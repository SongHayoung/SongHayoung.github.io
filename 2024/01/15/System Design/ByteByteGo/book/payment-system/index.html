<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[System Design] Payment System"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[System Design] Payment System | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Payment-System"><span class="toc-number">1.</span> <span class="toc-text">Payment System</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-1-Understand-the-Problem-and-Establish-Design-Scope"><span class="toc-number">2.</span> <span class="toc-text">Step 1 - Understand the Problem and Establish Design Scope</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Functional-requirements"><span class="toc-number">2.1.</span> <span class="toc-text">Functional requirements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Non-functional-requirements"><span class="toc-number">2.2.</span> <span class="toc-text">Non-functional requirements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Back-of-the-envelope-estimation"><span class="toc-number">2.3.</span> <span class="toc-text">Back-of-the-envelope estimation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-2-Propose-High-Level-Design-and-Get-Buy-In"><span class="toc-number">3.</span> <span class="toc-text">Step 2 - Propose High-Level Design and Get Buy-In</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pay-in-flow"><span class="toc-number">3.1.</span> <span class="toc-text">Pay-in flow</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#APIs-for-payment-service"><span class="toc-number">3.1.1.</span> <span class="toc-text">APIs for payment service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#The-data-model-for-payment-service"><span class="toc-number">3.1.2.</span> <span class="toc-text">The data model for payment service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Double-entry-ledger-system"><span class="toc-number">3.1.3.</span> <span class="toc-text">Double-entry ledger system</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hosted-payment-page"><span class="toc-number">3.1.4.</span> <span class="toc-text">Hosted payment page</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pay-out-flow"><span class="toc-number">3.2.</span> <span class="toc-text">Pay-out flow</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-3-Design-Deep-Dive"><span class="toc-number">4.</span> <span class="toc-text">Step 3 - Design Deep Dive</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PSP-integration"><span class="toc-number">4.1.</span> <span class="toc-text">PSP integration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reconciliation"><span class="toc-number">4.2.</span> <span class="toc-text">Reconciliation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handling-payment-processing-delays"><span class="toc-number">4.3.</span> <span class="toc-text">Handling payment processing delays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Communication-among-internal-services"><span class="toc-number">4.4.</span> <span class="toc-text">Communication among internal services</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handling-failed-payments"><span class="toc-number">4.5.</span> <span class="toc-text">Handling failed payments</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Tracking-payment-state"><span class="toc-number">4.5.1.</span> <span class="toc-text">Tracking payment state</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Retry-queue-and-dead-letter-queue"><span class="toc-number">4.5.2.</span> <span class="toc-text">Retry queue and dead letter queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exactly-once-delivery"><span class="toc-number">4.6.</span> <span class="toc-text">Exactly-once delivery</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Retry"><span class="toc-number">4.6.1.</span> <span class="toc-text">Retry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Idempotency"><span class="toc-number">4.6.2.</span> <span class="toc-text">Idempotency</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Consistency"><span class="toc-number">4.7.</span> <span class="toc-text">Consistency</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Payment-security"><span class="toc-number">4.8.</span> <span class="toc-text">Payment security</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-4-Wrap-Up"><span class="toc-number">5.</span> <span class="toc-text">Step 4 - Wrap Up</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-Summary"><span class="toc-number">6.</span> <span class="toc-text">Chapter Summary</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/hayoung-song-9523b61bb/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">11322</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">196</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">62</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[System Design] Payment System</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-01-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/System-Design-Interview/">System Design Interview</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4.1k</span><span class="post-meta__separator">|</span><span>Reading time: 25 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Payment-System"><a href="#Payment-System" class="headerlink" title="Payment System"></a>Payment System</h2><span id="more"></span>
<p>이 포스트에서는 결제 시스템을 설계한다. 최근 몇년 동안 전 세계적으로 전자상거래의 수요가 폭발적으로 증가했다. 모든 거래를 가능케 하는 것은 이면에서 작동하는 결제 시스템이다. 안정적이고 확장 가능하며 유연한 결제 시스템은 필수적이다.</p>
<p>결제 시스템이란 무엇인가? 위키백과에 따르면 결제 시스템은 금전적 가치의 이전을 통해 금융 거래를 정산하는데 사용되는 모든 시스템이다. 여기에는 교환을 가능하게 하는 기관, 도구, 사람, 규칙, 절차, 표준 및 기술이 포함된다.</p>
<h2 id="Step-1-Understand-the-Problem-and-Establish-Design-Scope"><a href="#Step-1-Understand-the-Problem-and-Establish-Design-Scope" class="headerlink" title="Step 1 - Understand the Problem and Establish Design Scope"></a>Step 1 - Understand the Problem and Establish Design Scope</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Candidate: What kind of payment system are we building?</span><br><span class="line">Interviewer: Assume you are building a payment backend for an e-commerce application like Amazon.com. When a customer places an order on Amazon.com, the payment system handles everything related to money movement.</span><br><span class="line"></span><br><span class="line">Candidate: What payment options are supported? Credit cards, PayPal, bank cards, etc?</span><br><span class="line">Interviewer: The payment system should support all of these options in real life. However, in this interview, we can use credit card payment as an example.</span><br><span class="line"></span><br><span class="line">Candidate: Do we handle credit card payment processing ourselves?</span><br><span class="line">Interviewer: No, we use third-party payment processors, such as Stripe, Braintree, Square, etc.</span><br><span class="line"></span><br><span class="line">Candidate: Do we store credit card data in our system?</span><br><span class="line">Interviewer: Due to extremely high security and compliance requirements, we do not store card numbers directly in our system. We rely on third-party payment processors to handle sensitive credit card data.</span><br><span class="line"></span><br><span class="line">Candidate: Is the application global? Do we need to support different currencies and international payments?</span><br><span class="line">Interviewer: Great question. Yes, the application would be global but we assume only one currency is used in this interview.</span><br><span class="line"></span><br><span class="line">Candidate: How many payment transactions per day?</span><br><span class="line">Interviewer: 1 million transactions per day.</span><br><span class="line"></span><br><span class="line">Candidate: Do we need to support the pay-out flow, which an e-commerce site like Amazon uses to pay sellers every month?</span><br><span class="line">Interviewer: Yes, we need to support that.</span><br><span class="line"></span><br><span class="line">Candidate: I think I have gathered all the requirements. Is there anything else I should pay attention to?</span><br><span class="line">Interviewer: Yes. A payment system interacts with a lot of internal services (accounting, analytics, etc.) and external services (payment service providers). When a service fails, we may see inconsistent states among services. Therefore, we need to perform reconciliation and fix any inconsistencies. This is also a requirement.</span><br></pre></td></tr></table></figure>
<h3 id="Functional-requirements"><a href="#Functional-requirements" class="headerlink" title="Functional requirements"></a>Functional requirements</h3><ul>
<li>Pay-in flow : 결제 시스템이 판매자를 대신해 고객으로부터 돈을 받는다.</li>
<li>Pay-out flow : 결제 시스템이 전 세계 판매자에게 돈을 송금한다.</li>
</ul>
<h3 id="Non-functional-requirements"><a href="#Non-functional-requirements" class="headerlink" title="Non-functional requirements"></a>Non-functional requirements</h3><ul>
<li>신뢰성 및 내결함성. 결제 실패는 신중하게 처리해야 한다.</li>
<li>내부 서비스(결제 시스템, 회계 시스템)와 외부 서비스(결제 서비스 프로바이더) 간의 조정 프로세스가 필요하다. 이 프로세스는 이런 시스템 간의 결제 정보가 일관성이 있는지 비동기적으로 확인한다.</li>
</ul>
<h3 id="Back-of-the-envelope-estimation"><a href="#Back-of-the-envelope-estimation" class="headerlink" title="Back-of-the-envelope estimation"></a>Back-of-the-envelope estimation</h3><p>시스템은 하루에 1백만 건의 트랜잭션을 처리해야 하는데, 이는 1,000,000건의 트랜잭션 / 10^5 sec = 10 TPS가 된다. 10 TPS는 일반적인 데이터베이스에서 큰 숫자가 아니므로 이 시스템 설계 인터뷰에서는 높은 처리량을 목표로 하기 보다는 결제 트랜잭션을 올바르게 처리하는 방법에 중점을 둔다.</p>
<h2 id="Step-2-Propose-High-Level-Design-and-Get-Buy-In"><a href="#Step-2-Propose-High-Level-Design-and-Get-Buy-In" class="headerlink" title="Step 2 - Propose High-Level Design and Get Buy-In"></a>Step 2 - Propose High-Level Design and Get Buy-In</h2><p>결제 흐름은 자금의 흐름을 반영하기 위해 크게 두 단계로 나뉜다.</p>
<ul>
<li>Pay-in Flow</li>
<li>Pay-out Flow</li>
</ul>
<p>전자상거래 사이트인 Amazon을 예로 들어 보자. 구매자가 주문을 하면 아마존의 은행 계좌로 돈이 유입되는데, 이것이 바로 결제 흐름이다. 돈이 아마존의 은행 게좌에 있지만 아마존이 모든 돈을 소유하는 것은 아니다. 판매자가 상당 부분을 소유하고 아마존은 수수료를 받고 자금 관리자의 역할만 수행한다. 나중에 제품이 배송되고 대금이 지급되면 수수료를 제외한 잔액이 아마존의 은행 계좌에서 판매자의 은행 계좌로 이동한다. 이것은 대금 지급 흐름이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240115232150828.png" alt=""></p>
<h3 id="Pay-in-flow"><a href="#Pay-in-flow" class="headerlink" title="Pay-in flow"></a>Pay-in flow</h3><p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240115232207288.png" alt=""></p>
<p><strong>Payment service</strong></p>
<p>결제 서비스는 사용자로부터 결제 이벤트를 수락하고 결제 프로세스를 조율한다. 일반적으로 가장 먼저 하는 일은 AML / CFT와 같은 규정을 준수하는지, 자금 세탁이나 테러 자금 조달과 같은 범죄 활동의 증거가 있는지 평가하는 위험 점검이다. 결제 서비스는 이 위험 검사를 통과한 결제만 처리한다. 일반적으로 위험 확인 서비스는 매우 복잡하고 고도로 전문화되어 있기 때문에 서드파티 프로바이더를 사용한다.</p>
<p><strong>Payment executor</strong></p>
<p>결제 실행자는 결제 서비스 공급업체(PSP)를 통해 단일 결제 주문을 실행한다. 결제 이벤트에는 여러 개의 결제 주문이 포함될 수 있다.</p>
<p><strong>Payment Service Provider (PSP)</strong></p>
<p>A 계정에서 B 계정으로 이동시킨다. 이 간단한 예제에서는 PSP가 구매자의 신용 카드 계정에서 돈을 이동시킨다.</p>
<p><strong>Card schemes</strong></p>
<p>카드사는 신용 카드 작업을 처리하는 조직이다.</p>
<p><strong>Ledger</strong></p>
<p>원장은 결제 거래에 대한 재무 기록을 보관한다. 예를 들어, 사용자가 판매자에게 1달러를 결제할 때 사용자로부터 1달러를 차변으로 인출하고 판매자에게 1달러를 대변으로 입금했다. 원장 시스템은 이커머스 웹사이트의 총 수익을 계산하거나 향후 수익을 예측하는 등 결제 후 분석에서 매우 중요하다.</p>
<p><strong>Wallet</strong></p>
<p>지갑은 판매자의 계정 잔액을 유지한다. 또한 특정 사용자가 결제한 총 금액을 기록할 수도 있다.</p>
<p>아래에서 볼 수 있듯이 일반적인 결제 흐름은 다음과 같이 동작한다.</p>
<ol>
<li>사용자가 주문하기 버튼을 클릭하면 결제 이벤트가 생성되어 결제 서비스로 전송된다.</li>
<li>결제 서비스는 결제 이벤트를 데이터베이스에 저장한다.</li>
<li>때로는 단일 결제 이벤트에 여러 개의 결제 주문이 포함될 수 있다. 예를 들어, 한 번의 결제 프로세스에서 여러 판매자의 제품을 선택할 수 있다. 전자상거래 웹사이트에서 결제를 여러 개의 결제 주문으로 분할하는 경우 결제 서비스는 각 결제 주문에 대해 결제 실행 업체를 호출한다.</li>
<li>결제 처리기는 결제 주문을 데이터베이스에 저장한다.</li>
<li>결제 처리기는 외부 PSP를 호출해 신용 카드 결제를 처리한다.</li>
<li>결제 처리자가 결제를 성공적으로 처리한 후 결제 서비스는 지갑을 업데이트해 특정 판매자가 보유한 금액을 기록한다.</li>
<li>지갑 서버는 업데이트된 잔액 정보를 데이터베이스에 저장한다.</li>
<li>지갑 서비스가 판매자의 잔액 정보를 성공적으로 업데이트하면 결제 서비스에서 원장을 호출해 원장을 업데이트한다.</li>
<li>원장 서비스는 새 원장 정보를 데이터베이스에 추가한다.</li>
</ol>
<h4 id="APIs-for-payment-service"><a href="#APIs-for-payment-service" class="headerlink" title="APIs for payment service"></a>APIs for payment service</h4><p>결제 서비스는 RESTful API 설계 규칙을 사용한다.</p>
<p><strong>POST /v1/payments</strong></p>
<p>이 엔트포인트는 결제 이벤트를 실행한다. 단일 결제 이벤트에는 여러 결제 주문이 포함될 수 있다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Field</strong></th>
<th style="text-align:left"><strong>Description</strong></th>
<th style="text-align:left"><strong>Type</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">buyer_info</td>
<td style="text-align:left">The information of the buyer</td>
<td style="text-align:left">json</td>
</tr>
<tr>
<td style="text-align:left">checkout_id</td>
<td style="text-align:left">A globally unique ID for this checkout</td>
<td style="text-align:left">string</td>
</tr>
<tr>
<td style="text-align:left">credit_card_info</td>
<td style="text-align:left">This could be encrypted credit card information or a payment token. The value is PSP-specific.</td>
<td style="text-align:left">json</td>
</tr>
<tr>
<td style="text-align:left">payment_orders</td>
<td style="text-align:left">A list of the payment orders</td>
<td style="text-align:left">list</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Field</strong></th>
<th style="text-align:left"><strong>Description</strong></th>
<th style="text-align:left"><strong>Type</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">seller_account</td>
<td style="text-align:left">Which seller will receive the money</td>
<td style="text-align:left">string</td>
</tr>
<tr>
<td style="text-align:left">amount</td>
<td style="text-align:left">The transaction amount for the order</td>
<td style="text-align:left">string</td>
</tr>
<tr>
<td style="text-align:left">currency</td>
<td style="text-align:left">The currency for the order</td>
<td style="text-align:left">string (ISO 4217)</td>
</tr>
<tr>
<td style="text-align:left">payment_order_id</td>
<td style="text-align:left">A globally unique ID for this payment</td>
<td style="text-align:left">string</td>
</tr>
</tbody>
</table>
</div>
<p><code>payment_order_id</code>는 전 세계적으로 고유하다. 결제 처리자가 서드파티 PSP에 결제 요청을 전송할 때 PSP는 idempotency 키라고 하는 중복 제거 ID로 payment_order_id를 사용한다.</p>
<p>“amount” 필드의 데이터 유형이 double이 아닌 string이라는 부분도 중요하다. 프로토콜, 소프트웨어, 하드웨어에 따라 직렬화 및 역직렬화에서 서로 다른 숫자 정밀도를 지원할 수 있다. 이 차이로 인해 의도하지 않은 반올림 오류가 발생할 수 있다.</p>
<p>전송 및 저장 시 숫자를 문자열 형식으로 보관하는 것이 좋다. 숫자는 표시나 계산에 사용할 때만 숫자로 파싱시킨다.</p>
<p><strong>GET /v1/payments/{:id}</strong></p>
<p>이 엔드포인트는 <code>payment_order_id</code>를 기준으로 단일 결제 주문의 실행 상태를 반환한다. 위에서 언급한 결제 API는 잘 알려진 몇몇 PSP의 API와 유사하다.</p>
<h4 id="The-data-model-for-payment-service"><a href="#The-data-model-for-payment-service" class="headerlink" title="The data model for payment service"></a>The data model for payment service</h4><p>결제 서비스에는 결제 이벤트와 결제 주문이라는 두 개의 테이블이 필요하다. 결제 시스템용 스토리지 솔루션을 선택할 때 일반적으로 성능은 가장 중요한 요소가 아니다. 대신 다음 사항을 중점적으로 둔다.</p>
<ul>
<li>검증된 안정성. 해당 스토리지 시스템이 다른 대형 금융 회사에서 수년 동안 긍정적 피드백을 받으며 사용되는지 여부</li>
<li>모니터링 및 서포팅 도구와 같은 지원 도구의 풍부함</li>
<li>DBA 채용 시장의 성숙도</li>
</ul>
<p>보통은 NoSQL / NewSQL보다 ACID 트랜잭션을 지원하는 전통적인 관계형 데이터베이스를 선호한다. 결제 이벤트 테이블에는 자세한 결제 이벤트 정보가 포함되어 있다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Name</strong></th>
<th style="text-align:left"><strong>Type</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">checkout_id</td>
<td style="text-align:left">string <strong>PK</strong></td>
</tr>
<tr>
<td style="text-align:left">buyer_info</td>
<td style="text-align:left">string</td>
</tr>
<tr>
<td style="text-align:left">seller_info</td>
<td style="text-align:left">string</td>
</tr>
<tr>
<td style="text-align:left">credit_card_info</td>
<td style="text-align:left">depends on the card provider</td>
</tr>
<tr>
<td style="text-align:left">is_payment_done</td>
<td style="text-align:left">boolean</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Name</strong></th>
<th style="text-align:left"><strong>Type</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">payment_order_id</td>
<td style="text-align:left">String <strong>PK</strong></td>
</tr>
<tr>
<td style="text-align:left">buyer_account</td>
<td style="text-align:left">string</td>
</tr>
<tr>
<td style="text-align:left">amount</td>
<td style="text-align:left">string</td>
</tr>
<tr>
<td style="text-align:left">currency</td>
<td style="text-align:left">string</td>
</tr>
<tr>
<td style="text-align:left">checkout_id</td>
<td style="text-align:left">string <strong>FK</strong></td>
</tr>
<tr>
<td style="text-align:left">payment_order_status</td>
<td style="text-align:left">string</td>
</tr>
<tr>
<td style="text-align:left">ledger_updated</td>
<td style="text-align:left">boolean</td>
</tr>
<tr>
<td style="text-align:left">wallet_updated</td>
<td style="text-align:left">boolean</td>
</tr>
</tbody>
</table>
</div>
<p>테이블에 대해 자세히 알아보기 전에 몇 가지 백그라운드 정보를 살펴보자.</p>
<ul>
<li>checkout_id는 외래 키다. 단일 결제는 여러 결제 주문을 포함할 수 있는 결제 이벤트를 생성한다.</li>
<li>구매자의 신용 카드에서 금액을 공제하기 위해 서드파티 PSP를 호출하면 금액이 판매자에게 직접 이체되지 않는다. 대신 이 금액은 전자상거래 웹사이트의 은행 계좌로 이체된다. 이 프로세스를 페이인이라고 한다. 제품이 배송되는 등 대금 지급 조건이 충족되면 판매자는 대금 지급을 시작한다. 그래야만 이커머스 웹사이트의 은행 계좌에서 판매자의 은행 계좌로 금액이 이체된다. 따라서 결제 흐름 중에는 판매자의 은행 계좌 정보가 아닌 구매자의 카드 정보만 필요하다.</li>
</ul>
<p>결제 주문 테이블에서 <code>payment_order_status</code>는 결제 주문의 실행 상태를 보관하는 enum이다. 실행 상태에는 NOT_STARTED, 실행 중, 성공, 실패가 포함된다. 업데이트 로직은 다음과 같다.</p>
<ol>
<li><code>payment_order_status</code>의 초기 상태는 NOT_STARTED다.</li>
<li>결제 서비스에서 결제 주문을 결제 처리자에게 전송하면 결제 주문 상태는 EXECUTING이다.</li>
<li>결제 서비스는 결제 처리자의 응답에 따라 payment_order_status를 SUCCESS 또는 FAILED로 업데이트한다.</li>
</ol>
<p>결제 서비스에서 결제 주문 상태가 성공하면 지갑 서비스를 호출해 판매자 잔액을 업데이트하고 wallet_updated 필드를 TRUE로 업데이트 한다. 여기서는 지갑 업데이트가 항상 성공한다고 가정해 설계를 단순화했다.</p>
<p>지갑 업데이트가 완료되면 결제 서비스의 다음 단계는 원장 서비스를 호출해 ledger_updated 필드를 TRUE로 업데이트해 원장 데이터베이스를 업데이트하는 것이다.</p>
<p>동일한 checkout_id에 해당하는 모든 결제 주문이 성공적으로 처리되면 결제 서비스는 결제 이벤트 테이블에서 <code>is_payment_done</code>을 TRUE로 업데이트한다. 예약된 작업은 일반적으로 결제 주문의 상태를 모니터링하기 위해 고정된 간격으로 실행된다. 결제 주문이 임계값 내에 완료되지 않으면 엔지니어가 이를 조사할 수 있도록 경고를 보낸다.</p>
<h4 id="Double-entry-ledger-system"><a href="#Double-entry-ledger-system" class="headerlink" title="Double-entry ledger system"></a>Double-entry ledger system</h4><p>원장 시스템에는 매우 중요한 설계 원칙이 있는데, 바로 double-entry principle(double-entry accounting/bookkeeping) 이다. Double-entry 시스템은 모든 결제 시스템의 기본이며 정확한 장부 기장의 핵심이다. Double-entry 방식은 모든 결제 거래를 동일한 금액의 두 개의 별도 원장 계좌에 기록한다. 한 계정에서는 동일한 금액이 인출되고 다른 계정에서는 동일한 금액이 입금된다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Account</th>
<th style="text-align:left">Debit</th>
<th style="text-align:left">Credit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">buyer</td>
<td style="text-align:left">$1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">seller</td>
<td style="text-align:left"></td>
<td style="text-align:left">$1</td>
</tr>
</tbody>
</table>
</div>
<p>Double-entry 시스템에서는 모든 거래 항목의 합계가 0이어야 한다. 1센트를 잃어버리면 다른 사람이 1센트를 얻게 된다. 이 시스템은 E2E 추적 기능을 제공하며 결제 주기 전반에 걸쳐 일관성을 보장한다. </p>
<h4 id="Hosted-payment-page"><a href="#Hosted-payment-page" class="headerlink" title="Hosted payment page"></a>Hosted payment page</h4><p>대부분의 기업은 신용카드 정보를 내부에 저장하지 않는 것을 선호하는데, 이는 신용카드 정보를 내부에 저장할 경우 미국의 PCI DSS와 같은 복잡한 규정을 준수해야 하기 때문이다. 신용카드 정보를 취급하지 않기 위해 기업들은  PSP에서 제공하는 호스팅 신용카드 페이지를 사용한다. 웹사이트의 경우 위젯이나 iframe으로, 모바일 애플리케이션의 경우 결제 SDK에서 미리 빌드된 페이지일 수 있다. 여기서 핵심은 PSP가 당사의 결제 서비스에 의존하지 않고 고객 카드 정보를 직접 캡처하는 호스팅된 결제 페이지를 제공한다는 점이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240115234413520.png" alt=""></p>
<h3 id="Pay-out-flow"><a href="#Pay-out-flow" class="headerlink" title="Pay-out flow"></a>Pay-out flow</h3><p>지급액 흐름의 구성 요소는 지급액 흐름과 매우 유사하다. 한 가지 차이점은 PSP를 사용해 구매자의 신용 카드에서 이커머스 웹사이트의 은행 계좌로 돈일 이체하는 대신, 지급액 흐름에서는 서드파티 지급 서비스 프로바이더를 사용해 이커머스 웹사이트의 은행 계좌에서 판매자의 은행 계좌로 돈을 이체한다는 점이다.</p>
<p>일반적으로 결제 시스템에서는 Tipalti와 같은 서드파티 대금 지급 서비스 프로바이더를 사용해 대금 지급을 처리한다.</p>
<h2 id="Step-3-Design-Deep-Dive"><a href="#Step-3-Design-Deep-Dive" class="headerlink" title="Step 3 - Design Deep Dive"></a>Step 3 - Design Deep Dive</h2><p>이 섹션에서는 시스템을 더 빠르고 견고하고 안전하게 만드는데 중점을 둔다. 분산 시스템에서 오류와 장애는 피할 수 없을 뿐만 아니라 흔한 일이다. 이 섹션에서는 몇 가지 주요 주제를 살펴본다.</p>
<ul>
<li>PSP integration</li>
<li>Reconciliation</li>
<li>Handling payment processing delays</li>
<li>Communication among internal services</li>
<li>Handling failed payments</li>
<li>Exact-once delivery</li>
<li>Consistency</li>
<li>Security</li>
</ul>
<h3 id="PSP-integration"><a href="#PSP-integration" class="headerlink" title="PSP integration"></a>PSP integration</h3><p>결제 시스템이 은행이나 비자 또는 마스터카드와 같은 카드 시스템에 직접 연결할 수 있는 경우 PSP 없이도 결제가 가능하다. 이런 직접 연결은 흔하지 않고 고도로 전문화되어 있다. 일반적으로 이런 투자를 정당화할 수 있는 매우 큰 회사에서만 사용할 수 있다. 대부분의 기업에서는 두 가지 방법 중 하나로 결제 시스템을 PSP와 통합한다.</p>
<ul>
<li>회사가 민감한 결제 정보를 안전하게 저장할 수 있고 그렇게 하기로 선택한 경우, API를 사용해 PSP를 통합할 수 있다. 회사는 결제 웹페이지를 개발하고 민감한 결제 정보를 수집 및 저장할 책임이 있다. PSP는 은행 또는 카드 시스템에 연결할 책임이 있다.</li>
<li>회사가 복잡한 규정 및 보안 문제로 인해 민감한 결제 정보를 저장하지 않기로 선택한 경우 PSP는 카드 결제 세부 정보를 수집해 PSP에 안전하게 저장할 수 있는 호스팅 결제 페이지를 제공한다. 이는 대부분의 기업이 취하는 접근 방식이다.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240116215726092.png" alt=""></p>
<p>위에서는 단순화를 위해 executor, ledger, wallet을 생략했다. 결제 서비스는 전체 결제 프로세스를 오케스트레이션 한다.</p>
<ol>
<li><p>사용자는 클라이언트 브라우저에서 “결제” 버튼을 클릭한다. 클라이언트는 결제 주문 정보와 함께 결제 서비스를 호출한다.</p>
</li>
<li><p>결제 주문 정보를 수신한 후 결제 서비스는 결제 등록 요청을 PSP에 전송한다. 이 등록 요청에는 결제 금액, 통화, 결제 요청의 만료일, 리디렉션 URL 등의 결제 정보가 포함된다. 결제 주문은 한 번만 등록해야 하므로 정확히 한 번만 등록할 수 있도록 UUID 필드가 있다. 이 UUID를 nonce라고도 한다. 일반적으로 이 UUID는 결제 주문의 ID다.</p>
</li>
<li><p>PSP는 결제 서비스에 토큰을 반환한다. 토큰은 결제 등록을 고유하게 식별하는 PSP측의 UUID다. 나중에 이 토큰을 사용해 결제 등록 및 결제 실행 상태를 확인할 수 있다.</p>
</li>
<li><p>결제 서비스는 PSP가 호스팅하는 결제 페이지를 호출하기 전에 토큰을 데이터베이스에 저장한다.</p>
</li>
<li><p>토큰이 유지되면 클라이언트는 PSP 호스팅 결제 페이지를 표시한다. 모바일 애플리케이션은 일반적으로 이 기능을 위해 PSP의 SDK 통합을 선택한다. 여기서는 Stripe의 웹 통합을 예로 든다. Stripe는 결제 UI를 표시하고, 민감한 결제 정보를 수집하며 결제를 완료하기 위해 PSP를 직접 호출하는 JavaScript 라이브러리를 제공한다. 민감한 결제 정보는 Stripe에서 수집한다. 당사의 결제 시스템에는 절대로 도달하지 않는다. 호스팅된 결제 페이지에는 일반적으로 두 가지 정보가 필요하다.</p>
<ol>
<li>4단계에서 받은 토큰. PSP의 JS 코드는 이 토큰을 사용해 PSP의 백엔드에서 결제 요청에 대한 자세한 정보를 검색한다. 중요한 정보 중 하나는 수집할 금액이다.</li>
<li>또 다른 중요한 정보는 리디렉션 URL이다. 이는 결제가 완료될 때 호출되는 웹 페이지 URL이다. PSP의 자바스크립트가 결제를 완료하면 브라우저를 리디렉션 URL로 리디렉션한다. 일반적으로 리디렉션 URL은 결제 상태를 표시하는 전자상거래 웹 페이지다. 리디렉션 URL은 추후 이야기할 웹훅과는 다르다.</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240116220313752.png" alt=""></p>
</li>
<li>사용자는 신용 카드 번호, 소유자 이름, 만료일 등 결제 세부 정보를 PSP의 웹 페이지에 입력한 다음 결제 버튼을 클릭한다. PSP에서 결제 처리가 시작된다.</li>
<li>PSP가 결제 상태를 반환한다.</li>
<li>이제 웹 페이지가 리디렉션 URL로 리디렉션 된다. 7단계에서 수신한 결제 상태는 일반적으로 URL에 추가된다. 예를 들어, 전체 리디렉션 URL은 <code>https://your-company.com/?tokenID=JIOUIQ123NSF&amp;payResult=X324FSa</code> 다.</li>
<li>비동기적으로 PSP는 웹훅을 통해 결제 상태와 함께 결제 서비스를 호출한다. 웹훅은 결제 시스템 측에서 PSP를 처음 설정할 때 PSP에 등록한 URL이다. 결제 시스템이 웹훅을 통해 결제 이벤트를 수신하면 결제 상태를 추출해 결제 주문 데이터베이스 테이블의 <code>payment_order_status</code> 필드를 업데이트한다.</li>
</ol>
<p>지금 까지 호스팅된 결제 페이지의 성공 패스에 대해 설명했다. 실제로는 네트워크로 인해 모든 단계가 실패할 수 있으며 실패 사례를 체계적으로 처리하는 방법을 살펴본다.</p>
<h3 id="Reconciliation"><a href="#Reconciliation" class="headerlink" title="Reconciliation"></a>Reconciliation</h3><p>시스템 구성 요소가 비동기식으로 통신하는 경우, 메세지가 전달되거나 응답이 반환된다는 보장이 없다. 이는 시스템 성능을 향상시키기 위해 비동기 통신을 자주 사용하는 결제 비즈니스에서 매우 일반적이다. PSP나 은행과 같은 외부 시스템도 비동기 통신을 선호한다. 이 경우 어떻게 정확성을 보장할까?</p>
<p>정답은 Reconciliation다. 이는 관련 서비스간의 상태를 주기적으로 비교하여 일치하는지 확인하는 관행이다. 일반적으로 결제 시스템의 마지막 방어선이다. 매일밤 PSP나 은행은 고객에세 정산 파일을 보낸다. 정산 파일에는 은행 계좌의 잔액과 함께 하루 동안 이 은행 계좌에서 발생한 모든 거래가 포함된다. 조정 시스템은 정산 파일을 파싱해 세부 정보를 원장 시스템과 비교한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240116220800225.png" alt=""></p>
<p>Reconciliation은 결제 시스템이 내부적으로 일관성이 있는지 확인하는데도 사용된다. 예를 들어, 원장과 지갑의 상태가 서로 다를 수 있는데 Reconciliation 시스템을 사용해 불일치를 감지할 수 있다.</p>
<p>Reconciliation 중에 발견된 불일치를 수정하기 위해 일반적으로 재무팀에서 수동 조정을 수행한다. 불일치 및 조정은 일반적으로 세 가지 범주로 분류된다.</p>
<ul>
<li>불일치를 분류할 수 있고 조정을 자동화할 수 있는 경우. 이 경우 불일치의 원인과 해결 방법을 알고 있으며 조정을 자동화하는 프로그램을 작성하는 것이 비용 효율적이다. 엔지니어는 미스매치 분류와 조정을 모두 자동화할 수 있다.</li>
<li>불일치 분류는 가능하지만 조정은 자동화할 수 없는 경우. 이 경우 불일치의 원인과 해결 방법을 알고 있지만 자동 조정 프로그램을 작성하는데 드는 비용이 너무 높다. 불일치를 작업 대기열에 넣고 재무팀에서 수동으로 불일치를 수정한다.</li>
<li>불일치를 분류할 수 없는 경우. 이 경우 불일치가 어떻게 발생하는지 알 수 없다. 불일치 작업은 특별 작업 대기열에 넣는다. 재무팀이 이를 수동으로 조사한다.</li>
</ul>
<h3 id="Handling-payment-processing-delays"><a href="#Handling-payment-processing-delays" class="headerlink" title="Handling payment processing delays"></a>Handling payment processing delays</h3><p>앞서 설명한 것처럼 E2E 결제 요청은 여러 구성 요소를 거치며 내부 및 외부 당사자가 모두 관여한다. 대부분의 경우 결제 요청은 몇 초 안에 완료되지만, 결제 요청이 지연되어 완료되거나 거부되기까지 몇 시간 또는 며칠이 걸리는 경우도 있다. 다음은 결제 요청이 평소보다 오래 걸릴 수 있는 몇 가지 예다.</p>
<ul>
<li>PSP가 결제 요청을 고위험으로 간주하여 사람이 검토해야 하는 경우</li>
<li>신용카드는 구매를 확인하기 위해 카드 소유자의 추가 세부 정보를 요구하는 3D 보안 인증과 같은 추가 보호가 필요하다.</li>
</ul>
<p>결제 서비스는 처리하는데 시간이 오래 걸리는 이런 결제 요청을 처리할 수 있어야 한다. 구매 페이지가 외부 PSP와 호스팅 되는 경우, PSP는 다음과 같은 방식으로 이런 장기 결제 요청을 처리한다.</p>
<ul>
<li>PSP는 보류 중 상태를 클라이언트에 반환한다. 클라이언트는 이를 사용자에게 표시한다. 또한 클라이언트는 고객이 현재 결제 상태를 확인할 수 있는 페이지를 제공한다.</li>
<li>PSP는 당사를 대신해 보류중인 결제를 추적하고 결제 서비스에 등록된 웹훅을 통해 결제 서비스에 상태 업데이트를 알린다.</li>
</ul>
<p>결제 요청이 최종적으로 완료되면 PSP는 위에서 언급한 등록된 웹훅을 호출한다. 결제 서비스는 내부 시스템을 업데이트하고 고객에게 배송을 완료한다.</p>
<p>또는 웹훅을 통해 결제 서비스를 업데이트하는 대신 일부 PSP는 결제 서비스에 보류 중인 결제 요청에 대한 상태 업데이트를 위해 PSP를 폴링하는 부담을 줄 수 있다.</p>
<h3 id="Communication-among-internal-services"><a href="#Communication-among-internal-services" class="headerlink" title="Communication among internal services"></a>Communication among internal services</h3><p>내부 서비스에서 통신하는데 사용되는 통신 패턴에는 동기식과 비동기식 두 가지 유형이 있다. </p>
<p><strong>Synchronous communication</strong></p>
<p>HTTP와 같은 동기식 통신은 소규모 시스템에서는 잘 작동하지만 규모가 커질수록 단점이 분명해진다. 많은 서비스에 의존하는 긴 요청 및 응답 주기가 발생한다. 이 접근 방식의 단점은 다음과 같다.</p>
<ul>
<li>낮은 성능. 체인된 서비스 중 하나라도 실패하면 전체 시스템이 영향을 받는다.</li>
<li>열악한 장애 격리. PSP 또는 기타 서비스에 장애가 발생하면 클라이언트는 더 이상 응답을 받지 못한다.</li>
<li>긴밀한 연결. 요청 발신자는 수신자를 알아야 한다.</li>
<li>낮은 확장성. 버퍼 역할을 하는 대기열을 사용하지 않으면 갑작스러운 트래픽 증가를 지원하기 위해 시스템을 확장하기가 쉽지 않다.</li>
</ul>
<p><strong>Asynchronous communication</strong></p>
<p>비동기 통신은 두 가지 범주로 나눌 수 있다.</p>
<ul>
<li>단일 수신자 : 각 요청(메세지)이 하나의 수신자 또는 서비스에서 처리된다. 일반적으로 공유 메세지 큐를 통해 구현된다. 메세지 대기열에는 여러 명의 가입자가 있을 수 있지만 메세지가 처리되면 대기열에서 제거된다. </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240116221700624.png" alt=""></p>
<ul>
<li>다중 수신자 : 각 요청(메세지)는 여러 수신자 또는 서비스에서 처리된다. 카프카는 여기서 잘 작동한다. 소비자가 메세지를 수신할 때 카프카에서 제거되지 않는다. 동일한 메세지를 여러 서비스에서 처리할 수 있다. 동일한 요청이 푸시 알림 전송, 재무 보고, 분석 업데이트 등과 같은 여러 가지 부작용을 유발할 수 있기 때문에 이 모델은 결제 시스템에 잘 매핑된다.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240116221805409.png" alt=""></p>
<p>일반적으로 동기식 통신은 설계가 더 간단하지만 서비스가 자율적으로 작동할 수 없다. 종속성 그래프가 커지만 전반적인 성능이 저하된다. 비동기식 통신은 설계의 단순성과 일관성을 확장성과 장애 복원력을 위해 희생한다. 비즈니스 로직이 복잡하고 타사 종속성이 많은 대규모 결제 시스템의 경우 비동기 통신이 더 나은 선택이다.</p>
<h3 id="Handling-failed-payments"><a href="#Handling-failed-payments" class="headerlink" title="Handling failed payments"></a>Handling failed payments</h3><p>모든 결제 시스템은 거래 실패를 처리해야 한다. 신뢰성과 내결함성은 핵심 요건이다. 이런 문제를 해결하기 위한 몇 가지 기술을 살펴보자.</p>
<h4 id="Tracking-payment-state"><a href="#Tracking-payment-state" class="headerlink" title="Tracking payment state"></a>Tracking payment state</h4><p>결제 주기의 어느 단계에서든 결제 상태를 명확히 파악하는 것은 매우 중요하다. 실패가 발생할 때마다 결제 거래의 현재 상태를 파악해 재시도 또는 환불이 필요한지 여부를 결정할 수 있다. 결제 상태는 추가 전용 데이터베이스 테이블에 유지될 수 있다.</p>
<h4 id="Retry-queue-and-dead-letter-queue"><a href="#Retry-queue-and-dead-letter-queue" class="headerlink" title="Retry queue and dead letter queue"></a>Retry queue and dead letter queue</h4><p>실패를 정상적으로 처리하기 위해 아래 표시된 것처럼 재시도 큐와 데드레터 큐를 활용한다.</p>
<ul>
<li>재시도 큐 : 일시적인 오류와 같이 재시도 가능한 오류는 재시도 큐로 라우팅 된다.</li>
<li>데드레터 큐 : 메세지가 반복적으로 실패하면 결국 데드레터 큐에 들어간다. 데드레터 큐는 문제가 있는 메세지를 디버깅하고 격리해 성공적으로 처리되지 않은 이유를 확인하기 위해 검사하는데 유용하다.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240116222110432.png" alt=""></p>
<ol>
<li>실패를 다시 시도할 수 있는지 확인한다.<ol>
<li>재시도 가능한 실패는 재시도 대기열로 라우팅 된다.</li>
<li>잘못된 입력과 같이 재시도할 수 없는 실패의 경우 오류가 데이터베이스에 저장된다.</li>
</ol>
</li>
<li>결제 시스템은 재시도 대기열에서 이벤트를 소비하고 실패한 결재 거래를 재시도한다.</li>
<li>결제 거래가 다시 실패하는 경우<ol>
<li>재시도 횟수가 임계값을 초과하기 않는 경우 이벤트가 재시도 대기열로 라우팅된다.</li>
<li>재시도 횟수가 임계값을 초과하면 이벤트가 사서함 대기열에 배치된다. 이런 실패한 이벤트는 조사해야 할 수도 있다.</li>
</ol>
</li>
</ol>
<h3 id="Exactly-once-delivery"><a href="#Exactly-once-delivery" class="headerlink" title="Exactly-once delivery"></a>Exactly-once delivery</h3><p>결제 시스템에서 발생할 수 있는 가장 심각한 문제 중 하나는 고객에게 이중으로 청구하는 것이다. 결제 시스템이 결제 주문을 정확히 한번만 실행하도록 설계하는 것이 중요하다.</p>
<p>언뜻 보기에 정확히 한 번만 결제하는 것은 해결하기 매우 어려워 보이지만, 문제를 두 부분으로 나누면 훨씬 쉽게 해결할 수 있다. 수학적으로 연산은 정확히 한 번만 실행된다.</p>
<ol>
<li>적어도 한번은 실행된다.</li>
<li>동시에 최대 한 번 실행된다.</li>
</ol>
<p>재시도를 사용해 최소 한 번을 구현하는 방법과 최대 한 번을 구현하는 방법을 살펴보자.</p>
<h4 id="Retry"><a href="#Retry" class="headerlink" title="Retry"></a>Retry</h4><p>네트워크 오류나 시간 초과로 인해 결제 트랜잭션을 다시 시도해야 하는 경우가 있다. 재시도는 최소 1회 보장을 제공한다. 예를 들어, 아래와 같이 클라이언트가 10달러 결제를 시도했지만 네트워크 연결 상태가 좋지 않아 결제 요청이 계속 실패하는 경우를 생각해 보자. 이 예에서는 네트워크가 결국 복구되어 네 번째 시도에서 요청이 성공했다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240116225828574.png" alt=""></p>
<p>재시도 사이의 적절한 시간 간격을 결정하는 것이 중요하다. 다음은 몇 가지 일반적 재시도 전략이다.</p>
<ul>
<li>Immediate retry: 클라이언트가 즉시 요청을 다시 보냄</li>
<li>Fixed intervals: 실패 시점으로 부터 새로운 재시도 요청까지 일정 시간 동안 대기</li>
<li>Incremental intervals: 클라이언트가 재시도를 지속적으로 실행할 수록 재시도 대기 시간을 점진적으로 늘림</li>
<li>Exponential backoff: 재시도에 실패할 때마다 재시도 사이의 대기 시간을 두 배로 늘림</li>
<li>Cancel: 클라이언트가 요청을 취소함. 이는 실패가 영구적이거나 반복되는 요청이 성공할 가능성이 낮을 때 일반적으로 사용됨</li>
</ul>
<p>적절한 재시도 전략을 결정하는 것은 어렵다. “모든 것에 맞는 해결책”은 없다. 일반적인 가이드라인으로, 네트워크 문제가 단 시간 내에 해결될 것 같지 않은 경우 Exponential backoff를 사용하는 것이 좋다. 지나치게 공격적인 재시도 전략은 컴퓨팅 리소스를 낭비하고 서비스 과부하를 유발할 수 있다. 재시도 후 헤더오 ㅏ함께 오류 코드를 제공하는 것이 좋다.</p>
<p>재시도의 잠재적인 문제는 이중 결제다. 두 가지 시나리오를 살펴보자. </p>
<ul>
<li>시나리오 1 : 결제 시스템이 호스팅된 결제 페이지를 사용해 PSP와 통합되고 클라이언트가 결제 버튼을 두 번 클릭한다.</li>
<li>시나리오 2 : PSP에서 결제가 성공적으로 처리되었지만 네트워크 오류로 인해 결제 시스템에 응답이 도달하지 못한다. 사용자가 결제 버튼을 다시 클릭하거나 클라이언트가 결제를 다시 시도한다.</li>
</ul>
<p>이중 결제를 방지하려면 결제가 한 번에 실행되어야 한다. 이런 즉시 결제 보장을 무효화 라고도 한다.</p>
<h4 id="Idempotency"><a href="#Idempotency" class="headerlink" title="Idempotency"></a>Idempotency</h4><p>At-most-once를 보장하기 위해서는 멱등성이 핵심이다. 멱등성은 “수학 및 컴퓨터 과학에서 특정 연산의 속성으로, 최조 적용 이후에도 결과를 변경하지 않고 여러 번 적용할 수 있다”는 특성으로 알려져 있다. API 관점에서 비동시성은 클라이언트가 동일한 호출을 반복적으로 수행해 동일한 결과를 생성할 수 있음을 의미한다. 클라이언트(웹 및 모바일 애플리케이션)과 서버 간의 통신에서 비동시성 키는 일반적으로 클라이언트가 생성하고 일정 시간이 지나면 만료되는 고유 값이다. UUID는 일반적으로 비활성 키로 사용되며 Stripe, PayPal과 같은 많은 기술 회사에서 권장하는 키다. 멱등한 결제 요청을 수행하려면 HTTP 헤더에 멱등 키가 추가된다 <code>&lt;idempotency-key: key_value&gt;</code>. 이제 멱등성의 기본 사항을 이해했으니 이중 결제 문제 해결에 대해 살펴보자.</p>
<p><strong>Scenario 1: what if a customer clicks the “pay” button quickly twice?</strong></p>
<p>사용자가 “결제”를 클릭하면 HTTP 요청의 일부로 멱등키가 결제 시스템으로 전송된다. 이커머스 웹사이트에서 멱등키는 일반적으로 결제 직전 장바구니의 ID다.</p>
<p>두 번째 요청의 경우 결제 시스템에서 이미 멱등키를 확인했기 때문에 재시도로 처리된다. 요청 헤더에 이전에 지정한 멱등키를 포함하면 결제 시스템에서 이전 요청의 최신 상태를 반환한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240116232049412.png" alt=""></p>
<p>동일한 멱등키로 여러 개의 동시 요청이 감지되면 하나의 요청만 처리되고 나머지 요청은 “429 Too Many Requests” 상태 코드를 받는다.</p>
<p>비동시성을 지원하기 위해 데이터베이스의 고유 키 제약 조건을 사용할 수 있다. 예를 들어 데이터베이스 테이블의 기본 키가 멱등키로 제공된다.</p>
<ol>
<li>결제 시스템이 결제를 받으면 데이터베이스 테이블에 행을 삽입하려고 시도한다.</li>
<li>삽입이 성공하면 이전에 이 결제 요청을 본 적이 없다는 뜻이다.</li>
<li>동일한 기본 키가 이미 존재하기 때문에 삽입이 실패하면 이전에 이 결제 요청을 본 적이 있다는 뜻이다. 두 번째 요청은 처리되지 않는다.</li>
</ol>
<p><strong>Scenario 2: The payment is successfully processed by the PSP, but the response fails to reach our payment system due to network errors. Then the user clicks the “pay” again.</strong></p>
<p>아래 표시된 것처럼 결제 서비스에서 PSP에 nonce를 전송하면 PSP는 해당 토큰을 반환한다. Nonce는 결제 순서를 고유하게 나타내며 토큰은 nonce에 고유하게 매핑된다. 따라서 토큰은 결제 주문에 고유하게 매핑된다.</p>
<p>사용자가 “결제” 버튼을 다시 클릭하면 결제 순서가 동일하므로 PSP로 전송되는 토큰도 동일하다. 토큰은 PSP 측에서 아이덴티티 키로 사용되기 때문에 이중 결제를 식별하고 이전 실행 상태를 반환할 수 있다.</p>
<h3 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h3><p>결제 실행 시 여러 stateful 서비스가 호출된다.</p>
<ol>
<li>결제 서비스는 nonce, 토큰, 결제 순서, 실행 상태 등 결제 관련 데이터를 보관한다.</li>
<li>원장은 모든 회계 데이터를 보관한다.</li>
<li>지갑은 판매자의 계정 잔액을 보관한다.</li>
<li>PSP는 결제 실행 상태를 유지한다.</li>
<li>데이터는 안정성을 높이기 위해 서로 다른 데이터베이스 복제본 간에 복제될 수 있다.</li>
</ol>
<p>분산 환경에서는 두 서비스 간의 통신이 실패하여 데이터 불일치가 발생할 수 있다. 결제 시스템에서 데이터 불일치를 해결하기 위한 몇 가지 기술을 살펴보자.</p>
<p>내부 서비스 간의 데이터 일관성을 유지하려면 정확히 한 번 처리를 보장하는 것이 매우 중요하다. 내부 서비스와 외부 서비스 간의 데이터 일관성을 유지하기 위해 일반적으로 멱등성 및 조정에 의존한다. 외부 서비스에서 아이덴티티를 지원하는 경우, 결제 재시도 작업에 동일한 아이덴티티 키를 사용해야 한다. 외부 서비스가 아이덴티티 비활성화 API를 지원하더라도 외부 시스템이 항상 옳다고 가정해서는 안되므로 여전히 조정이 필요하다.</p>
<p>데이터가 복제되는 경우, 복제 지연으로 인해 기본 데이터베이스와 복제본 간에 데이터가 일치하지 않을 수 있다. 일반적으로 이 문제를 해결하기 위한 두 가지 옵션이 있다.</p>
<ol>
<li>기본 데이터베이스에서만 읽기와 쓰기를 모두 수행한다. 이 접근 방식은 설정하기 쉽지만 확장성이 떨어진다는 단점이 있다. 복제본은 데이터 안정성을 보장하는데 사용되지만 트래픽을 처리하지 않으므로 리소스가 낭비된다.</li>
<li>모든 복제본이 항상 동기화되도록 해야한다. Paxos, Raft는 이런 작업에 적합하다.</li>
</ol>
<h3 id="Payment-security"><a href="#Payment-security" class="headerlink" title="Payment security"></a>Payment security</h3><p>결제 보안은 매우 중요하다. 다음은 보안에 대응하기 위한 몇가지 기술의 간략한 버전이다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Problem</strong></th>
<th style="text-align:left"><strong>Solution</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Request/response eavesdropping</td>
<td style="text-align:left">Use HTTPS</td>
</tr>
<tr>
<td style="text-align:left">Data tampering</td>
<td style="text-align:left">Enforce encryption and integrity monitoring</td>
</tr>
<tr>
<td style="text-align:left">Man-in-the-middle attack</td>
<td style="text-align:left">Use SSL with certificate pinning</td>
</tr>
<tr>
<td style="text-align:left">Data loss</td>
<td style="text-align:left">Database replication across multiple regions and take snapshots of data</td>
</tr>
<tr>
<td style="text-align:left">Distributed denial-of-service attack (DDoS)</td>
<td style="text-align:left">Rate limiting and firewall</td>
</tr>
<tr>
<td style="text-align:left">Card theft</td>
<td style="text-align:left">Tokenization. Instead of using real card numbers, tokens are stored and used for payment</td>
</tr>
<tr>
<td style="text-align:left">PCI compliance</td>
<td style="text-align:left">PCI DSS is an information security standard for organizations that handle branded credit cards</td>
</tr>
<tr>
<td style="text-align:left">Fraud</td>
<td style="text-align:left">Address verification, card verification value (CVV), user behavior analysis, etc.</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Step-4-Wrap-Up"><a href="#Step-4-Wrap-Up" class="headerlink" title="Step 4 - Wrap Up"></a>Step 4 - Wrap Up</h2><p>이 장에서는 입금 흐름과 출금 흐름을 조사했다. 재시도, 무효화, 일관성에 대해서도 자세히 살펴봤다. 결제 오류 처리와 보안에 대해서도 장의 마지막에 다뤘다.</p>
<p>결제 시스템은 매우 복잡하다. 많은 주제를 다루었지만 아직 언급할 가치가 있는 주제가 더 있다. 다음은 관련 주제의 전체 목록은 아니지만 대표적인 것들이다.</p>
<ul>
<li>모니터링. 주요 지표를 모니터링하는 것은 최신 애플리케이션에서 매우 중요한 부분이다. 광범위한 모니터링을 통해 “”특정 결제 수단의 평균 승인률은 얼마인가?”, “서버의 리소스 사용량은 얼마인가?” 와 같은 질문에 답을 할 수 있다.</li>
<li>알림. 비정상적인 상황이 발생하면 신속하게 알림을 보내는 것이 중요하다.</li>
<li>디버깅 툴. “결제 실패 이유가 무엇인가요?”는 자주 받는 질문 중 하나다. 이런 문의를 잘 대처하기 위해 상태, 기록 등을 검토할 수 있는 툴을 개발하는 것이 중요하다.</li>
<li>환전. 해외 사용자층을 위한 결제 시스템을 설계할 때 환전은 중요한 고려 사항이다.</li>
<li>지역. 지역마다 완전히 다른 결제 방법을 사용할 수 있다.</li>
<li>현금 결제. 인도, 브라질 및 외부 국가에서는 현금 결제가 매우 일반적이다.</li>
</ul>
<h2 id="Chapter-Summary"><a href="#Chapter-Summary" class="headerlink" title="Chapter Summary"></a>Chapter Summary</h2><p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240116233338318.png" alt=""></p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2024/01/15/System%20Design/ByteByteGo/book/payment-system/">https://songhayoung.github.io/2024/01/15/System%20Design/ByteByteGo/book/payment-system/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2025 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>