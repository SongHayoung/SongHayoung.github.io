<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[Effective Java] clone 재정의는 주의해서 진행하라"><meta name="keywords" content="JAVA"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[Effective Java] clone 재정의는 주의해서 진행하라 | SUMFIのBlog</title><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0"><span class="toc-number">1.</span> <span class="toc-text">들어가며</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cloneable"><span class="toc-number">2.</span> <span class="toc-text">Cloneable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clone-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%9D%BC%EB%B0%98-%EA%B7%9C%EC%95%BD"><span class="toc-number">3.</span> <span class="toc-text">clone 메소드 일반 규약</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B0%80%EB%B3%80%EC%83%81%ED%83%9C%EB%A5%BC-%EC%B0%B8%EC%A1%B0%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9A%A9-clone-%EB%A9%94%EC%86%8C%EB%93%9C"><span class="toc-number">4.</span> <span class="toc-text">가변상태를 참조하지 않는 클래스용 clone 메소드</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B0%80%EB%B3%80%EC%83%81%ED%83%9C%EB%A5%BC-%EC%B0%B8%EC%A1%B0%ED%95%98%EB%8A%94-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9A%A9-clone-%EB%A9%94%EC%86%8C%EB%93%9C"><span class="toc-number">5.</span> <span class="toc-text">가변상태를 참조하는 클래스용 clone 메소드</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B0%9D%EC%B2%B4-%EB%B3%B5%EC%82%AC%EC%9D%98-%EB%8B%A4%EB%A5%B8-%EB%B0%A9%EB%B2%95"><span class="toc-number">6.</span> <span class="toc-text">객체 복사의 다른 방법</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.instagram.com/hayoung0_0/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">6697</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">183</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">62</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[Effective Java] clone 재정의는 주의해서 진행하라</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-06</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/Effective-Java/">Effective Java</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">630</span><span class="post-meta__separator">|</span><span>Reading time: 3 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h2><span id="more"></span>
<p>Cloneable은 복제해도 되는 클래스임을 명시하는 용도인 믹스인 인터페이스지만 아쉽게도 의도한 목적을 제대로 이루지 못했다. 가장 큰 문제는 clone 메소드가 선언된 곳이 Cloneable이 아닌 Object이고 그마저도 protected라는데 있다.</p>
<h2 id="Cloneable"><a href="#Cloneable" class="headerlink" title="Cloneable"></a>Cloneable</h2><p>메소드 하나 없는 Clonealbe 인터페이스는 놀랍게도 Object의 protected 메소드인 clone의 동작 방식을 결정한다. Cloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면 그 객체의 필드들을 하나하나 복사한 객체를 반환하며 그렇지 않은 클래스의 인스턴스에서 호출하면 CloneNotSupportedException을 던진다. 게다가 Cloneable을 구현한 thread safe 클래스를 작성할 때는 clone 메소드 역시 적절한 동기화가 필요하다. Object의 clone 메소드는 동기화를 신경쓰지 않았기 때문이다.</p>
<h2 id="clone-메소드-일반-규약"><a href="#clone-메소드-일반-규약" class="headerlink" title="clone 메소드 일반 규약"></a>clone 메소드 일반 규약</h2><ol>
<li>x.clone() != x</li>
<li>x.clone().getClass() == x.getClass()</li>
<li>x.clone().equals(x)</li>
</ol>
<p>강제성이 없다는 점만 빼면 생성자 연쇄와 살짝 비슷한 메커니즘이다. 즉 clone 메소드가 super.clone이 아닌 생성자를 호출해 얻은 인스턴스를 반환해도 컴파일러는 오류를 내지 않을 것이다. 하지만 이 클래스의 하위 클래스에서 super.clone을 호출한다면 잘못된 클래스의 객체가 만들어져 결국 하위 클래스의 clone 메소드가 제대로 동작하지 않게 된다.</p>
<p>clone을 재정의한 클래스가 final이라면 걱정해야할 하위 클래스가 없으니 이 관례는 무시해도 안전하지만 final 클래스의 clone 메소드가 super.clone을 호출하지 않는다면 Cloneable을 구현할 이유도 없다.</p>
<h2 id="가변상태를-참조하지-않는-클래스용-clone-메소드"><a href="#가변상태를-참조하지-않는-클래스용-clone-메소드" class="headerlink" title="가변상태를 참조하지 않는 클래스용 clone 메소드"></a>가변상태를 참조하지 않는 클래스용 clone 메소드</h2><p>가변상태를 참조하지 않은 즉 모든 필드가 기본 타입이거나 불변 객체를 참조한다면 다음과 같이 clone 메소드를 구성할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PhoneNumber <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (PhoneNumber) <span class="built_in">super</span>.clone();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ConleNotSupportedException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();	<span class="comment">// 일어날 수 없다.</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="가변상태를-참조하는-클래스용-clone-메소드"><a href="#가변상태를-참조하는-클래스용-clone-메소드" class="headerlink" title="가변상태를 참조하는 클래스용 clone 메소드"></a>가변상태를 참조하는 클래스용 clone 메소드</h2><p>가변 상태를 참조하는 클래스는 깊은 복사를 진행해주어야 한다. 그냥 단순히 super.clone을 호출한다면 원본의 참조 필드와 동일한 필드를 참조하게 될 것이다. 이를 해결하는 방법은 참조 필드의 clone을 재귀적으로 호출해 주는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Stack <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">Stack</span> <span class="variable">result</span> <span class="operator">=</span> (Stack) <span class="built_in">super</span>.clone();</span><br><span class="line">		result.elements = elements.clone();</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>다만 elements 필드가 final이었다면 위의 방식은 동작하지 않는다. final 필드에는 새로운 값을 할당할 수 없기 때문이다. 이는 근본적인 문제로, 직렬화와 마찬가지로 Cloneable 아키텍처는 가변 객체를 참조하는 필드는 final로 선언하라는 일반 용법과 충돌한다. (단 원본과 복제된 객체가 그 가변 객체를 공유해도 안전하다면 괜찮다.) 그래서 복제할 수 있는 클래스를 만들기 위해 일부 필드에서 final 한정자를 제거해야 할 수도 있다.</p>
<p>단순해 재귀적으로 호출하는것이 충분하지 않을 때도 있다. 해시 테이블용 clone 메소드를 보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> HashTable <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">HashTable</span> <span class="variable">result</span> <span class="operator">=</span> (HashTable) <span class="built_in">super</span>.clone();</span><br><span class="line">		result.buckets = buckets.clone();</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드는 복제본은 자신만의 버킷 배열을 가지지만 이 배열은 원본과 같은 연결리스트를 참조하는 문제가 있다. 그럼 다음은 어떨까?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Entry <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value, next == <span class="literal">null</span> ? <span class="literal">null</span> : next.deepCopy());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> HashTable <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">HashTable</span> <span class="variable">result</span> <span class="operator">=</span> (HashTable) <span class="built_in">super</span>.clone();</span><br><span class="line">		result.buckets = <span class="keyword">new</span> <span class="title class_">Entry</span>[buckets.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.length; i++)</span><br><span class="line">			<span class="keyword">if</span> (buckets[i] != <span class="literal">null</span>)</span><br><span class="line">				result.buckets[i] = buckets[i].deepCopy();</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>deepCopy를 지원하도록 보강하였다. 언듯 보기에는 문제가 없어보인다. 하지만 재귀적으로 작성한 코드는 리스트의 원소 수만큼 스택 프레임을 소비하여 경우에 따라 스택 오버플로를 일으킬 수 있다. 이는 반복자를 활용하여 해결할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Entry <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">Entry</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value, next);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">p</span> <span class="operator">=</span> result; p.next != <span class="literal">null</span>; p = p.next)</span><br><span class="line">		p.next = <span class="keyword">new</span> <span class="title class_">Entry</span>(p.next.key, p.next.value, p.next.next);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="객체-복사의-다른-방법"><a href="#객체-복사의-다른-방법" class="headerlink" title="객체 복사의 다른 방법"></a>객체 복사의 다른 방법</h2><p>객체 복사의 다른 방법중 하나는 복사 생성자와 복사 팩터리다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Yum</span><span class="params">(Yum yum)</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Yun <span class="title function_">newInstance</span><span class="params">(Yun yun)</span> &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p>위 방법은 언어 모순적이고 위험 천만한 객체 생성 메커니즘(생성자를 쓰지 않는 방식)을 사용하지 않으며 엉성하게 문서화된 규약에 기대지 않고 정상적인 final 필드 용법과도 충돌하지 않으며 불필요한 검사 예외를 던지지도 않고 형변환도 필요하지 않다. 그리고 해당 클래스가 구현한 인터페이스 타입의 인스턴스를 인수로 받을 수 있다. 이를 통하면 클라이언트는 원본의 구현 타입에 얽매이지 않고 복제본의 타입을 직접 선택할 수 있다.</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2020/08/06/Effective%20JAVA/item13/">https://songhayoung.github.io/2020/08/06/Effective%20JAVA/item13/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/08/07/Clean%20Code/clean-code10/"><i class="fa fa-chevron-left">  </i><span>[Clean Code] 클래스</span></a></div><div class="next-post pull-right"><a href="/2020/08/06/Effective%20JAVA/item12/"><span>[Effective Java] toString을 항상 재정의하라</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2023 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>