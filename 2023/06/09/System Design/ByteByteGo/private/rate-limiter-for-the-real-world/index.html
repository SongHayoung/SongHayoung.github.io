<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[ByteByteGo] Rate Limiter For The Real World"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[ByteByteGo] Rate Limiter For The Real World | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Rate-Limiter-For-The-Real-World"><span class="toc-number">1.</span> <span class="toc-text">Rate Limiter For The Real World</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Gathering-Requirements-and-Key-Considerations"><span class="toc-number">2.</span> <span class="toc-text">Gathering Requirements and Key Considerations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rate-Limiter-Architecture"><span class="toc-number">3.</span> <span class="toc-text">Rate Limiter Architecture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CDN-and-Reverse-Proxy"><span class="toc-number">3.1.</span> <span class="toc-text">CDN and Reverse Proxy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-Gateway"><span class="toc-number">3.2.</span> <span class="toc-text">API Gateway</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Application-Framework-and-Middleware"><span class="toc-number">3.3.</span> <span class="toc-text">Application Framework and Middleware</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Application"><span class="toc-number">3.4.</span> <span class="toc-text">Application</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rate-Limiting-States"><span class="toc-number">4.</span> <span class="toc-text">Rate Limiting States</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Centralized-State-Storage"><span class="toc-number">4.1.</span> <span class="toc-text">Centralized State Storage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Handling-Race-Conditions"><span class="toc-number">4.1.1.</span> <span class="toc-text">Handling Race Conditions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Performance-Optimization"><span class="toc-number">4.1.2.</span> <span class="toc-text">Performance Optimization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Utilizing-Redis-for-Rate-Limiting"><span class="toc-number">4.1.3.</span> <span class="toc-text">Utilizing Redis for Rate Limiting</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handling-Failures"><span class="toc-number">5.</span> <span class="toc-text">Handling Failures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Case-Study"><span class="toc-number">6.</span> <span class="toc-text">Case Study</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Problem"><span class="toc-number">6.1.</span> <span class="toc-text">Problem</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solution"><span class="toc-number">6.2.</span> <span class="toc-text">Solution</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementation"><span class="toc-number">6.3.</span> <span class="toc-text">Implementation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Best-Practices"><span class="toc-number">7.</span> <span class="toc-text">Best Practices</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Safety"><span class="toc-number">7.1.</span> <span class="toc-text">Safety</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Operational-Emergency"><span class="toc-number">7.2.</span> <span class="toc-text">Operational Emergency</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monitoring-and-Alerting"><span class="toc-number">7.3.</span> <span class="toc-text">Monitoring and Alerting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Clear-Error-Responses"><span class="toc-number">7.4.</span> <span class="toc-text">Clear Error Responses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trial-Period"><span class="toc-number">7.5.</span> <span class="toc-text">Trial Period</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">8.</span> <span class="toc-text">Conclusion</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/hayoung-song-9523b61bb/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">11266</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">197</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">62</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[ByteByteGo] Rate Limiter For The Real World</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-09</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/Byte-Byte-Go/">Byte Byte Go</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2.5k</span><span class="post-meta__separator">|</span><span>Reading time: 15 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Rate-Limiter-For-The-Real-World"><a href="#Rate-Limiter-For-The-Real-World" class="headerlink" title="Rate Limiter For The Real World"></a>Rate Limiter For The Real World</h2><span id="more"></span>
<p>이번 포스트에서는 실제 rate limiter를 구축하는 방법을 살펴본다. 실제 환경에 맞는 rate limiter를 개발할 때 고려해야할 요소는 많다. 대부분의 사례에서 rate limiter는 애플리케이션의 가장 중요한 경로에 위치한다. 이 상황에서는 모든 장애 시나리오를 고려하고 중요한 경로에 rate limiter를 배치하는 것이 성능에 미치는 영향을 고려하는 것이 중요하다.</p>
<h2 id="Gathering-Requirements-and-Key-Considerations"><a href="#Gathering-Requirements-and-Key-Considerations" class="headerlink" title="Gathering Requirements and Key Considerations"></a>Gathering Requirements and Key Considerations</h2><p>Rate limiter 구축에 들어가기 전에 목표를 이해하는 것이 중요하다. 이는 요구사항을 수집하고 주요 설계 요소를 고려하는 것에서 시작된다. 요구사항은 서비스의 성격과 지원하고자 하는 사용 사례에 따라 달라질 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230609221054021.png" alt=""></p>
<p>먼저 서비스의 특성을 고려해야 한다. 지연 시간에 민감한 애플리케이션인지, 실시간 성능보다 정확성과 안정성이 더 중요한 비동기 작업인지? 이는 rate limiting 제한을 위반했을 때 처리하는 방법에 대한 결정에 도움이 될 수 있다. 시스템이 추가 요청을 즉시 거부해야 하는지, 아니면 대기열에 대기했다가 리소스가 확보되는 대로 처리해야하는지에 대해서 말이다.</p>
<p>다음으로는 사용자의 행동을 고려해야 한다. 사용자의 평균 요청 속도와 최대 요청 속도는 어느 정도 인가? 고객의 사용 패턴이 예측하능 한가? 아니면 트래픽이 급격히 증가하는가? 이런 분석은 합법적인 사용자를 방해하지 않으면서 시스템을 보호하는 rate limiting 규칙을 만드는 데 유용하다.</p>
<p>그 뒤엔 규모와 성능 요구 사항을 고려한다. 예상되는 요청의 양을 파악하고 시스템의 목표 지연 시간을 설정해야 한다. 시스템이 수백만 명의 고객에서 수십억 건의 요청을 처리해야 하는가, 아니면 그보다 적은 수의 요청을 처리해야 하는가? 지연 시간이 중요한가, 아니면 안정성 향상을 위해 속도를 어느 정도 희생할 수 있는가?</p>
<p>Rate limiting 정책도 신중하게 고려해야 한다. 단위 시간당 요청 수, 요청 크키 또는 기타 기준에 따라 제한하고 있는지? 한도를 클라이언트 별로 설정하는지, 아니면 모든 클라이언트에 공유하는지? 클라이언트 계층별로 한도가 다른지? 정책이 엄격한지 아니면 bursting을 허용하는지?</p>
<p>일부 rate limiting에는 지속성 조건이 필요하다. Rate limiting 제한 기간이 긴 경우 장기 추적을 위해 카운터와 같은 rate limit 상태를 어떻게 유지해야할까? 이 요구사항은 비동기 작업 처리 시스템과 같이 지연 시간보다 long term 정확도가 더 중요한 경우에 특히 중요할 수 있다.</p>
<p>이러한 부분을 더 잘 이해하기 위해 몇 가지 예를 살펴보자.</p>
<p>지연 시간이 매우 중요할 수 있는 입찰 플랫폼과 같은 실시간 서비스의 경우, 전체 요청 시간에 상당한 지연 시간을 추가하지 않는 rate limiter가 필요하다. 정확도와 리소스 소비 사이에서 절충점을 찾아야 한다. 더 정확한 rate limiter는 더 많은 메모리와 CPU를 사용할 수 있지만 더 간단한 rate limiter는 가끔식 요청이 폭주하는 것을 허용할 수 있다.</p>
<p>반면 대량의 데이터 분석 작업을 처리하는 비동기 작업 처리 시스템에서는 rate limiter가 실시간으로 limiting을 적용할 필요는 없지만 각 사용자가 제출한 작업의 총 수가 일일 제한을 초과하지 않도록 해야한다. 이러한 경우 rate limiting 상태를 데이터베이스 등에 영구적으로 저장하는 것이 중요할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230609222025157.png" alt=""></p>
<h2 id="Rate-Limiter-Architecture"><a href="#Rate-Limiter-Architecture" class="headerlink" title="Rate Limiter Architecture"></a>Rate Limiter Architecture</h2><p>주요 아키텍처 질문은 애플리케이션 스택에서 rate limiter를 어디에 배치해야 하는가이다.</p>
<p>이는 애플리케이션 스택의 구성에 따라 크게 달라진다. 애플리케이션 스택에 rate limiter를 통합하는 위치는 매우 중요하다. 이 결정은 이전 섹션에서 수집한 rate limiting 요구 사항에 따라 달라진다. 일반적인 웹 기반 API 제공 애플리케이션의 경우 rate limiter를 잠재적으로 배치할 수 있는 계층이 여럿 있다.</p>
<h3 id="CDN-and-Reverse-Proxy"><a href="#CDN-and-Reverse-Proxy" class="headerlink" title="CDN and Reverse Proxy"></a>CDN and Reverse Proxy</h3><p>가장 바깥에 위치하는 계층은 애플리케이션의 리버스 프록시 역할도 하는 CDN이다. CDN을 사용하여 API 서비스를 앞당기는 것은 프로덕션 환경에서 점점 더 보편적인 설계가 되고 있다. 예를 들어, 잘 알려진 CDN인 Cloudflare는 IP 주소나 기타 일반적인 HTTP 헤더와 같은 표준 웹 요청 헤더를 기반으로 일부 rate limiting 기능을 제공한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230609222322691.png" alt=""></p>
<p>CDN이 이미 애플리케이션 스택의 일부인 경우, 기본적인 어뷰징에 대한 초기 방어에 효과적이다. 보다 정교한 rate limiting 장치를 애플리케이션 백엔드에 더 가깝게 배치하여 나머지 rate limiting 요구사항을 해결할 수 있다. 일부 프로덕션 배포에서는 CDN이 아닌 자체 리버스 프록시를 유지하기도 한다. 이러한 리버스 프록시 중 다수는 rate limiting 플러그인을 제공한다. 예를 들어 Nginx는 IP 주소 또는 HTTP 헤더와 같은 기타 변수를 기반으로 연결, 요청 속도 또는 대역폭 사용량을 제한할 수 있다. <a target="_blank" rel="noopener" href="https://doc.traefik.io/traefik/middlewares/http/ratelimit/">Traefik</a>은 rate limiting을 제공하는 리버스 프록시의 또 다른 예로, 쿠버네티스 에코시스템에서 널리 사용되는 프록시이다.</p>
<p>리버스 프록시가 원하는 rate limiting 알고리즘을 지원하는 경우 기본 rate limiter를 설치하기에 적합한 위치이다. 그러나 대규모 배포에는 일반적으로 대량의 요청을 처리하기 위해 리버스 프록시 노드 클러스터가 필요하다는 점에 유의해야 한다. 이로 인해 rate limiting 상태가 여러 노드에 분산된다. 상태가 동기화되지 않으면 부정확성이 발생할 수 있다.</p>
<h3 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a>API Gateway</h3><p>애플리케이션 스택으로 더 깊이 들어가면 일부 배포에서는 API 게이트웨이를 사용해 들어오는 트래픽을 관리한다. 이 계층은 API 게이트웨이가 지원하는 경우 기본 rate limiter를 호스팅할 수 있다. 이를 통해 개별 경로를 제어할 수 있으며 엔드포인트마다 다른 rate limiting 규칙을 적용할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230609222857958.png" alt=""></p>
<h3 id="Application-Framework-and-Middleware"><a href="#Application-Framework-and-Middleware" class="headerlink" title="Application Framework and Middleware"></a>Application Framework and Middleware</h3><p>Rate limiting이 필요한 리소스를 더 세밀하게 식별해야 하는 경우 rate limiter를 애플리케이션 로직에 더 가깝게 배치해야 할 수 있다. 예를 들어, 구독 유형과 같은 사용자별 속성에 제한이 필요한 경우 이 수준에서 rate limiter를 구현해야 한다. 경우에 따라 애플리케이션 프레임워크가 미들웨어 또는 플러그인을 통해 rate limiting 기능을 제공할 수도 있다. 앞선 사례와 마찬가지로 이런 기능이 요구사항을 충족한다면 이 기능이 rate limiting에 적합한 위치가 될 것이다.</p>
<p>이 방법을 사용하면 애플리케이션 코드 내에 미들웨어로 rate limiter를 통합할 수 있다. 다양한 사용 사례에 맞게 사용자 지정이 가능하고 가시성이 향상되지만 애플리케이션 코드가 복잡해지고 성능에 영향을 미칠 수 있다.</p>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>필요한 경우 애플리케이션 코드에 직접 rate limiting 로직을 통합할 수도 있다. 경우에 따라 rate limiting 요구 사항이 매우 구체적이어서 이 방법만이 가능한 유일한 옵션인 경우도 있다.</p>
<p>이 방법은 가장 높은 수준의 제어와 가시성을 제공하지만, rate limiting과 비즈니스 로직 사이에 복잡성과 잠재적인 긴밀한 결합이 발생할 수 있다. 이전과 마찬가지로 대규모로 운영할 때는 애플리케이션 노드 간에 rate limiting 제한 상태를 공유하는 것과 관련된 모든 문제가 관련된다.</p>
<h2 id="Rate-Limiting-States"><a href="#Rate-Limiting-States" class="headerlink" title="Rate Limiting States"></a>Rate Limiting States</h2><p>다른 중요한 아키텍쳐 걸정은 rate limiting 상태를 어디에 저장할 것인가이다. 규모가 작고 단순한 rate limiter의 경우 상태를 rate limiter의 메모리에만 저장하는 것으로 충분할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230609223544590.png" alt=""></p>
<p>그러나 이는 규칙이 아니라 예외일 가능성이 높다. 대부분의 프로덕션 환경에서는 애플리케이션 스택에서 rate limiter의 위치에 관계없이 부하를 처리하기 위해 여러 개의 rate limiter 인스턴스가 있으며 상태가 노드에 분산되어 있을 가능성이 높다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230609223642124.png" alt=""></p>
<p>이 영역은 매우 챌린징하기 때문에 몇 가지 구체적인 내용을 살펴보자.</p>
<p>Rate limiting 기능이 시스템 전체에 분산되어 있는 경우, 각 인스턴스가 들어오는 모든 요청을 완벽하게 파악하지 못할 수 있다는 문제가 있다. 이로 인해 부정확한 rate limiting이 발생할 수 있다.</p>
<p>예를 들어, 각각 자체 rate limiting 인스턴스를 실행하는 역방향 프록시 클러스터가 있다고 가정해보자. 이런 프록시 중 어느것이라도 수신 요청을 처리할 수 있다. 이로 인해 분산되고 격리된 rate limiting 상태가 발생한다. 사용자의 요청이 여러 프록시에서 처리되는 경우 사용자는 잠재적으로 rate limiting을 초과할 수 있다.</p>
<p>경우에 따라 부정확성이 허용될 수 있다. 요구 사항에 대한 초기 논의를 다시 참조하면, 기본적인 수준의 보호를 제공하는 것이 목표라면 각 인스턴스가 자체 상태를 유지하도록 허용하는 간단한 솔루션이 적절할 수 있다. 그러나 정확한 비율 제한을 유지하는 것이 핵심 요구 사항인 경우에는 보다 정교한 전략을 고려해야 한다.</p>
<h3 id="Centralized-State-Storage"><a href="#Centralized-State-Storage" class="headerlink" title="Centralized State Storage"></a>Centralized State Storage</h3><p>이런 전략 중 하나는 중앙 집중식 상태 저장소이다. 여기서는 각 rate limiter 인스턴스가 자체 상태를 관리하는 대신 모든 인스턴스가 중앙 스토리지 시스템과 상호 작용해 상태를 읽고 업데이트 한다. 하지만 이 방법에는 많은 단점이 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230609224100613.png" alt=""></p>
<p>중앙 집중식 상태 저장 시스템을 구현하면 지연 시간이 길어지고 특히 처리량이 많은 애플리케이션에서 병목 현상이 발생할 수 있다. 또한 이를 고성능으로 올바르게 구현하는 것도 어렵다. 여러 프로세스가 동시에 상태를 업데이트 하려고 시도할 때 경쟁 조건이 발생할 수 있다. 이로 인해 부정확성이 발생할 수 있다. 이런 문제와 해결책을 자세히 살펴보자.</p>
<h4 id="Handling-Race-Conditions"><a href="#Handling-Race-Conditions" class="headerlink" title="Handling Race Conditions"></a>Handling Race Conditions</h4><p>중앙 집중식 데이터 저장소가 있고 동시 전송률 제한 요청량이 많은 시나리오에서는 경합 조건이 심각한 문제가 될 수 있다. 이는 일반적으로 현재 제한 카운터를 먼저 검색해 증가시킨 다음 데이터 스토리지에 다시 쓰는 패턴을 채택할 때 발생한다. 여기서 경합 조건은 읽기 - 증분 - 쓰기 싸이클을 완료하는데 걸리는 시간 동안 더 많은 요청이 들어올 수 있다는 점이다. 이런 요청은 카운터를 다시 쓰려고 시도하지만 오래된 낮은 카운터 값으로 인해 잠재적인 rate limiting 우회로 이어질 수 있다.</p>
<p>다른 인스턴스가 카운터에 액세스하거나 수정하지 못하도록 rate limiting 식별자의 키를 잠그는 방법을 고려할 수 있다. 그러나 이 방법은 심각한 성능 병목 현상을 초래할 수 있으며 확장성이 떨어진다.</p>
<p>보다 효과적인 전략은 원자 연산을 사용하는 접근 방식을 채택하는 것이다. 이런 연산을 사용하면 원자성을 손상시키지 않으면서 카운터 값을 빠르게 늘리고 확인할 수 있다. 또한 경쟁 조건의 위험 없이 효율적인 카운터 관리가 가능하다.</p>
<h4 id="Performance-Optimization"><a href="#Performance-Optimization" class="headerlink" title="Performance Optimization"></a>Performance Optimization</h4><p>Rate limiting 카운터를 추적하기 위해 중앙 집중식 데이터 저장소를 사용하면 Redis와 같은 빠른 데이터 저장소를 사용하더라도 각 요청에 항상 지연 시간이 추가된다. 이때 글로벌 상태의 인메모리 복사본이 도움이 될 수 있다. 로컬 인메모리에 캐시된 상태는 지연 시간을 크게 줄일 수 있다. </p>
<p>이를 가능하게 하기 위해 rate limiting 정확도를 약간 완화하고 궁극적으로 일관된 모델을 사용할 수 있다. 이 모델에서는 각 노드가 중앙 데이터 저장소와 주기적으로 데이터 동기화 푸시를 진행한다. 푸시할 때마다 모든 노드는 각 식별자 및 time window에 대한 카운터를 데이터 저장소에 원자 단위로 업데이트 한다. 그런 다음 노드는 업데이트된 값을 가져와 인메모리 버전을 새로 고칠 수 있다.</p>
<p>이러한 푸시 속도는 조정할 수 있어야 한다. 동기화 간격이 짧으면 클러스터의 여러 노드에 트래픽을 분사할 때 데이터 분산이 줄어든다. 반면에 동기화 간격이 길면 데이터 저장소에 대한 읽기 / 쓰기 압력이 줄어들고 새로 동기화된 값을 가져오기 위한 각 노드의 오버헤드가 최소화 된다.</p>
<p>Nginx는 이 메커니즘을 사용해 노드 간에 rate limiting 상태를 동기화 한다.</p>
<h4 id="Utilizing-Redis-for-Rate-Limiting"><a href="#Utilizing-Redis-for-Rate-Limiting" class="headerlink" title="Utilizing Redis for Rate Limiting"></a>Utilizing Redis for Rate Limiting</h4><p>Redis는 고성능 인메모리 데이터 구조 저장소이며 rate limiter를 구현하는데 널리 사용되는 도구다. 다양한 역방향 프록시 및 API 게이트웨이용 rate limiting 플러그인 중 상당수가 Redis를 백업 저장소로 사용할 수 있도록 지원한다.</p>
<p>Redis는 사용하기 쉽고 확장성이 뛰어나기 때문에 매력적인 옵션이다. Redis는 sliding window log, fixed window count, token bucket 등 다양한 유형의 rate limiting 알고리즘을 구현하는데 도움이 되는 다양한 데이터 구조와 명령을 지원한다. 다른 방법으로는 구현하기 어려울 수 있는 정교한 rate limiting 알고리즘을 구성하기 위한 수단으로 Lua 스크립팅을 지원한다.</p>
<p>Redis에는 다양한 rate limiting 알고리즘을 구현하는 예제가 있다. 또한 확장성이 뛰어나다. 단일 Redis 인스턴스는 대부분의 중간 규모 애플리케이션의 워크로드를 관리할 수 있다. 단일 노드 이상으로 확장하기 위해 여러 노드에 rate limiting 식별자를 분산하는 샤딩과 같은 알려진 기술이 있다.</p>
<p>그러나 다른 도구와 마찬가지로, Redis도 모든 것에 적합한 솔루션은 아니다. Redis는 주로 인메모리 데이터 저장소이다. 기본적인 지속성 기능을 제공하지만 기존 데이터베이스와 동일한 내구성을 보장하지는 않는다. 또한 Redis 클러스터를 관리하는 데 드는 비용과 복잡성도 고려해야 한다. 그러나 배포에서 이미 다른 기능에 Redis를 사용하고 있다면 rate limiting에 활용하는 것이 논리적인 선택이 될 수 있다.</p>
<h2 id="Handling-Failures"><a href="#Handling-Failures" class="headerlink" title="Handling Failures"></a>Handling Failures</h2><p>가장 강력한 rate limiter를 사용하더라도 장애를 완전히 피할 수는 없다. 따라서 장애가 시스템과 최종 사용자 경험에 미치는 영향을 최소화하기 위해 장애를 적절히 관리하기 위한 전략을 통합해야 한다.</p>
<p>Rate limiter 장애를 처리하기 위한 두 가지 일반적인 전략인 “Fail open”과 “Fail close”를 고려해보자.  Fail open 전략은 rate limiting 서비스에 예기치 않은 오류가 발생하거나 서비스를 사용할 수 없는 경우에 동작한다. 이런 시나리오에서는 rate limiter가 “개방”되어 들어오는 모든 요청이 통과할 수 있다. 이 전략은 합법적인 요청을 거부하지 않도록 보장하지만, 잠재적으로 트래픽이 폭주해 다운스트림 시스템을 압도할 수 있는 위험이 있다. 이 절충안은 가용성을 극대화하는 한편, 애초에 rate limiter를 도입한 이유인 시스템 과부하 방지를 위태롭게 할 수 있다는 것을 의미한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230609225711093.png" alt=""></p>
<p>반면에 Fail close 전략은 다르게 동작한다. 장애가 발생하면 rate limiter가 “폐쇄”되어 들어오는 모든 요청을 거부한다. 이 전략은 합법적인 요청을 거부하는 위험을 감수하더라도 잠재적인 과부하로부터 시스템을 보호함으로써 rate limiter의 기본 취지를 유지한다. 단 강력한 보호를 위해 가용성을 희생할 수 있다는 단점이 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230609225826550.png" alt=""></p>
<p>Fail open과 Fail close중 어느 전략을 선택할지는 서비스의 특정 특성과 요구 사항에 따라 달라진다. 가용성이 가장 중요한 시스템의 경우 Fail open이 선호되는 전략일 수 있다. Rate limiting을 엄격하게 준수하고 다운스트림 리소스를 보호하는 것이 더 중요한 시스템에는  Fail close가 더 적합할 수 있다.</p>
<p>하지만 이 전략만이 고려할 수 있는 유일한 옵션은 아니다. 다른 대안으로는 두 전략의 측면을 결합한 하이브리드 전략이 있다. 예를 들어 신뢰할 수 있는 사용자에 대해서는 Fail open을, 그렇지 않은 사용자에 대해서는 Fail close를 할수도 있고, 임계값을 낮춰 트래픽을 허용하되 비율을 낮출 수 있도록 적용할 수도 있다.</p>
<h2 id="Case-Study"><a href="#Case-Study" class="headerlink" title="Case Study"></a>Case Study</h2><p>이 토픽에서는 Stripe가 rate limiter를 구현하고 사용하는 방법을 살펴본다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230609233107664.png" alt=""></p>
<p>Stripe의 사용자 수가 기하급수적으로 증가함에 따라 많은 성공적인 API가 공통적으로 직면한 문제인 서비스 중단으로 이어질 수 있는 갑작스러운 트래픽 급증에도 불구하고 서비스 안정성과 가용성을 유지하는 방법에 대해 고민했다. 다양한 유형의 rate limiter를 구현해 이 문제를 해결했다.</p>
<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>Stripe가 우려했던 시나리오는 아래와 같다.</p>
<ul>
<li>한 명의 사용자로 인해 트래픽이 급증하는 경우</li>
<li>잘못된 스크립트로 인해 의도치 않게 서버에 과부하가 걸리는 사용자</li>
<li>우선순위가 낮은 요청을 너무 많이 전송해 우선순위가 높은 트래픽의 품질을 저하시킬 수 있는 사용자</li>
<li>모든 일반 트래픽을 처리하는데 영향을 미치는 내부 시스템 문제</li>
</ul>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Stripe는 이 문제를 해결하기 위해 4가지의 rate limiter를 구현했다.</p>
<p>첫 번째는 Request rate limiter다. 이 제한기는 각 사용자의 초당 요청 수를 일정 수로 제한한다. 이 제한기는 Stripe에서 가장 범용적인 제한기이며 남용을 방지하는데 가장 중요한 제한기이다. 플래시 세일과 같은 대규모 이벤트에 대응하기 위해 제한을 잠시 초과할 수 있는 기능을 구현했다.</p>
<p>두 번째는 Concurrent Request Limiter다. 이 제한기는 동시에 진행중인 API 요청 수를 제한한다. 리소스 집약적인 엔드포인트를 제어하는데 특히 유용했다.</p>
<p>마지막 두가지는 load shedder다. Fleet Usage Load Shedder는 중요한 API 요청에 대해 특정 비율의 fleet을 항상 사용할 수 있도록 보장한다. 중요한 요청을 위해 인프라의 일부를 예약하고, 허용된 할당량을 초과하는 중요하지 않은 요청은 거부된다.</p>
<p>Worker Utilization Load Shedder는 요청을 처리하는 워커 집합이 과부하 상태로 빠지지 않도록 보호한다. 테스트 모드 트래픽부터 시작해 덜 중요한 요청을 서서히 차단하기 시작해 워커가 중요한 요청에 계속 사용할 수 있도록 한다.</p>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>Stripe는 rate limiting을 위해 token bucket 알고리즘을 사용한다. 이 알고리즘은 각 요청에 대해 토큰을 가져오는 중앙 집중식 버킷 호스트를 사용하며, 새 토큰이 점차적으로 버킷에 떨어진다. 버킷이 비어 있으면 요청이 거부된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230609233852909.png" alt=""></p>
<p>자체 호스팅 또는 Amazon의 ElastiCache와 같은 관리형 서비스를 통해 Redis를 사용한 rate limiter를 구현했다. Rate limiter를 구현하는 것은 Stripe가 증가하는 사용자 수를 관리하고 API의 안정성을 유지하는데 효과적인 솔루션임을 입증했다. Request Rate limiter로 시작해 시간이 지남에 따라 운영 규모를 확장하면서 점차 다른 rate limiter를 도입했다. 이들의 경험은 서비스 안정성을 유지하고 남용을 방지하기 위한 적절한 rate limiting 전략과 관행의 중요성을 보여준다.</p>
<h2 id="Best-Practices"><a href="#Best-Practices" class="headerlink" title="Best Practices"></a>Best Practices</h2><p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230609234058159.png" alt=""></p>
<h3 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h3><p>Rate limiter는 일반적으로 애플리케이션의 가장 중요한 경로에 위치한다. Rate limiter 코드에 버그가 있어도 요청이 계속 처리될 수 있는지 확인해야 한다. 즉 모든 수준에서 오류를 주의 깊게 포착하여 버그나 운영상의 오류가 발생하지 않도록 해야한다. 여기에는 rate limiter가 redis와 같은 데이터 저장소에 의존하는 경우 데이터 저장소의 모든 오류를 처리하는 것도 포함된다.</p>
<p>한 가지 중요한 점은 fail open을 기본값으로 설정하는걸 권장하지만 이 또한 애플리케이션 악용에 노출될 수 있다. 일부 서비스의 경우 유료 사용자에게는 fail open을 적용하고 무료 사용자에게는 fail close를 적용하는 것이 합리적일 수 있다.</p>
<h3 id="Operational-Emergency"><a href="#Operational-Emergency" class="headerlink" title="Operational Emergency"></a>Operational Emergency</h3><p>이처럼 중요한 경로에 rate limiter가 있을 때 필요한 경우에 이를 비활성화 하기 위해 Kill switch를 추가하는 것을 고려해야 한다. 기능 플래그는 이런 kill switch를 구현하기 위한 훌륭한 매커니즘이다.</p>
<h3 id="Monitoring-and-Alerting"><a href="#Monitoring-and-Alerting" class="headerlink" title="Monitoring and Alerting"></a>Monitoring and Alerting</h3><p>Rate limiter가 트리거되는 시기와 조정이 필요한지 여부를 파악하는 데 도움이 되는 정기적인 모니터링, 경고 및 메트릭을 확보하는 것이 중요하다.</p>
<h3 id="Clear-Error-Responses"><a href="#Clear-Error-Responses" class="headerlink" title="Clear Error Responses"></a>Clear Error Responses</h3><p>Rate limit에 도달하면 사용자에게 명확하게 알려야 한다. 이렇게 하면 발진자가 무턱대고 재시도하여 서비스에 과도한 부담을 주지 않고 rate limiting 오류를 올바르게 처리할 수 있다.</p>
<p>Rate limiting 오류를 표시하는 업계 표준은 아직 없다. API의 경우 HTTP 429(Too Many Requests) 또는 HTTP 503(Service Unavailable)을 반환하는 것이 일반적이다. 또한 응답 헤더에 추가 정보가 포함되어 호출자에게 rate limiting 상한, 남은 rate limiting 수, rate limiting 재설정 시간 등 세 가지 정보를 알려준다. 또한 표준 재시도 후 헤더를 포함하여 발신자에게 재시도 시기를 알려야 한다.</p>
<h3 id="Trial-Period"><a href="#Trial-Period" class="headerlink" title="Trial Period"></a>Trial Period</h3><p>Rate limiter를 완전히 적용하기 전에 다크 런칭을 통해 잠재적인 영향을 관찰하는 것이 유용할 수 있다. 실제로 요청을 거부하지 않고 rate limiter를 관찰함으로써 올바른 트래픽이 신고되고 있는지 여부를 측정하고 임계값을 미세 조정할 수 있다.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Rate limiter는 확장성을 위해 서비스를 준비할 때 기본적으로 사용하는 툴킷의 도구이다. 처음부터 다양한 rate limiter 전략을 모두 구현할 필요는 없지만, 필요에 따라 점진적으로 도입할 수 있다.</p>
<p>올바르게 구현하면 긍정적인 사용자 경험을 유지하면서 남용을 방지하고 공정한 사용을 보장할 수 있는 효율적인 메커니즘을 제공한다. 균형을 잡는 것은 어려운 일이지만, 신중한 계획과 세심한 주의를 기울인다면 충분히 달성할 수 있다.</p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2023/06/09/System%20Design/ByteByteGo/private/rate-limiter-for-the-real-world/">https://songhayoung.github.io/2023/06/09/System%20Design/ByteByteGo/private/rate-limiter-for-the-real-world/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2025 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>