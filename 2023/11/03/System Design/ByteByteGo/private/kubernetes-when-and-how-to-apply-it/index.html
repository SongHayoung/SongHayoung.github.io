<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[ByteByteGo] Kubernetes: When and How to Apply It"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[ByteByteGo] Kubernetes: When and How to Apply It | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes-When-and-How-to-Apply-It"><span class="toc-number">1.</span> <span class="toc-text">Kubernetes: When and How to Apply It</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes%E2%80%99-Declarative-Architecture"><span class="toc-number">2.</span> <span class="toc-text">Kubernetes’ Declarative Architecture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Declarative-Model"><span class="toc-number">2.1.</span> <span class="toc-text">The Declarative Model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Custom-Resource-Definition"><span class="toc-number">2.2.</span> <span class="toc-text">Custom Resource Definition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Advanced-Built-in-Resources"><span class="toc-number">2.3.</span> <span class="toc-text">Advanced Built-in Resources</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Third-party-Add-ons"><span class="toc-number">2.4.</span> <span class="toc-text">Third-party Add-ons</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Benefits-and-Drawbacks-of-Kubernetes"><span class="toc-number">3.</span> <span class="toc-text">Benefits and Drawbacks of Kubernetes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Main-Benefits"><span class="toc-number">3.1.</span> <span class="toc-text">The Main Benefits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.2.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Infrastructure-Efficiency"><span class="toc-number">3.2.1.</span> <span class="toc-text">Infrastructure Efficiency</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Enhanced-Developer-Productivity"><span class="toc-number">3.2.2.</span> <span class="toc-text">Enhanced Developer Productivity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Easy-Scalability"><span class="toc-number">3.2.3.</span> <span class="toc-text">Easy Scalability</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Application-Portability"><span class="toc-number">3.2.4.</span> <span class="toc-text">Application Portability</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Consistent-Environments"><span class="toc-number">3.2.5.</span> <span class="toc-text">Consistent Environments</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Resilience"><span class="toc-number">3.2.6.</span> <span class="toc-text">Resilience</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Large-Ecosystem"><span class="toc-number">3.2.7.</span> <span class="toc-text">Large Ecosystem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vendor-Neutral"><span class="toc-number">3.2.8.</span> <span class="toc-text">Vendor Neutral</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Main-Drawbacks"><span class="toc-number">3.3.</span> <span class="toc-text">The Main Drawbacks</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Complexity"><span class="toc-number">3.3.1.</span> <span class="toc-text">Complexity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Resource-Overheads"><span class="toc-number">3.3.2.</span> <span class="toc-text">Resource Overheads</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Security-Concerns"><span class="toc-number">3.3.3.</span> <span class="toc-text">Security Concerns</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Resource-Underutilization"><span class="toc-number">3.3.4.</span> <span class="toc-text">Resource Underutilization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Upgrade-Headaches"><span class="toc-number">3.3.5.</span> <span class="toc-text">Upgrade Headaches</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Limited-Support-for-Stateful-Apps"><span class="toc-number">3.3.6.</span> <span class="toc-text">Limited Support for Stateful Apps</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Our-Take"><span class="toc-number">3.4.</span> <span class="toc-text">Our Take</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Use-Cases-for-Kubernetes"><span class="toc-number">4.</span> <span class="toc-text">Use Cases for Kubernetes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Microservices"><span class="toc-number">4.1.</span> <span class="toc-text">Microservices</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Machine-Learning"><span class="toc-number">4.2.</span> <span class="toc-text">Machine Learning</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Global-Scale"><span class="toc-number">4.3.</span> <span class="toc-text">Global Scale</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hybrid-and-Multi-Cloud"><span class="toc-number">4.4.</span> <span class="toc-text">Hybrid and Multi-Cloud</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Beyond-the-Code"><span class="toc-number">4.5.</span> <span class="toc-text">Beyond the Code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#When-Kubernetes-May-Not-Be-the-Best-Fit"><span class="toc-number">4.6.</span> <span class="toc-text">When Kubernetes May Not Be the Best Fit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Small-Scale-Deployments"><span class="toc-number">4.6.1.</span> <span class="toc-text">Small-Scale Deployments</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Simple-Applications"><span class="toc-number">4.6.2.</span> <span class="toc-text">Simple Applications</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rapid-Development-and-Prototyping"><span class="toc-number">4.6.3.</span> <span class="toc-text">Rapid Development and Prototyping</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lack-of-Expertise"><span class="toc-number">4.6.4.</span> <span class="toc-text">Lack of Expertise</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cost-Considerations"><span class="toc-number">4.6.5.</span> <span class="toc-text">Cost Considerations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Legacy-System-Integration"><span class="toc-number">4.6.6.</span> <span class="toc-text">Legacy System Integration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Our-Take-1"><span class="toc-number">4.6.7.</span> <span class="toc-text">Our Take</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">5.</span> <span class="toc-text">Conclusion</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/hayoung-song-9523b61bb/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">11512</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">199</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">62</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[ByteByteGo] Kubernetes: When and How to Apply It</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-11-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/Byte-Byte-Go/">Byte Byte Go</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3.2k</span><span class="post-meta__separator">|</span><span>Reading time: 19 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Kubernetes-When-and-How-to-Apply-It"><a href="#Kubernetes-When-and-How-to-Apply-It" class="headerlink" title="Kubernetes: When and How to Apply It"></a>Kubernetes: When and How to Apply It</h2><span id="more"></span>
<p>이번 포스트에서는 쿠버네티스의 실용적인 측면을 살펴본다. 애플리케이션 요구사항과 팀 스킬에 따라 언제, 어떻게 쿠버네티스를 적용해야 하는지 배우게 된다. 고급 기능, 장단점, 쿠버네티스가 탁월한 사용 사례, 그리고 오버엔지니어링 상황을 살펴본다.</p>
<h2 id="Kubernetes’-Declarative-Architecture"><a href="#Kubernetes’-Declarative-Architecture" class="headerlink" title="Kubernetes’ Declarative Architecture"></a>Kubernetes’ Declarative Architecture</h2><p>쿠버네티스의 주요 강점 중 하나는 선언적 아키텍쳐다. 선언적 API를 사용하면 애플리케이션의 원하는 상태를 지정해 쿠버네티스가 실제 상태와 일치하도록 조정하는 작업을 처리한다.</p>
<h3 id="The-Declarative-Model"><a href="#The-Declarative-Model" class="headerlink" title="The Declarative Model"></a>The Declarative Model</h3><p>예를 들어 애플리케이션을 배포하려면 다음과 같은 세부 사항을 선언하는 배포 리소스를 만든다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231103152100086.png" alt=""></p>
<p>배포 리소스는 원하는 상태를 선언한다.</p>
<ul>
<li>nginx 1.16 이미지</li>
<li>3개의 레플리카</li>
<li><code>app=my-app</code> 라벨로 파드 매칭</li>
</ul>
<p>그 뒤엔 선언된 사양을 기반으로 앱을 실제로 배포하고 확장하는 모든 기본 세부 사항을 쿠버네티스가 처리한다. 이는 배포 및 업데이트를 위해 단계별 명령이 필요한 명령형 접근 방식과는 다르다.</p>
<h3 id="Custom-Resource-Definition"><a href="#Custom-Resource-Definition" class="headerlink" title="Custom Resource Definition"></a>Custom Resource Definition</h3><p>이 아키텍처의 주요 이점은 확장성이다. 쿠버네티스는 새로운 리소스 유형을 감시하고 선언적 API를 통해 이를 원활하게 처리하도록 설계되었다. 쿠버네티스 자체를 수정할 필요가 없다. 개발자는 빌트인처럼 작동하는 새로운 리소스 유형에 대한 사용자 정의 리소스를 생성할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231103154848185.png" alt=""></p>
<p>위 설정은 <code>mycompany.com/v1</code>에 새 앱 리소스를 정의하고 아래와 같이 사용할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231103154947066.png" alt=""></p>
<p>선언적 모델을 통해 강력한 자동화 기능을 사용할 수 있다. 컨트롤러는 리소스 사양을 모니터링하고 필요에 따라 자동으로 조정할 수 있다. 예를 들어 HorizontalPodAutoscaler는 CPU 사용량과 같은 메트릭을 추적하고 이에 따라 배포를 확장 또는 축소한다. 클러스터 오토 스케일러는 파드 리소스 수요에 따라 노드 수를 조절한다.</p>
<p>쿠버네티스는 kubectl 실행과 같은 명령형 명령도구를 지원하지만 확장성이 떨어지고 쿠버네티스의 자동화 기능과 원활하게 통합되지 않는다. 선언적 API를 사용하면 확장성, 이식성 및 셀프 서비스 자동화 측면에서 상당한 이점을 제공한다.</p>
<h3 id="Advanced-Built-in-Resources"><a href="#Advanced-Built-in-Resources" class="headerlink" title="Advanced Built-in Resources"></a>Advanced Built-in Resources</h3><p>쿠버네티스는 선언적 아키텍처를 활용해 애플리케이션을 더 쉽게 관리할 수 있는 많은 기본 제공 리소스를 제공한다. 예를 들어 Ingress resources는 쿠버네티스 서비스에 대한 외부 액세스의 선언적 구성을 허용한다. 이는 사용자 정의 리소스를 도입해 서비스 노출의 구현 세부 사항을 추상화함으로써 확장성을 활용한다. Nginx, ALB, Traefik 등과 같은 다양한 환경에 대해 서로 다른 Ingress controller를 구현할 수 있다. 이런 분리된 관심사는 이식성을 가능하게 한다.</p>
<p>ConfigMaps는 구성 데이터를 파드에 주입하는 네이티브 쿠버네티스 방식을 제공한다. ConfigMaps 환경 변수로 마운트하거나 설정할 수 있는 키-값 데이터를 보유한다. 이를 통해 코드 / 이미지로부터 설정을 분리할 수 있다. 파드는 ConfigMap을 직접 하용한다. 이것은 쿠버네티스의 확장 가능한 API를 통해 기본적으로 설정을 통합한다.</p>
<p>Role-Based Access Control(RBAC)는 Roles, RoleBindings 및 ClusterRoles과 같은 사용자 정의 리소스를 도입한다. 이런 리소스를 결합해 세분화된 권한을 가능하게 하는 액세스 정책을 형석한다. RBAC는 admission control 및 enforcement를 통해 선언적 인가를 쿠버네티스 API에 통합한다.</p>
<h3 id="Third-party-Add-ons"><a href="#Third-party-Add-ons" class="headerlink" title="Third-party Add-ons"></a>Third-party Add-ons</h3><p>활발한 add-ons 에코시스템은 쿠버네티스 API를 사용해 기능을 확장한다. </p>
<p>Helm은 복잡한 애플리케이션 설정을 선언적으로 관리하기 위해 YAML 템플릿을 패키징하는 차트를 도입했다. 차트는 패키지 관리자와 같은 리포지토리에서 호스팅해 쉽게 공유하고 설치할 수 있다. 헬름은 애플리케이션 플랫폼으로써 쿠버네티스를 효과적으로 확장한다.</p>
<p>Prometheus는 동적 대상 검색 및 사용자 지정 메트릭에 기반한 자동 확장을 위해 ServiceMonitors와 같은 사용자 지정 리소스를 통해 통합된다. Prometheus Operator와 controllers는 확장 가능한 API를 활용해 모니터링, 알림, 오토스케일링을 간소화한다.</p>
<p>Istio는 사용자 지정 리소스, 컨트롤러, admission webhooks와 같은 확장성 메커니즘을 사용해 트래픽 제어, 가시성, 보안을 위한 프록시를 추가한다. 이는 코드 변경 없이 고급 기능을 계층화한다.</p>
<p>Argo CD는 사용자 정의 리소스, 컨트롤러, CRD, 웹 훅, 오퍼레이터를 사용해 쿠버네티스에서 GitOps 워크플로우를 활성화한다. 선언적 API를 통해 CD 개념을 모델링하고 자동화를 통해 상태를 조정한다.</p>
<p>쿠버네티스를 사용하면 시스템 구성을 완전히 사용자 정의할 수 있다. 모든 것은 사용자가 정의한 쿠버네티스 리소스와 애드온을 통해 설정된다. 따라서 미리 정의된 옵션의 제약을 받지 않고 특정 요구사항에 맞게 플랫폼을 구성할 수 있다.</p>
<p>쿠버네티스는 사용 사례에 맞게 창의적인 방식으로 결합할 수 있는 공통 빌딩 블록을 제공한다. 프로그래밍이 가능한 개방형 설계 덕분에 원래 개발자도 생각하지 못했던 새로운 애플리케이션을 개발할 수 있다.</p>
<h2 id="Benefits-and-Drawbacks-of-Kubernetes"><a href="#Benefits-and-Drawbacks-of-Kubernetes" class="headerlink" title="Benefits and Drawbacks of Kubernetes"></a>Benefits and Drawbacks of Kubernetes</h2><p>쿠버네티스는 많은 이점으로 인해 큰 인기를 얻고 있지만 다른 기술과 마찬가지로 신중한 평가가 필요한 몇 가지 단점도 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231103160306294.png" alt=""></p>
<h3 id="The-Main-Benefits"><a href="#The-Main-Benefits" class="headerlink" title="The Main Benefits"></a>The Main Benefits</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231103160323502.png" alt=""></h3><h4 id="Infrastructure-Efficiency"><a href="#Infrastructure-Efficiency" class="headerlink" title="Infrastructure Efficiency"></a>Infrastructure Efficiency</h4><p>쿠버네티스의 장점 중 하나는 리소스를 대규모로 관리할 수 있다는 점이다. 노드 간에 컨테이너를 자동으로 스케줄링하고 자동 확장 및 자가 복구와 같은 기능을 통해 쿠버네티스는 리소스를 최적으로 사용할 수 있도록 한다. 필요에 따라 리소스를 시작하거나 종료하면서 수요에 따라 원활하게 조정한다. 따라서 리소스 사용을 개선해 비용을 절감할 수 있을 뿐만 아니라 애플리케이션이 원활하게 실행될 수 있도록 적절한 리소스를 확보할 수 있다.</p>
<h4 id="Enhanced-Developer-Productivity"><a href="#Enhanced-Developer-Productivity" class="headerlink" title="Enhanced Developer Productivity"></a>Enhanced Developer Productivity</h4><p>확장 및 배포와 같은 많은 인프라 작업을 자동으로 처리함으로써 개발자는 이런 작업에 많은 시간을 할애하지 않아도 된다. 따라서 개발자는 인프라 세부 사항에 대해 걱정할 필요 없이 애플리케이션 코드 작성에 시간과 에너지를 집중할 수 있다. 따라서 쿠버네티스를 통해 개발자의 생산성이 향상된다.</p>
<h4 id="Easy-Scalability"><a href="#Easy-Scalability" class="headerlink" title="Easy Scalability"></a>Easy Scalability</h4><p>쿠버네티스의 주요 장점은 실시간 수요에 따라 애플리케이션을 쉽게 확장 및 축소할 수 있다는 점이다. 따라서 트래픽이 급증하는 동안에도 리소스를 효율적으로 사용하면서 우수한 성능을 유지할 수 있다. 자동 확장은 워크로드가 변화하는 애플리케이션에 특히 유용하다.</p>
<h4 id="Application-Portability"><a href="#Application-Portability" class="headerlink" title="Application Portability"></a>Application Portability</h4><p>쿠버네티스는 온프레미스, 퍼블릭 클라우드, 하이브리드 등 어디에서 애플리케이션을 실행하든 일관된 배포 환경을 제공한다. 따라서 환경 간에 애플리케이션을 쉽게 이동할 수 있으며 단일 클라우드 제공자에 대한 의존성을 줄일 수 있다.</p>
<h4 id="Consistent-Environments"><a href="#Consistent-Environments" class="headerlink" title="Consistent Environments"></a>Consistent Environments</h4><p>쿠버네티스는 개발, 테스트 및 프로덕션에서 코드에 대해 동일한 표준화된 환경을 제공한다. 따라서 환경 간 불일치로 인한 버그가 줄어든다. 개발자와 QA 엔지니어는 프로덕션 환경과 거의 일치하는 안정적인 테스트 환경을 이용할 수 있다.</p>
<h4 id="Resilience"><a href="#Resilience" class="headerlink" title="Resilience"></a>Resilience</h4><p>쿠버네티스는 개발자가 자동확장, 롤링 업데이트, IDC간 이중화 등 복원력이 뛰어난 애플리케이션을 구축할 수 있는 기능을 제공한다. 그러나 이 복원력 기능은 쿠버네티스의 유연한 아키텍처를 사용해 의도적으로 구현해야 한다.</p>
<h4 id="Large-Ecosystem"><a href="#Large-Ecosystem" class="headerlink" title="Large Ecosystem"></a>Large Ecosystem</h4><p>쿠버네티스를 중심으로 활발한 오픈 소스 커뮤니티는 다양한 용도에 맞게 사용자 정의할 수 있는 많은 도구, 플러그인, 확장 및 리소스를 만들었다. </p>
<h4 id="Vendor-Neutral"><a href="#Vendor-Neutral" class="headerlink" title="Vendor Neutral"></a>Vendor Neutral</h4><p>온프레미스 및 퍼블릭 클라우드 전반에서 다양한 인프라를 지원하는 쿠버네티스는 단일 공급업체에 종속되는 것을 방지한다. 필요에 따라 적합한 인프라를 유연하게 선택할 수 있다.</p>
<h3 id="The-Main-Drawbacks"><a href="#The-Main-Drawbacks" class="headerlink" title="The Main Drawbacks"></a>The Main Drawbacks</h3><p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231103162419830.png" alt=""></p>
<h4 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h4><p>쿠버네티스의 가장 큰 단점은 복잡성이다. 특히 많은 컴포넌트들이 유기적으로 동작하는 프로덕션급 배포의 경우 쿠버네티스의 광범위한 기능으로 인해 복잡해진다. 제대로 설정하고 관리하려면 상당한 전문 지식이 필요하게 된다.</p>
<p>지속적인 관리와 문제 해결에도 전문 엔지니어링 기술이 필요하다. 잘못된 설정으로 인해 쿠버네티스에 배포된 애플리케이션이 쉽게 중단될 수 있다. 심층적인 데브옵스 기술이 없는 소규모 팀의 경우 이런 복잡성이 이점을 능가할 수 있다. 특히 대규모 분산 시스템을 처음 사용하는 팀에게는 학습 곡선이 가파르다.</p>
<h4 id="Resource-Overheads"><a href="#Resource-Overheads" class="headerlink" title="Resource Overheads"></a>Resource Overheads</h4><p>쿠버네티스를 실행하면 오버헤드 리소스 비용이 발생한다. 쿠버네티스 컨트롤 플레인에는 특정 기준 수준의 리소스가 필요하다. 이제 막 시작한 소규모 애플리케이션이나 조직에서는 이런 오버헤드 비용이 이점을 정당화하지 못할 수 있다. 쿠버네티스를 실행하는데 필요한 리소스가 과도할 수 있다.</p>
<p>쿠버네티스를 제대로 운영하는데 필요한 인적 자원도 간접비용을 부과한다. 대규모 시스템의 경우 쿠버네티스 인프라를 풀타임으로 관리하려면 전담 팀이 필요하다. 많은 소규모 팀의 경우 이런 운영 비용을 정당화하기 어렵다. 쿠버네티스의 효율성이 성과를 거두는 손익분기점은 생각보다 높다.</p>
<h4 id="Security-Concerns"><a href="#Security-Concerns" class="headerlink" title="Security Concerns"></a>Security Concerns</h4><p>플랫폼의 configurable한 부분이 많기 때문에 쿠버네티스 환경의 보안을 유지하는 것은 쉽지 않다. 제대로 관리하려면 전문 지식과 지속적인 확인이 필요하다.</p>
<h4 id="Resource-Underutilization"><a href="#Resource-Underutilization" class="headerlink" title="Resource Underutilization"></a>Resource Underutilization</h4><p>쿠버네티스는 리소스 사용을 최적화하는 것을 목표로 하지만, 부적절한 설정은 오버프로비저닝과 낭비를 초래할 수도 있다. 실제 사용률에 따라 클러스터 리소스의 크기를 적절히 조정하는 것이 중요하다.</p>
<h4 id="Upgrade-Headaches"><a href="#Upgrade-Headaches" class="headerlink" title="Upgrade Headaches"></a>Upgrade Headaches</h4><p>쿠버네티스 클러스터를 최신 상태로 유지하려면 업그레이드 중에 애플리케이션 다운 타임을 최소화하고 호환성을 유지하기 위해 신중한 계획과 실행이 필요하다.</p>
<h4 id="Limited-Support-for-Stateful-Apps"><a href="#Limited-Support-for-Stateful-Apps" class="headerlink" title="Limited Support for Stateful Apps"></a>Limited Support for Stateful Apps</h4><p>상태 비저장 워크로드에 최적화되어 있지만 쿠버네티스는 StatefulSets, persistent volumes, affinity/anti-affinity 등의 기능을 통해 스테이트풀 애플리케이션을 지원할 수 있는 기능을 제공한다. 데이터베이스와 같은 스테이트풀 애플리케이션에 대한 지원이 개선되고 있지만, 쿠버네티스에서 이를 실행하는 데는 여전히 추가적인 복잡성이 수반된다.</p>
<h3 id="Our-Take"><a href="#Our-Take" class="headerlink" title="Our Take"></a>Our Take</h3><p>쿠버네티스는 엄청난 이점을 제공하지만 단점도 있다. 환경 간 이동성, 고가용성, 운영 효율성이 요구되는 대규모 분산 애플리케이션에 탁월하다. 하지만 복잡성과 리소스 오버헤드가 발생하기도 한다. 모든 엔지니어링 결정과 마찬가지로 애플리케이션 요구 사항과 팀 제약 조건에 따라 장단점을 평가해야 한다. 비용 및 역량과 같은 비즈니스 고려 사항과 함께 기술적 장단점을 모두 고려해야 적절한 결정을 내릴 수 있다.</p>
<h2 id="Use-Cases-for-Kubernetes"><a href="#Use-Cases-for-Kubernetes" class="headerlink" title="Use Cases for Kubernetes"></a>Use Cases for Kubernetes</h2><p>쿠버네티스는 대규모의 복잡한 애플리케이션에서 빛을 발한다. 하지만 모든 워크로드에 적합하지는 않다. 쿠버네티스가 탁월한 주요 사용 사례와 오버엔지니어링의 주요 사례를 살펴본다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231103163507107.png" alt=""></p>
<h3 id="Microservices"><a href="#Microservices" class="headerlink" title="Microservices"></a>Microservices</h3><p>마이크로서비스 아키텍처는 애플리케이션을 작고 독립적인 서비스로 나눈다. 이는 쿠버네티스와 잘 어울린다. 각 마이크로서비스는 자체 컨테이너 이미지로 패키징할 수 있다. 그러면 쿠버네티스는 각각을 개별적으로 배포하고 관리할 수 있다.</p>
<p>트래픽 패턴이 변화함에 따라 쿠버네티스는 각 서비스의 레플리카 수를 원활하게 늘리거나 줄일 수 있다. 다운타임 없이 단계적 업데이트를 통해 새 버전을 롤아웃할 수 있다. 쿠버네티스는 이런 까다로운 조율 작업을 자동으로 처리한다.</p>
<p>예를 들어 Spotify는 마이크로서비스 아키텍처를 관리할 때 몇 가지 문제에 직면했다.</p>
<ul>
<li>독립적인 팀에서 구축한 수백 개의 개별 마이크로 서비스</li>
<li>잦은 신규 서비스 출시</li>
<li>예측할 수 없는 트래픽과 사용량 급증</li>
<li>방대한 규모 - 1600개 이상의 서비스 및 빠른 성장세</li>
</ul>
<p>쿠버네티스 이전에는 Spotify에서 직접 만든 도구를 사용해 가상 머신을 관리했다. 이로 인해 병목 현상이 발생해 혁신이 느려졌다. 엔지니어들은 리소스에 대한 셀프서비스 엑세스 권한이 부족했다. 이런 문제를 해결하기 위해 Spotify는 쿠버네티스를 도입했다.</p>
<ul>
<li>독립적인 배포를 위해 각 마이크로서비스를 컨테이너 이미지로 패키지화</li>
<li>개발부터 프로덕션까지 신속한 배포를 위해 쿠버네티스 자동화 활용</li>
<li>트래픽 폭증을 처리하기 위한 파드의 동적 확장</li>
<li>롤링 업데이트를 통해 새로운 기능을 자주 릴리즈</li>
<li>병목 현상 없이 리소스에 대한 엔지니어의 셀프 서비스 엑세스</li>
</ul>
<p>쿠버네티스 사용의 영향은 아래와 같다.</p>
<ul>
<li>개발자 생산성 및 만족도 향상</li>
<li>1000개 이상의 마이크로서비스와 수천 개의 인스턴스로 확장 가능</li>
<li>빠른 혁신 속도 - 매월 100개 이상의 새로운 마이크로서비스 출시</li>
<li>사용 패턴의 변화에 빠르게 적응</li>
<li>개발자가 업데이트를 릴리스할 때 병목 현상 방지</li>
</ul>
<h3 id="Machine-Learning"><a href="#Machine-Learning" class="headerlink" title="Machine Learning"></a>Machine Learning</h3><p>쿠버네티스는 GPU 스케쥴링, 우선순위 클래스, 노드 선호도와 같은 기능을 통해 머신 러닝 워크로드를 최적화할 수 있도록 지원한다. 이는 학습과 추론 작업 간의 리소스 할당을 개선해 ML 워크로드 성능을 향상시킨다.</p>
<p>OpenAI는 GPT 및 DALL-E와 같은 여러 획기적인 AI 제품을 출시하면서 트래픽 및 머신 러닝 워크로드의 엄청난 증가를 지원하기 위해 인프라를 점검해야 한다는 것을 알고 있었다. 당시의 인프라는 AWS에 있었다. 그러나 컴퓨팅 요구가 비용 효율적으로 확장할 수 있는 AWS의 역량을 초과함에 따라 아키텍처를 현대화할 방법을 모색했다.</p>
<p>그리고 환경을 자동화하고 최적화하기 위해 쿠버네티스를 도입하기로 결정했다. 쿠버네티스는 OpenAI의 워크로드를 실행할 수 있는 클라우드에 구애받지 않는 플랫폼을 제공했다. 쿠버네티스를 도입한 후 OpenAI는 기본 클라우드 제공업체와 독립적으로 애플리케이션을 개발 및 배포할 수 있었다.</p>
<p>주요 동기는 GPU에서 대규모 신경망 모델의 계산 집약적인 훈련을 포함하는 AI 연구에 대한 지원을 개선하는 것이였다. 기존 인프라에서는 GPU 리소스를 효율적으로 할당하기가 어려웠다. 쿠버네티스는 파드 요청과 제한을 사용해 GPU를 세밀하게 제어할 수 있었다. 엔지니어들은 각 트레이닝 작업의 필요에 맞게 GPU 클러스터를 동적으로 프로비저닝 할 수 있었다. 이를 통해 GPU 사용률이 30%에서 80% 이상으로 향상되어 트레이닝 비용을 절감하는데 큰 도움이 되었다.</p>
<p>또한 쿠버네티스는 트레이닝 작업의 원활한 자동 확장을 가능하게 했다. 연구원들은 수백 개의 실험을 동시에 실행하고 빠르게 반복해 최적의 모델 아키텍처와 하이퍼 파라미터를 찾을 수 있었다.</p>
<p>프로덕션 배포의 경우 쿠버네티스는 최종 사용자에게 AI 모델을 제공하는 지연 시간을 최소화했다. 이전에는 2주가 걸리던 모델을 단 2일 만에 사용할 수 있게 되었다. 실시간 자동 확장을 통해 사용자는 추론을 위한 컴퓨팅 리소스에 지연 시간이 짧은 액세스를 보장받을 수 있었다.</p>
<p>더 넓게 보면 쿠버네티스는 OpenAI의 개발 워크플로우를 가속화했다. API를 통해 인프라를 프로그래밍 방식으로 관리할 수 있었기 때문에 엔지니어는 과거에 주 단위로 코드를 배포하던 것을 하루에 여러 번 배포할 수 있었다. 예를 들어 마이그레이션 후 첫 달에 16개의 주요 서비스를 배포하는 등 성능 저하 없이 며칠 만에 새로운 서비스를 출시할 수 있었다.</p>
<p>쿠버네티스는 고정 서버를 프로비저닝할 필요가 없어 비용을 40% 절감했다. 리소스는 실시간 트래픽 패턴에 따라 확장 및 축소할 수 있었다. 상태 점검과 자가 복구 기능 덕분에 가동 중단도 60% 감소했다.</p>
<p>OpenAI는 Google의 GKE 서비스를 사용해 쿠버네티스를 빠르게 시작했다. Google Cloud 인프라 비용을 감당할 수 없게 되었을 때 쿠버네티스를 통해 OpenAI는 몇 주 만에 Microsoft Azure로 원활하게 마이그레이션 할 수 있었다.</p>
<p>쿠버네티스로 마이그레이션함으로 OpenAI는 새로운 AI 모델을 빠르게 실험하는 동시에 글로벌 규모로 효율적으로 서비스하는데 필요한 자동화, 확장성, 안정성 및 멀티클라우드 이식성을 확보할 수 있었다. ChatGPT의 출시는 이 클라우드 네이티브 인프라가 연구 및 제품 혁신을 지원하는데 끼친 영향을 잘 보여준다.</p>
<h3 id="Global-Scale"><a href="#Global-Scale" class="headerlink" title="Global Scale"></a>Global Scale</h3><p>전 세계 사용자에게 짧은 지연 시간으로 서비스를 제공해야 하는 애플리케이션을 전세계적으로 운영하는 것은 매우 복잡하다. 쿠버네티스는 여러 지역에 걸쳐 있는 클러스터 간의 분산 조정을 위한 중요한 기본 기능을 제공해 이런 복잡성을 관리하는데 도움을 준다.</p>
<p>Geo-DNS, anycast IPs, global load balancing과 같은 글로벌 트래픽 관리 패턴은 전 세계 사용자의 지연 시간을 줄이는데 더욱 도움이 된다. 다중 스케줄러 및 페더레이션과 같은 정교한 쿠버네티스 기능은 여러 지역과 영역에 걸친 대규모 글로벌 쿠버네티스 풋프린트 운영을 간소화한다.</p>
<p>여러 쿠버네티스 스케줄러 인스턴스를 여러 지역에서 실행할 수 있다. 이를 통해 스케줄링 결정을 파드가 실행되는 위치에 더 가깝게 내릴 수 있어 성능이 향상된다. 페더레이션은 클러스터 차이를 추상화해 사용자가 멀리 떨어진 클라스터에서 익숙한 쿠버네티스 API 오브젝트로 작업할 수 있도록 한다.</p>
<p>예를 들어 포켓몬 고가 출시되었을 때 포켓몬 고는 필요에 따라 클러스터를 전 세계적으로 확장하기 위해 GKE를 사용했다. 이를 통해 사용자가 있는 곳에서 서비스를 제공하기 위한 글로벌 규모 컨테이너 오케스트레이션을 수행할 수 있었다. 쿠버네티스를 통해 개발팀은 포켓몬 고의 글로벌 팬층을 만족시킬 수 있는 기능을 신속하게 배포하는데 집중할 수 있었다. 초기 쿠버네티스 배포는 당시 GKE에서 가장 큰 규모였다.</p>
<p>포켓몬 고가 새로운 국가에서 출시되었을 때 예상보다 훨씬 더 많은 플레이어가 몰렸다. 포켓몬 고는 엄청난 신규 사용자의 유입에 대비했지만, 플레이어 수는 최악의 예측을 훨씬 뛰어넘었다. 늘어난 플레이어를 모두 처리하기 위해 GKE의 쿠버네티스 클러스터를 확장하기 위해 수 만 개의 컴퓨팅 코어를 추가했다. 이를 통해 원래 계획했던 플레이어 수의 50배가 넘는 플레이어를 지원할 수 있었다.</p>
<p>다중 스케줄러와 페더레이션과 같은 쿠버네티스 기능은 포켓몬 고가 전 세계적으로 폭발적인 수요를 관리하는데 매우 중요했다. 전 세계에서 매일 수백만 명의 신규 플레이어가 가입하는 가운데 이러한 기능 덕분에 게임이 원활하고 반응이 좋게 유지되었다.</p>
<p>포켓몬 고의 성공은 기업이 지연 시간을 줄이기 위해 geo-DNS, anycast IPs, global load balancing과 같은 패턴을 사용해 전 세계적으로 쿠버네티스를 활용할 수 있는 방법을 보여준다. 이를 통해 차세대 글로벌 규모의 애플리케이션을 구현할 수 있다.</p>
<h3 id="Hybrid-and-Multi-Cloud"><a href="#Hybrid-and-Multi-Cloud" class="headerlink" title="Hybrid and Multi-Cloud"></a>Hybrid and Multi-Cloud</h3><p>현대의 기업들은 점점 더 여러 지역에 걸쳐 여러 프라이빗 데이터센터와 AWS, GCP, Azure와 같은 퍼블릭 클라우드에 걸쳐 복잡한 하이브리드 환경을 운영하고 있다.</p>
<p>쿠버네티스는 이런 이질적이고 분산된 공간에서 워크플로를 통합할 수 있는 일관된 컨트롤 플레인을 제공한다. 즉 뉴욕의 프라이빗 데이터 센터와 싱가포르의 퍼블릭 클라우드 인스턴스에 컨테이너를 배포하는데 동일한 쿠버네티스 API를 사용할 수 있다.</p>
<p>클라우드에 구애받지 않는 이런 이식성 덕분에 개발자는 기본 인프라에 대한 걱정 없이 강력한 애플리케이션을 구축하는데 집중할 수 있다. 운영팀은 하이브리드 인프라를 코드로 관리할 수 있는 유연성을 확보할 수 있다. 네트워크 스토리지, 보안 및 기타 리소스에 대한 통합 추상화를 통해 쿠버네티스는 온프레미스 환경과 퍼블릭 클라우드 환경을 원활하게 연결할 수 있도록 지원한다. 분산 마이크로서비스로 구축된 서비스는 데이터센터와 클라우드를 아우를 수 있다.</p>
<p>선도적인 금융 데이터 기업인 블룸버그는 각각 수천 개의 노드로 구성된 수백 개의 쿠버네티스 클러스터를 운영하며 대규모 프라이빗 네트워크와 퍼블릭 클라우드 전반에서 서비스를 오케스트레이션 한다.</p>
<p>블룸버그의 개발자들은 쿠버네티스를 활용해 런던의 터미널에서 도쿄의 온프레미스 인프라로 앱과 데이터 파이프라인을 신속하게 배포한다. 통합된 쿠버네티스 워크플로를 통해 전 세계에 분산된 프라이빗 클라우드를 퍼블릭 클라우드만큼 민첩하게 사용할 수 있다.</p>
<p>쿠버네티스는 하이브리드 클라우드에 필수적인 일관성을 제공한다. 이를 통해 기업은 클라우드 벤더 종속을 방지하면서 통합 컨트롤 플레인에서 배포를 표준화할 수 있다. 워크로드를 환경 간에 마이그레이션하거나 비용과 성능에 따라 워크로드의 균형을 맞출 수 있다.</p>
<p>블룸버그의 경험에서 알 수 있듯이 쿠버네티스는 개발자의 생산성과 운영 유연성을 높여 온프레미스와 클라우드를 연결한다. 하이브리드 쿠버네티스는 퍼블릭 및 프라이빗 환경의 고유한 이점을 희생하지 않으면서 워크플로를 통합한다.</p>
<h3 id="Beyond-the-Code"><a href="#Beyond-the-Code" class="headerlink" title="Beyond the Code"></a>Beyond the Code</h3><p>쿠버네티스는 단순히 애플리케이션 코드를 실행하는 것 이상의 인프라 관리 방법을 제공한다. 쿠버네티스를 통해 팀은 코드형 인프라 접근 방식을 취하여 전체 환경을 자동화하고 최적화할 수 있다. 쿠버네티스가 코드형 인프라를 구현하는 몇 가지 주요 방법을 확인해보자.</p>
<ul>
<li>Declarative Infrastructure : 쿠버네티스 구성을 사용하면 네트워크, 스토리지, 보안 정책 등과 같은 인프라의 원하는 상태를 선언할 수 있다. 쿠버네티스는 실제 상태와 원하는 상태를 일치시키기 위해 작동한다. 이는 절차적이고 스크립트화된 인프라 변경보다 더 효율적이다.</li>
<li>GitOps Pipelines : 쿠버네티스는 코드와 인프라 모두에 대한 신뢰할 수 있는 단일 소스인 Git에 의존하는 GitOps 워크플로우를 지원한다. 인프라 변경 사항은 코드 변경 사항과 함께 버전 제어된다. ArgoCD와 같은 GitOps 에이전트는 쿠버네티스 클러스터 상태를 Git 레포지토리에 동기화한다.</li>
<li>Policy as Code : RBAC 및 네트워크 정책과 같은 보안 및 거버넌스 정책을 쿠버네티스에서 코드로 정의할 수 있다. 이를 통해 여러 환경에서 일관된 정책을 적용할 수 있다. 정책은 코드처럼 버전 제어 및 테스트할 수 있다.</li>
<li>Automated Management : 쿠버네티스 컨트롤러는 사람의 개입 없이 자동으로 변경 사항을 롤아웃하고 문제를 감지하고 구성 요소를 재시작하는 등의 작업을 수행한다. 이는 일상적인 관리 작업을 자동화한다.</li>
<li>Improved Monitoring : 쿠버네티스는 파이프라인, 로깅 및 메트릭 모니터링에 대한 기본 지원을 제공한다. 이를 통해 애플리케이션뿐만 아니라 인프라에 대한 통합 가시성을 제공한다.</li>
<li>Self-Healing Capabilities : 쿠버네티스는 컨테이너 재시작, 노드 교체, 워크로드 스케줄 재조정 등 특정 장애를 자가 복구할 수 있다. 이를 통해 복원력이 향상된다.</li>
</ul>
<p>이런 기능을 함께 사용하면 팀은 버전 제어, 테스트 및 자동화와 같은 소프트웨어 개발 모범 사례를 인프라 관리에 적용할 수 있다. 쿠버네티스를 사용하면 인프라를 완전히 코드로 관리할 수 있다.</p>
<h3 id="When-Kubernetes-May-Not-Be-the-Best-Fit"><a href="#When-Kubernetes-May-Not-Be-the-Best-Fit" class="headerlink" title="When Kubernetes May Not Be the Best Fit"></a>When Kubernetes May Not Be the Best Fit</h3><p>쿠버네티스는 컨테이너화된 애플리케이션을 배포하고 관리하기 위한 선도적인 플랫폼으로 부상했다. 그러나 이런 인기에도 불구하고 쿠버네티스가 항상 이상적인 솔루션은 아닐 수 있다. 특정 사용 사례를 평가해 쿠버네티스가 적합한지 또는 Docker Swarm, autoscaling virtual machine clusters 및 서버리스 아키텍처와 같은 대안이 더 적합한지 판단하는 것이 중요하다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231103233225268.png" alt=""> </p>
<h4 id="Small-Scale-Deployments"><a href="#Small-Scale-Deployments" class="headerlink" title="Small-Scale Deployments"></a>Small-Scale Deployments</h4><p>워크로드가 작거나 리소스가 제한되어 있는 경우, 쿠버네티스 실행에 따른 오버헤드가 이점을 능가할 수 있다. 쿠버네티스 클러스터를 설정하고 운영하는데 필요한 복잡성과 리소스는 더 간단한 솔루션에 비해 상당한 운영 오버헤드를 유발한다. 따라서 소규모 회사, 리소스가 제한된 프로젝트 또는 최소한의 규모를 가진 애플리케이션에는 적합하지 않다.</p>
<h4 id="Simple-Applications"><a href="#Simple-Applications" class="headerlink" title="Simple Applications"></a>Simple Applications</h4><p>모놀리식 또는 단순한 아키텍처를 가진 애플리케이션은 종종 쿠버네티스의 모든 기능을 필요로 하지 않는다. 분산된 구성 요소나 마이크로서비스가 필요하지 않은 애플리케이션의 경우 쿠버네티스를 도입하면 무의미한 복잡성이 추가될 수 있다. 애플리케이션 로드 밸런서 뒤에 있는 단순한 가상 머신 클러스터와 같은 기존 배포 방식이 단순하고 가벼운 앱에 더 적합할 수 있다.</p>
<h4 id="Rapid-Development-and-Prototyping"><a href="#Rapid-Development-and-Prototyping" class="headerlink" title="Rapid Development and Prototyping"></a>Rapid Development and Prototyping</h4><p>신속하고 반복적인 프로토타이핑이 우선순위인 경우 쿠버네트스는 개발 속도가 느려질 수 있다. 학습 곡선과 클러스터를 구성하고 배포하는데 필요한 노력으로 인해 새로운 아이디어를 빠르게 프로토타이핑 하는데는 쿠버네티스가 적합하지 않다. AWS Fargate 및 Google App Engine과 같은 경량 플랫폼을 사용하면 개발자가 운영상의 우려를 줄여 더 빠르게 프로토타입을 빌드하고 테스트할 수 있다. 이런 플랫폼의 단순성과 자동 관리 기능 덕분에 전체 쿠버네티스 클러스터를 구성하고 관리해야 하는 복잡함 없이 빠르게 실험할 수 있다. 새로운 개념을 빠르게 개발하고 평가하기 위해 이런 플랫폼을 사용하면 팀은 쿠버네티스 클러스터 관리가 아닌 반복 잡업에 집중할 수 있다.</p>
<h4 id="Lack-of-Expertise"><a href="#Lack-of-Expertise" class="headerlink" title="Lack of Expertise"></a>Lack of Expertise</h4><p>쿠버네티스의 복잡성은 숙련도가 부족하면 잘못된 설정, 보안 문제, 비효율적인 리소스 활용으로 이어질 수 있음을 의미한다. 쿠버네티스를 도입하기 전에 팀은 자신의 역량과 학습 의지를 정직하게 평가해야 한다. 컨테이너 오케스트레이션 경험이 없는 팀의 경우 관리형 쿠버네티스 제품이 진입 장벽을 낮추는데 도움이 될 수 있다. 또는 AWS Fargate 및 Google Cloud Run과 같은 완전 관리형 서버리스 컨테이너 플랫폼은 운영 복잡성을 줄여주므로 관리형 쿠버네티스 제품보다 더 쉬운 시작점이 될 수 있다.</p>
<h4 id="Cost-Considerations"><a href="#Cost-Considerations" class="headerlink" title="Cost Considerations"></a>Cost Considerations</h4><p>쿠버네티스 컨트롤 플레인 구성 요소의 워커 노드의 리소스 요구사항은 단순한 호스팅 솔루션에 비해 비용이 증가하는 경우가 많다. 대규모 워크로드에서는 쿠버네티스의 확장 및 자동화 강점이 이러한 비용을 정당화할 수 있지만 팀은 비용 / 편익 절충을 평가해야 한다.</p>
<h4 id="Legacy-System-Integration"><a href="#Legacy-System-Integration" class="headerlink" title="Legacy System Integration"></a>Legacy System Integration</h4><p>오래된 모놀리식 애플리케이션은 쿠버네티스의 컨테이너를 도입하는데 어려움을 겪을 수 있다. 레거시 애플리케이션을 컨테이너화해 마이크로서비스로 분해하려면 상당한 리팩터링이 필요할 수 있다. 일부 레거시 시스템의 경우 이런 수준의 변경이 불가능할 수도 있다.</p>
<h4 id="Our-Take-1"><a href="#Our-Take-1" class="headerlink" title="Our Take"></a>Our Take</h4><p>워크로드 요구사항과 팀 역량을 평가한 후 쿠버네티스를 도입해야 한다. 전문적인 데브옵스 운영하에 대규모의 동적 워크로드를 처리하는 경우 쿠버네티스는 엄청난 가치를 제공한다. 하지만 복잡성과 리소스 비용이 발생해 작고 단순하거나 정적인 워크로드에서는 결과가 약할 수 있다. 기술 규모를 적절하게 조정해야한다. 워크로드 드라이브와 팀 제약 조건에 따라 쿠버네티스 도입 여부를 결정해야 한다.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>쿠버네티스는 컨테이너 오케스트레이션의 표준으로 자리잡았지만 만병통치약은 아니다. 쿠버네티스를 성공으로 이끄는 열쇠는 그 강점을 이해하고 적절한 워크로드에 적용하는 것이다. 적절하게 사용하면 운영을 간소화 할 수 있다. 하지만 잘못 적용하면 오버헤드로 인해 생산성이 저하될 수 있다. 쿠버네티스의 일반적인 성공 요인은 아래와 같다.</p>
<ul>
<li>동적인 리소스 요구가 있는 많은 마이크로 서비스로 구성된 애플리케이션</li>
<li>온프레미스, 클라우드, 하이브리드 환경 전반에서 이식성이 필요</li>
<li>자동 확장 및 롤링 업데이트와 같은 잦은 변경을 처리해야 하는 인프라</li>
<li>쿠버네티스의 복잡성을 처리할 수 있는 강력한 데브옵스 기술을 갖춘 팀</li>
</ul>
<p>이런 기준을 충족하는 조직은 이점을 누릴 수 있는 유리한 위치에 있다. 쿠버네티스는 생산성, 안정성, 효율성을 크게 개선할 수 있다. 경제성 또한 규모에 따라 유리하게 변화한다. 쿠버네티스의 고정 오버헤드 비용은 많은 노드와 애플리케이션에 걸쳐 상각된다. 반면에 다음과 같은 경우에는 쿠버네티스를 신중하게 사용해야 한다.</p>
<ul>
<li>애플리케이션이 단순하거나 정적 리소스 요구 사항이 있는 경우</li>
<li>환경 이식성이 우선순위가 아닌 경우</li>
<li>팀이 분산 시스템에 대한 심층적인 운영 경험이 부족한 경우</li>
</ul>
<p>이런 경우 오케스트레이션의 복잡성이 도움이 되기 보다는 오히려 방해가 될 수 있다. 물론 흑백으로 나뉘는 기술 결정은 거의 없다. 필요에 따라 장단점을 면밀히 평가하고 도입 여부를 결정해야 한다.</p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2023/11/03/System%20Design/ByteByteGo/private/kubernetes-when-and-how-to-apply-it/">https://songhayoung.github.io/2023/11/03/System%20Design/ByteByteGo/private/kubernetes-when-and-how-to-apply-it/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2025 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>