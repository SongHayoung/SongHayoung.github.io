<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[ByteByteGo] Common failure causes"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[ByteByteGo] Common failure causes | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Common-failure-causes"><span class="toc-number">1.</span> <span class="toc-text">Common failure causes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hardware-faults"><span class="toc-number">2.</span> <span class="toc-text">Hardware faults</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Incorrect-error-handling"><span class="toc-number">3.</span> <span class="toc-text">Incorrect error handling</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Configuration-changes"><span class="toc-number">4.</span> <span class="toc-text">Configuration changes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Single-points-of-failure"><span class="toc-number">5.</span> <span class="toc-text">Single points of failure</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Network-faults"><span class="toc-number">6.</span> <span class="toc-text">Network faults</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Resource-leaks"><span class="toc-number">7.</span> <span class="toc-text">Resource leaks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Load-pressure"><span class="toc-number">8.</span> <span class="toc-text">Load pressure</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cascading-failures"><span class="toc-number">9.</span> <span class="toc-text">Cascading failures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Managing-risk"><span class="toc-number">10.</span> <span class="toc-text">Managing risk</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.instagram.com/hayoung0_0/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">9511</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">192</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">60</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[ByteByteGo] Common failure causes</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-08-25</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/Byte-Byte-Go/">Byte Byte Go</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1.5k</span><span class="post-meta__separator">|</span><span>Reading time: 9 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Common-failure-causes"><a href="#Common-failure-causes" class="headerlink" title="Common failure causes"></a>Common failure causes</h2><span id="more"></span>
<p>시스템이 사양에 맞는 서비스를 더 이상 사용자에게 제공하지 못할 때 장애가 발생했다고 말한다. 장애는 내부의 구성 요소의 오류 또는 시스템이 의존하는 외부 종속성 등의 결함으로 인해 발생한다. 일부 결함은 견딜 수 있고 사용자에게 전혀 영향을 미치지 않지만 다른 결함은 장애로 이어진다.</p>
<p>내결함성 애플리케이션을 구축하려면 먼저 무엇이 잘못될 수 있는지 파악해야 한다. 다음 몇 섹션에서는 장애의 가장 일반적인 근본 원인 몇 가지를 살펴본다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230825203041233.png" alt=""></p>
<h2 id="Hardware-faults"><a href="#Hardware-faults" class="headerlink" title="Hardware faults"></a>Hardware faults</h2><p>컴퓨터의 모든 물리적 부품은 고장날 수 있다. HDD, 메모리 모듈, 전원 공급 장치, 마더보드, SSD, NIC 또는 CPU는 모두 다양한 이유로 작동을 멈출 수 있다. 경우에 따라 하드웨어 결함으로 인해 데이터 손상도 발생할 수 있다. 그것도 모자라 정전이나 자연재해로 인해 데이터센터 전체가 다운될 수도 있다.</p>
<p>나중에 설명하겠지만, 이중화를 통해 이러한 인프라 결함 중 상당수를 해결할 수 있다. 이러한 결함이 분산 애플리케이션 장애의 주요 원인이라고 생각할 수 있지만, 실제로는 매우 일상적인 이유로 장애가 발생하는 경우가 많다.</p>
<h2 id="Incorrect-error-handling"><a href="#Incorrect-error-handling" class="headerlink" title="Incorrect error handling"></a>Incorrect error handling</h2><p>2014년에 5개의 유명 분산 데이터 저장소에서 사용자가 보고한 장애를 조사한 <a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-yuan.pdf">연구</a>에 따르면 치명적인 장애의 대부분은 치명적이지 않은 오류를 잘못 처리한 결과였다.</p>
<p>대부분의 경우 오류 처리의 버그는 간단한 테스트를 통해 발견할 수 있었다. 예를 들어 일부 핸들러는 오류를 완전히 무시했다. 다른 핸들러는 Java의 예외와 같이 지나치게 일반적인 예외를 포착하여 정당한 이유 없이 전체 프로세스를 중단했다. 그리고 일부 핸들러는 부분적으로만 구현되었고 심지어 “FIXME” 및 “TODO” 주석이 포함되어 있었다.</p>
<p>돌이켜보면 오류 처리는 뒷전으로 밀리는 경향이 있다는 점을 감안하면 이는 그리 놀라운 일은 아니다. 이것이 바로 Go언어가 오류 처리에 많은 중점을 두는 이유이다. 대규모 분산 애플리케이션을 테스트하기 위한 모범 사례를 자세히 살펴보자.</p>
<h2 id="Configuration-changes"><a href="#Configuration-changes" class="headerlink" title="Configuration changes"></a>Configuration changes</h2><p>구성 설정 변경은 치명적인 장애를 일으키는 주요 근본 원인 중 하나다. 잘못된 구성뿐만 아니라 거의 사용하지 않는 기능을 활성화하기 위해 유효한 구성을 변경하여 더 이상 예상대로 작동하지 않거나 전혀 작동하지 않는 경우도 문제를 일으킨다.</p>
<p>구성 변경이 특히 위험한 이유는 그 효과가 지연될 수 있기 때문이다. 애플리케이션이 실제로 필요할 때만 구성 값을 읽는다면 잘못된 값이 변경된 후 몇 시간 또는 며칠이 지난 후에야 적용되어 조기 탐지를 피할 수 있다.</p>
<p>그렇기 때문에 구성 변경도 코드 변경과 마찬가지로 버전 관리, 테스트 및 릴리즈되어야 하며, 변경이 발생할 때 예방적으로 유효성 검사를 수행해야 한다. 이 글 에서는 지속적인 배포의 맥락에서 코드 및 구성 변경에 대한 안전한 릴리즈 관행에 대해 설명한다.</p>
<h2 id="Single-points-of-failure"><a href="#Single-points-of-failure" class="headerlink" title="Single points of failure"></a>Single points of failure</h2><p>단일 장애 지점(SPOF)은 장애가 발생하면 시스템 전체가 다운되는 구성 요소를 말한다. 실제로 시스템에는 여러 SPOF가 있을 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230825203805944.png" alt=""></p>
<p>인간은 훌륭한 SPOF를 만들고, 그들이 스스로 재앙적인 실패를 일으킬 수 있는 위치에 놓인다면, 그들이 결국 그렇게 될 것이라고 장담할 수 있다. 예를 들어, 사람이 실수 없이 일련의 작업 단계를 특정 순서대로 수동으로 실행해야 할 때 인간은 종종 실패한다. 반면에 컴퓨터는 명령을 실행하는데 능숙하기 때문에 가능한 한 자동화를 활용해야 한다.</p>
<p>또 다른 일반적인 SPOF는 DNS다. 클라이언트가 애플리케이션의 도메인 이름을 확인할 수 없으면 애플리케이션에 연결할 수 없다. 도메인 이름이 만료되는 것부터 전체 루트 레벨 도메인이 다운되는 것까지 여러 가지 이유가 있다.</p>
<p>마찬가지로 애플리케이션이 HTTP 엔드포인트에 사용하는 TLS 인증서도 SPOF다. 인증서가 만료되면 클라이언트는 애플리케이션과의 보안 연결을 열 수 없다.</p>
<p>이상적으로는 시스템을 설계할 때 SPOF를 식별해야 한다. 이를 감지하는 가장 좋은 방법은 모든 시스템 구성 요소를 검사하고 실패할 경우 어떤 일이 발생할지 묻는 것이다. 일부 SPOF는 이중화를 도입하는 등 설계를 통해 제거할 수 있지만, 그렇지 않는 경우도 있다. 이 경우 남은 유일한 옵션은 SPOF의 폭발 반경, 즉 장애 발생 시 시스템에 가해지는 피해를 줄이는 것이다. 나중에 설명할 복원력 패턴 중 상당수가 장애의 폭발 반경을 줄여준다.</p>
<h2 id="Network-faults"><a href="#Network-faults" class="headerlink" title="Network faults"></a>Network faults</h2><p>클라이언트가 서버에 요청을 보내면 잠시 후 서버로부터 응답을 받을 것으로 예상한다. 가장 좋은 경우에는 요청을 보낸 직후 응답을 받는다. 그렇지 않은 경우 클라이언트는 계속 기다리거나 시간 초과 예외 또는 오류를 발생시켜 요청을 실패하는 두 가지 옵션이 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230825204619992.png" alt=""></p>
<p>장애 감지 및 시간 제한이라는 개념이 도입되었을 때 신속한 응답을 받지 못하는 이유는 여러 가지가 있었다. 예를 들어 서버가 매우 느리거나 요청을 처리하는 동안 충돌이 발생했을 수 있고, 네트워크 패킷의 일부가 손실되어 재전송과 지연이 많이 발생할 수도 있다.</p>
<p>느린 네트워크 호출은 분산 시스템의 조용한 살인자다. 클라이언트는 응답이 최종적으로 도착할지 여부를 알 수 없기 때문에 포기하기까지 오랜 시간을 기다릴 수 있으며, 포기할 경우 디버깅하기 어려운 성능 저하를 초래할 수 있다. 이런 종류의 오류를 <a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2017/06/paper-1.pdf">gray failure</a>라고도 하며 매우 미묘하여 신속하고 정확하게 감지할 수 없는 오류다. 회색 실패는 그 특성상 전체 시스템을 쉽게 중단시킬 수 있다.</p>
<h2 id="Resource-leaks"><a href="#Resource-leaks" class="headerlink" title="Resource leaks"></a>Resource leaks</h2><p>관찰자의 관점에서 볼 때 매우 느린 프로세스는 전혀 실행되지 않는 프로세스와 크게 다르지 않으며, 둘 다 유용한 작업을 수행할 수 없다. 리소스 누수는 프로세스 속도 저하의 가장 일반적인 원인 중 하나이다.</p>
<p>메모리는 누수의 영향을 받는 가장 잘 알려진 리소스다. 메모리 누수는 시간이 지남에 따라 메모리 소비를 꾸준히 증가시킨다. 가비지 컬렉션이 있는 언어도 누수에 취약하다. 더 이상 필요하지 않는 객체에 대한 참조가 어딘가 보관되어 있으면 가비지 컬렉션이 이를 삭제할 수 없기 때문이다. 누수로 인해 메모리가 너무 많이 소모되어 남은 메모리가 거의 없는 경우 운영체제는 메모리 페이지를 디스크에 공격적으로 스왑하기 시작한다. 또한 가비지 콜렉터가 더 자주 작동하여 메모리를 해제하려고 시도한다. 이 모든 것이 CPU 주기를 소모하고 프로세스를 느리게 만든다. 결국 물리적 메모리가 더 이상 남아 있지 않고 스왑 파일에 더 이상 공간이 없으면 프로세스가 메모리를 할당할 수 없게 되고 대부분의 작업이 실패하게 된다.</p>
<p>메모리는 누수될 수 있는 많은 리소스 중 하나에 불과하다. 스레드 풀을 예로 들면, 풀에서 획득한 스레드가 시간 초과 없이 동기식 차단 HTTP 호출을 수행한 후 호출이 반환되지 않으면 해당 스레드는 풀로 반환되지 않는다. 그리고 풀은 최대 크기가 제한되어 있기 때문에 계속 스레드를 잃게 되면 결국 스레드가 부족해 진다.</p>
<p>앞의 경우 동기 호출이 아닌 비동기 호출을 하는것이 도움이 될 것이라고 생각할 수 있다. 하지만 최신 HTTP 클라이언트는 소켓 풀을 사용해 TCP 연결을 다시 생성하고 성능 요금을 지불하는 것을 피한다. 시간 제한 없이 요청이 이루어지면 연결이 풀로 반환되지 않는다. 풀에는 최대 크기가 제한되어 있으므로 결국에는 연결이 남지 않는다.</p>
<p>게다가 메모리, 스레드, 소켓에 엑세스하는 것은 코드만이 아니다. 애플리케이션이 의존하는 라이브러리도 동일한 리소스를 사용하므로 방금 설명한 것과 동일한 문제에 직면할 수 있다.</p>
<h2 id="Load-pressure"><a href="#Load-pressure" class="headerlink" title="Load pressure"></a>Load pressure</h2><p>모든 시스템에는 견딜 수 있는 부하량, 즉 용량의 한계가 있다. 따라서 시스템으로 향하는 부하가 계속 증가하면 조만간 그 한계에 도달할 수밖에 없다. 그러나 유기적으로 부하가 증가하여 시스템이 그에 따라 확장하고 용량을 늘릴 수 있는 시간을 주는 것과 갑작스럽고 예상치 못한 폭증은 전혀 다른 문제다.</p>
<p>예를 들어 일정 기간 동안 애플리케이션이 수신한 요청 수를 생각해 보세요. 들어오는 요청의 속도와 유형은 시간이 지남에 따라, 때로는 다양한 이유로 갑자기 변할 수 있다.</p>
<p>요청에 계절적 요인이 있을 수 있다. 예를 들어, 하루 중 시간에 따라 다른 국가의 사용자들이 애플리케이션에 접속하는 비율이 달라질 수 있다. 어떤 요청은 다른 요청보다 훨씬 비싸고, 초인적인 속도로 데이터를 훑어보는 스크레퍼와 같이 예상치 못한 방식으로 시스템을 악용하기도 한다. 일부 요청은 애플리케이션의 대역폭을 포화시켜 정상적인 사용자의 액세스를 거부하려는 DDoS 공격과 같은 악의적인 요청이다.</p>
<p>일부 부하 급증은 용량을 추가하는 자동화(e.g., autoscaling)로 처리할 수 있지만, 다른 부하 급증은 시스템이 요청을 거부하여 과부하를 방지해야 한다.</p>
<h2 id="Cascading-failures"><a href="#Cascading-failures" class="headerlink" title="Cascading failures"></a>Cascading failures</h2><p>시스템에 수백 개의 프로세스가 있는 경우 일부 프로세스가 느리거나 연결이 되지 않는다고 해도 큰 차이가 없을 것이라고 생각할 수 있다. 문제는 결함이 바이러스처럼 퍼져 전체 시스템이 무너질 때까지 한 프로세스에서 다른 프로세스로 연쇄적으로 확산될 수 있다는 점이다. 이는 시스템 구성 요소가 서로 의존하고 있고 한 구성 요소에 장애가 발생하면 다른 구성 요소에 장애가 발생할 확률이 높아질 때 발생한다.</p>
<p>예를 들어, 여러 클라이언트가 부하 분산 장치 뒤에 있는 두 개의 데이터베이스 복제본인 A와 B를 쿼리한다고 가정해 보자. 각 복제본은 초당 약 50개의 트랜잭션을 처리한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230825205848486.png" alt=""></p>
<p>네트워크 오류로 인해 복제본 B를 갑자기 사용할 수 없게 된다. 로드 밸런서는 B를 사용할 수 없음을 감지하고 풀에서 제거한다. 따라서 복제본 A는 B의 공백을 메우고 이전에 처리하던 단위 시간당 요청의 두 배를 처리해야 한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230825205931584.png" alt=""></p>
<p>복제본 A가 들어오는 요청을 따라잡는데 어려움을 겪으면 클라이언트는 점점 더 많은 시간 초과를 경험하고 요청을 다시 시도하기 시작해 시스템에 더 많은 부하가 추가된다. 결국 복제본 A는 너무 많은 부하를 받아 대부분의 요청이 시간 초과되어 로드 밸런서가 풀에서 복제본을 제거해야 한다. 즉, 복제본 B를 사용할 수 없게 만든 원래의 네트워크 장애가 복제본 A의 장애로 연쇄적으로 이어진 것이다.</p>
<p>이제 복제본 B를 다시 사용할 수 있게 되고 로드 밸런서가 이를 풀에 다시 넣는다고 가정해 본다. 풀에 있는 유일한 복제본이기 때문에 요청이 폭주하여 과부하가 발생하고 결국 다시 제거될 것이다. 네트워크 장애가 사라진 후에도 부하가 한 복제본에서 다른 복제본으로 이동하는 피드백 루프 때문에 애플리케이션이 계속 어려움을 겪는 것을 볼 수 있다. 이러한 특성을 가진 장애를 <a target="_blank" rel="noopener" href="https://sigops.org/s/conferences/hotos/2021/papers/hotos21-s11-bronson.pdf">metasable</a>이라고 한다.</p>
<p>이 루프를 끊으려면 일반적으로 트래픽이 복제본으로 이동하는 것을 일시적으로 차단하는 등 충분히 큰 수정 조치가 필요하다. 안타깝게도 이러한 장애는 일단 시작되면 완화하기가 매우 어려우며, 이를 방지하는 가장 좋은 방법은 애초에 장애가 한 구성 요소에서 다른 구성 요소로 확산되는 것을 막는 것이다.</p>
<h2 id="Managing-risk"><a href="#Managing-risk" class="headerlink" title="Managing risk"></a>Managing risk</h2><p>이쯤 되면 분명한 사실이지만, 분산 애플리케이션은 결함이 불가피하다는 사실을 받아들이고 결함이 발생했을 때 이를 감지, 대응, 복구할 수 있도록 준비해야 한다.</p>
<p>이 시점에서 잘못될 수 있는 일의 양이 너무 많아서 압도당할 수 있다. 하지만 특정 결함이 발생할 가능성이 있다고 해서 이에 대한 조치를 취해야 한다는 의미는 아니다. 먼저 결함이 발생할 확률과 결함이 발생했을 때 시스템 사용자에게 미칠 영향을 고려해야 한다. 이 두 가지 요소를 곱하면 위험 점수를 얻을 수 있다. 이 점수는 먼저 해결해야 할 결함의 우선순위를 정하는데 사용할 수 있다. 예를 들어, 발생할 가능성이 매우 높고 영향이 큰 결함은 정면으로 해결해야 하고, 반면에 발생 가능성이 낮고 영향이 적은 결함은 기다릴 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230825211102623.png" alt=""></p>
<p>특정 결함에 대해 조치를 취해야 한다고 결정하면 결함 발생 가능성을 줄이거나 영향을 줄일 수 있다.</p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2023/08/25/System%20Design/ByteByteGo/private/common-failure-causes/">https://songhayoung.github.io/2023/08/25/System%20Design/ByteByteGo/private/common-failure-causes/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2023 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>