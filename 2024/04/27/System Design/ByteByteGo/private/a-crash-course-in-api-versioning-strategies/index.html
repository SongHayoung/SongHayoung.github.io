<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[ByteByteGo] A Crash Course in API Versioning Strategies"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[ByteByteGo] A Crash Course in API Versioning Strategies | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-Crash-Course-in-API-Versioning-Strategies"><span class="toc-number">1.</span> <span class="toc-text">A Crash Course in API Versioning Strategies</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-Version-APIs"><span class="toc-number">2.</span> <span class="toc-text">Why Version APIs?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#When-to-Version-APIs"><span class="toc-number">3.</span> <span class="toc-text">When to Version APIs?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Version-Strategies"><span class="toc-number">4.</span> <span class="toc-text">Version Strategies</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Additive-change-strategy"><span class="toc-number">4.1.</span> <span class="toc-text">Additive change strategy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Explicit-versioning-strategy"><span class="toc-number">4.2.</span> <span class="toc-text">Explicit versioning strategy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#URI-components-versioning"><span class="toc-number">4.2.1.</span> <span class="toc-text">URI components versioning</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-header-versioning"><span class="toc-number">4.2.2.</span> <span class="toc-text">HTTP header versioning</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Request-parameter-versioning"><span class="toc-number">4.2.3.</span> <span class="toc-text">Request parameter versioning</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Version-Labels-SemVer"><span class="toc-number">5.</span> <span class="toc-text">Version Labels (SemVer)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Decommissioning-Versions"><span class="toc-number">6.</span> <span class="toc-text">Decommissioning Versions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sunset-header"><span class="toc-number">6.1.</span> <span class="toc-text">Sunset header</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Versioning-Communication"><span class="toc-number">7.</span> <span class="toc-text">Versioning Communication</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tools-and-Libraries-for-API-Versioning"><span class="toc-number">8.</span> <span class="toc-text">Tools and Libraries for API Versioning</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Summary"><span class="toc-number">9.</span> <span class="toc-text">Summary</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/hayoung-song-9523b61bb/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">11148</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">196</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">62</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[ByteByteGo] A Crash Course in API Versioning Strategies</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-04-27</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/Byte-Byte-Go/">Byte Byte Go</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1.3k</span><span class="post-meta__separator">|</span><span>Reading time: 7 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="A-Crash-Course-in-API-Versioning-Strategies"><a href="#A-Crash-Course-in-API-Versioning-Strategies" class="headerlink" title="A Crash Course in API Versioning Strategies"></a>A Crash Course in API Versioning Strategies</h2><span id="more"></span>
<p>API를 개발하려면 계획부터 구현까지 많은 작업이 필요하다. 개발자가 혼동하지 않도록 명확하고 이해하기 쉬운 버전 관리 전략을 세우는 것이 중요하다. 이번 포스트는 API를 위한 다양한 버전 관리 전략을 살펴본다.</p>
<h2 id="Why-Version-APIs"><a href="#Why-Version-APIs" class="headerlink" title="Why Version APIs?"></a>Why Version APIs?</h2><p>API에 새 기능을 추가하거나 기존 문제를 해결하거나 API 작동 방식을 변경할 때 사용자에게 혼란을 주지 않으면서 이런 변경 사항을 전달해야 한다. 예를 들어 일기 예보용 API가 있다고 가정하자. 수천 개의 웹사이트에서 대시보드 및 기타 애플리케이션을 구축하는 데 이 API를 사용하고 있다.</p>
<p>응답 객체의 데이터 계약을 변경하고 싶다고 가정해보자. 여기에는 필드 이름 변경, 새 필드 추가, 전체 데이터 계약 변경이 포함되어 있다. 기존 필드 이름을 변경하면 사용자의 애플리케이션이 작동을 멈추거나 오류가 발생하기 시작할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240427110317223.png" alt=""></p>
<p>이 문제를 해결하려면 모든 사용자에게 최신 변경 사항이 적용되도록 애플리케이션을 업데이트하게 요청해야 한다. 이런 일이 자주 발생하면 사용자의 불만이 커질 것이다.</p>
<p>버전 관리는 이 문제를 해결한다. 획기적인 변경 사항을 릴리즈하고 싶을 때는 API 버전을 업그레이드 한다. 그리고 사용자가 변경 사항을 언제 받아들일지 선택할 수 있는 방식으로 릴리즈한다.</p>
<p>일단 고객이 API를 사용하기 시작하면 원래 설계된 대로 작동한다. 고객의 요구 사항을 고려하지 않고 변경하거나 새 버전을 출시하면 문제가 발생할 수 있다. 그렇기 때문에 API 버전을 공개하고 고객이 준비되었을 때 업그레이드할 수 있는 선택권을 주는 것이 중요하다.</p>
<p>그렇기 때문에 변경에 대비한 설계가 API에 필수적이다. 버전 관리를 사용해 명확하고 일관되며 잘 문서화된 방식으로 사용자에게 변경 사항을 전달해야 한다.</p>
<h2 id="When-to-Version-APIs"><a href="#When-to-Version-APIs" class="headerlink" title="When to Version APIs?"></a>When to Version APIs?</h2><p>버전 관리가 너무 자주 이루어지면 혼란을 초래할 수 있고 개발자가 코드를 자주 업데이트해야 할 수 있으므로 버전 관리를 너무 자주 해서는 안된다. 다음은 새 API 버전이 필요한 몇 가지 시나리오다.</p>
<ul>
<li>중대한 변경 사항 : 잠재적으로 소프트웨어를 중단시킬 수 있는 변경을 하는 경우. 예를 들어 페이로드에 새로운 필수 필드를 도입하거나 API 호출에서 더 이상 유효하지 않은 매개변수를 제거하는 경우</li>
<li>새로운 기능 : 기존 사용자와의 이전 버전과의 호환성을 보장하면서 API에 새로운 기능을 추가하는 경우</li>
<li>버그 수정 : API의 버그나 문제를 해결할 때는 기존 소비자에게 혼란을 주지 않으면서 수정 사항을 적용하는 것이 중요하다.</li>
<li>성능 개선 : 사용자가 API와 상호작용하는 방식을 바꿀 수 있는 성능 향상 또는 최적화를 구현할 때</li>
</ul>
<h2 id="Version-Strategies"><a href="#Version-Strategies" class="headerlink" title="Version Strategies"></a>Version Strategies</h2><h3 id="Additive-change-strategy"><a href="#Additive-change-strategy" class="headerlink" title="Additive change strategy"></a>Additive change strategy</h3><p>이 접근 방식에선 기존 기능을 수정하지 않고 새로운 기능이나 필드를 API에 추가한다. API에 대한 모든 업데이트는 이전 버전과 호환되어야 한다.</p>
<p>그러나 일부 작업은 추가 변경 전략에서 허용되지 않는다. </p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240427110815417.png" alt=""></p>
<p>반면에 가능한 작업들의 예는 아래와 같다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240427110847587.png" alt=""></p>
<p>가능한 작업 옵션중 마지막은 모순적으로 보일 수 있지만 그렇지 않다. 주요 아이디어는 변경 사항을 깨지 않도록 하는 것이다. 사용자가 옵트인할 수 있는 한 기존 코드를 손상시키지 않는다.</p>
<p>예를 들어 아래와 같이 가상의 날씨 API에 다음과 같은 응답이 있다고 가정해 보자. 처음 API를 출시했을 때는 기압 데이터를 포함하는 것이 좋다고 생각했다. 하지만 기압 데이터가 항상 필요한 것은 아니며 네트워크 부하만 가중시킨다는 사용자의 불만이 여러 차례 제기된 후 이를 제거하기로 결정했다.</p>
<p>추가 변경 전략에서는 일부 클라이언트가 여전히 기압 데이터를 사용할 수 있기 때문에 단순히 기압 데이터를 제거할 순 없다.</p>
<p>하지만 사용자가 <code>exclude_pressure=true</code> 와 같은 매개변수를 추가해 기압 데이터를 제외하는 최신 API를 사용하겠다고 명시함으로써 변경에 동의하는 경우 이를 제거할 수 있다. 이렇게 하면 다른 사용자에게는 피해를 주지 않으면서 불편을 겪는 사용자의 문제를 제거할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240427111153889.png" alt=""></p>
<h3 id="Explicit-versioning-strategy"><a href="#Explicit-versioning-strategy" class="headerlink" title="Explicit versioning strategy"></a>Explicit versioning strategy</h3><p>이 접근 방식에는 여러 버전의 API를 유지한다. API를 변경하고 싶을 때 새 버전으로 릴리즈한다. 이는 변경을 중단할 수 없는 추가 변경 전략과는 다르다. 명시적 버전 변경 전략은 모든 종류의 변경을 허용하며, 이것이 가장 큰 차이점이다.</p>
<p>이 전략을 사용하려면 사용자가 특정 버전과 상호작용할 수 있도록 번호가 매겨진 시스템을 만들어야 한다. 이를 버전 관리 체계라고 한다. 이런 액세스 패턴을 지원하기 위해 소비자가 사용하려는 API 버전을 알려주는 다양한 방법이 있다.</p>
<h4 id="URI-components-versioning"><a href="#URI-components-versioning" class="headerlink" title="URI components versioning"></a>URI components versioning</h4><p>이 방법에서는 버전 체계가 URI에 추가된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240427111410294.png" alt=""></p>
<p>이 방법의 한 가지 장점은 요청과 그 버전을 더 쉽게 디버깅하고 검사할 수 있다는 것이다. 버전은 요청 URI에 명확하게 표시된다. 반대로 이런 엔드포인트를 영구 링크로 지원하지 않는 경우에는 이 접근 방식을 피해야 한다. 또한 이 접근 방식을 사용할 때는 300대의 HTTP  상태 코드를 지원할 수 있도록 준비해야 한다. 이런 코드는 이동했거나 이동 중인 리소스에 대한 리디렉션을 나타낸다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240427111523432.png" alt=""></p>
<h4 id="HTTP-header-versioning"><a href="#HTTP-header-versioning" class="headerlink" title="HTTP header versioning"></a>HTTP header versioning</h4><p>사용자 정희 헤더를 만들거나 콘텐츠 유형 헤더를 “accept”를 사용해 HTTP 헤더를 사용하여 버전을 지정할 수 있다. 아래 예시와 같이 URI에 버전 체계를 넣는 대신 헤더를 사용한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240427111610344.png" alt=""></p>
<p>이 접근 방식의 한 가지 장점은 URI를 깔끔히 유지하고 혼란을 줄인다는 점이다. 하지만 버전이 잘 보이지 않기 때문에 디버깅이 어려워진다. 또한 클라이언트가 서로 다른 버전으로 전송된 두 요청을 동일한 요청으로 인식하는 경우 클라이언트 캐싱에 문제가 발생할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240427111701373.png" alt=""></p>
<h4 id="Request-parameter-versioning"><a href="#Request-parameter-versioning" class="headerlink" title="Request parameter versioning"></a>Request parameter versioning</h4><p>이 방법은 사용자가 요청 매개변수를 통해 원하는 매개변수를 지정할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240427111732725.png" alt=""></p>
<p>이 접근 방식은 URI 컴포넌트 버전 관리와 유사한 이점이 있다. 하지만 애플리케이션에서 요청 매개변수를 관리하는 것은 까다로울 수 있다. 요청 매개변수는 요청이 특정 엔드포인트에 도달한 후에만 확인된다. 즉, 특정 엔드포인트에서 지원되는 버전 수에 따라 단일 엔드포인트가 많은 요청과 복잡한 로직을 처리해야 할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240427111829559.png" alt=""></p>
<h2 id="Version-Labels-SemVer"><a href="#Version-Labels-SemVer" class="headerlink" title="Version Labels (SemVer)"></a>Version Labels (SemVer)</h2><p>API 버전에 라벨을 붙이는 시스템에 대해 알아보자. 일반적으로 사용되는 시스템은 Semantic Versioning Specification, 줄여서 SemVer라고 한다. SemVer에는 3가지 유형이 있다.</p>
<ul>
<li>Major</li>
<li>Minor</li>
<li>Patch</li>
</ul>
<p>API에 2.0.0 버전이 있다고 가정해보자.</p>
<p>메이저 버전은 변경 사항이나 이전 버전과 호환되지 않는 변경 사항에 사용한다. 이런 변경을 수행하면 메이저 버전 번호가 증가한다. 이렇게 하면 API 버전이 2.0.0 에서 3.0.0으로 변경된다.</p>
<p>마이너 버전은 이전 버전과 호환되는 새로운 기능을 추가하기 위한 것이다. 이런 유형의 변경으로 인해 버전은 3.0.0 에서 3.1.0으로 변경된다.</p>
<p>패치 버전은 이전 버전과 호환되는 버그 수정을 위한 버전이다. 패치 버전이 변경되면 버전이 3.1.0 에서 3.1.1로 증가한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240427112241138.png" alt=""></p>
<h2 id="Decommissioning-Versions"><a href="#Decommissioning-Versions" class="headerlink" title="Decommissioning Versions"></a>Decommissioning Versions</h2><p>계속해서 변경 사항을 적용하고 새 버전을 출시하면 코드베이스의 모든 버전을 유지관리 해야한다. 하지만 이는 장기적으로 볼 때 이상적이지 않다. 이전 버전을 폐기하는 방법을 고려해야 한다.</p>
<p>일부 조직에서는 현재 버전 뒤에 있는 가장 최신 버전 두 개만 유지 관리한다. 예를 들어 현재 버전 3을 사용중이고 API 버전 4를 릴리즈하는 경우 해당 릴리즈에 앞서 버전 1을 더 이상 사용하지 않는 작업을 진행한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240427112354147.png" alt=""></p>
<p>유지보수를 쉽게 하기 위해 가능한 한 적은 수의 버전을 유지하는 것이 가장 좋다.</p>
<h3 id="Sunset-header"><a href="#Sunset-header" class="headerlink" title="Sunset header"></a>Sunset header</h3><p>Sunset 헤더를 사용할 수도 있다. 이 헤더는 응답 개체에 추가되며 특정 시간에 리소스를 사용할 수 없게 될 것으로 예상됨을 나타낸다. 소비자는 이런 Sunset timestamp를 힌트로 간주해야 한다. 시간에 도달하면 해당 리소스를 요청할 때 400레벨 오류나 300레벨 리디렉션이 발생해야 한다. Sunset 헤더에는 리소스가 폐기된 후 어떤 유형의 오류가 발생할지 지정할 필요가 없다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240427112527343.png" alt=""></p>
<h2 id="Versioning-Communication"><a href="#Versioning-Communication" class="headerlink" title="Versioning Communication"></a>Versioning Communication</h2><p>이제 API 버전 관리 프로세스의 중요한 부분인 커뮤니케이션에 주목해 보자.</p>
<p>개발자에게 새 버전에 대해 알리고 버전을 전환할 수 있는 전환 기간을 확보하려면 어떻게 해야 할까? 새 API 버전을 만들어 모든 개발자에게 즉시 사용하도록 하는 것은 좋은 사용성이 아니다. 개발자 커뮤니티가 내부 개발자 또는 회사의 버전 릴리즈 프로세스에 익숙한 신뢰할 수 있는 소수의 파트너로만 구성된 경우에는 예외일 수 있다.</p>
<p>대부분의 경우 이전 버전을 일정 기간 동안 활성 상태로 유지하고 사용하는 전환 기간이 필요하다. 그렇다면 이 기간은 얼마나 길어야 할까? 일반적으로 6개월에서 12개월 정도다. 이 기간 동안 보안 패치나 버그 수정 등의 작업을 위해 이전 버전을 계속 유지관리해야 한다.</p>
<p>사용 중단 날짜를 설정할 때 고려해야 할 몇 가지 요소는 다음과 같다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240427112748321.png" alt=""> </p>
<h2 id="Tools-and-Libraries-for-API-Versioning"><a href="#Tools-and-Libraries-for-API-Versioning" class="headerlink" title="Tools and Libraries for API Versioning"></a>Tools and Libraries for API Versioning</h2><p>특히 시간이 지남에 따라 API가 성장하고 발전함에 따라 수작업으로 API 버전을 관리하는 것은 복잡해지고 오류가 발생하기 쉽다. 이 점이 API 버전 관리를 위해 특별히 설계된 도구와 라이브러리가 필요한 이유다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240427112835389.png" alt=""></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>추가 변경 전략은 변경 용량이 제한된 소규모 프로젝트에는 적합할 수 있지만 시간이 지남에 따라 진화하고 성장하며 새로운 비즈니스 로직을 추가해야 하는 엔터프라이즈 애플리케이션에는 적합하지 않을 수 있다. 명시적인 버전 관리 전략은 복잡한 변경 사항을 관리하는데 훨씬 더 적합하다. 제품이 지속적으로 진화하고 있으며 추가 변경 전략과 같은 접근 방식이 적합하지 않은 Stripe 및 Slack과 같은 회사가 명시적 버전 관리 전략을 사용하는 이유도 바로 이 때문이다.</p>
<p>API 버전 관리에서 일관성의 중요성을 강조하면서 이 주제를 마무리 한다. 개발자는 원래 예상하지 못했던 방식으로 최고의 API를 널리 사용한다는 점을 기억해야 한다. 즉, 회사 내 개별 부서가 아닌 회사가 버전 관리 표준을 설정해야 한다. 일관성을 유지하면 개발자가 Facebook의 API를 사용해 소프트웨어를 더 쉽게 사용하고 유지관리할 수 있다.</p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2024/04/27/System%20Design/ByteByteGo/private/a-crash-course-in-api-versioning-strategies/">https://songhayoung.github.io/2024/04/27/System%20Design/ByteByteGo/private/a-crash-course-in-api-versioning-strategies/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2024 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>