<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[System Design] Real-time Gaming Leaderboard"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[System Design] Real-time Gaming Leaderboard | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Real-time-Gaming-Leaderboard"><span class="toc-number">1.</span> <span class="toc-text">Real-time Gaming Leaderboard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-1-Understand-the-Problem-and-Establish-Design-Scope"><span class="toc-number">2.</span> <span class="toc-text">Step 1 - Understand the Problem and Establish Design Scope</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Functional-requirements"><span class="toc-number">2.1.</span> <span class="toc-text">Functional requirements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Non-functional-requirements"><span class="toc-number">2.2.</span> <span class="toc-text">Non-functional requirements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Back-of-the-envelope-estimation"><span class="toc-number">2.3.</span> <span class="toc-text">Back-of-the-envelope estimation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-2-Propose-High-Level-Design-and-Get-Buy-In"><span class="toc-number">3.</span> <span class="toc-text">Step 2 - Propose High-Level Design and Get Buy-In</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API-design"><span class="toc-number">3.1.</span> <span class="toc-text">API design</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#High-level-architecture"><span class="toc-number">3.2.</span> <span class="toc-text">High-level architecture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-models"><span class="toc-number">3.3.</span> <span class="toc-text">Data models</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Relational-database-solution"><span class="toc-number">3.3.1.</span> <span class="toc-text">Relational database solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-solution"><span class="toc-number">3.3.2.</span> <span class="toc-text">Redis solution</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#What-are-sorted-sets"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">What are sorted sets?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Implementation-using-Redis-sorted-sets"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">Implementation using Redis sorted sets</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Storage-requirement"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">Storage requirement</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-3-Design-Deep-Dive"><span class="toc-number">4.</span> <span class="toc-text">Step 3 - Design Deep Dive</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#To-use-a-cloud-provider-or-not"><span class="toc-number">4.0.1.</span> <span class="toc-text">To use a cloud provider or not</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Manage-our-own-services"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">Manage our own services</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Build-on-the-cloud"><span class="toc-number">4.0.1.2.</span> <span class="toc-text">Build on the cloud</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Scaling-Redis"><span class="toc-number">4.0.2.</span> <span class="toc-text">Scaling Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Data-sharding"><span class="toc-number">4.0.2.1.</span> <span class="toc-text">Data sharding</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Hash-partition"><span class="toc-number">4.0.2.2.</span> <span class="toc-text">Hash partition</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Sizing-a-Redis-node"><span class="toc-number">4.0.2.3.</span> <span class="toc-text">Sizing a Redis node</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Alternative-solution-NoSQL"><span class="toc-number">4.0.3.</span> <span class="toc-text">Alternative solution: NoSQL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-4-Wrap-Up"><span class="toc-number">4.1.</span> <span class="toc-text">Step 4 - Wrap Up</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-Summary"><span class="toc-number">5.</span> <span class="toc-text">Chapter Summary</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/hayoung-song-9523b61bb/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">11129</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">198</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">62</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[System Design] Real-time Gaming Leaderboard</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-12-25</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/System-Design-Interview/">System Design Interview</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3.8k</span><span class="post-meta__separator">|</span><span>Reading time: 23 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Real-time-Gaming-Leaderboard"><a href="#Real-time-Gaming-Leaderboard" class="headerlink" title="Real-time Gaming Leaderboard"></a>Real-time Gaming Leaderboard</h2><span id="more"></span>
<p>이 포스트에선 온라인 모바일 게임의 리더보드를 디자인 하는 과제를 살펴본다.</p>
<p>리더보드는 특정 토너먼트나 대회에서 누가 선두를 달리고 있는지 보여주기 위해 게임 등에서 흔히 사용된다. 사용자는 과제나 도전을 완료하면 점수를 부여받으며, 가장 많은 점수를 획득한 사람이 리더보드의 맨 위에 오르게 된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231225224820852.png" alt=""></p>
<h2 id="Step-1-Understand-the-Problem-and-Establish-Design-Scope"><a href="#Step-1-Understand-the-Problem-and-Establish-Design-Scope" class="headerlink" title="Step 1 - Understand the Problem and Establish Design Scope"></a>Step 1 - Understand the Problem and Establish Design Scope</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Candidate: How is the score calculated for the leaderboard?</span><br><span class="line">Interviewer: The user gets a point when they win a match. We can go with a simple point system in which each user has a score associated with them. Each time the user wins a match, we should add a point to their total score.</span><br><span class="line"></span><br><span class="line">Candidate: Are all players included in the leaderboard?</span><br><span class="line">Interviewer: Yes.</span><br><span class="line"></span><br><span class="line">Candidate: Is there a time segment associated with the leaderboard?</span><br><span class="line">Interviewer: Each month, a new tournament kicks off which starts a new leaderboard.</span><br><span class="line"></span><br><span class="line">Candidate: Can we assume we only care about the top 10 users?</span><br><span class="line">Interviewer: We want to display the top 10 users as well as the position of a specific user on the leaderboard. If time allows, let’s also discuss how to return users who are four places above and below a specific user.</span><br><span class="line"></span><br><span class="line">Candidate: How many users are in a tournament?</span><br><span class="line">Interviewer: Average of 5 million daily active users (DAU) and 25 million monthly active users (MAU).</span><br><span class="line"></span><br><span class="line">Candidate: How many matches are played on average during a tournament?</span><br><span class="line">Interviewer: Each player plays 10 matches per day on average.</span><br><span class="line"></span><br><span class="line">Candidate: How do we determine the rank if two players have the same score?</span><br><span class="line">Interviewer: In this case, their ranks are the same. If time allows, we can talk about ways to break ties.</span><br><span class="line"></span><br><span class="line">Candidate: Does the leaderboard need to be real-time?</span><br><span class="line">Interviewer: Yes, we want to present real-time results, or as close as possible. It is not okay to present a batched history of results.</span><br></pre></td></tr></table></figure>
<h3 id="Functional-requirements"><a href="#Functional-requirements" class="headerlink" title="Functional requirements"></a>Functional requirements</h3><ul>
<li>순위표 상위 10명의 플레이어 표시</li>
<li>사용자의 특정 순위를 표시</li>
<li>원하는 사용자보다 4계단 위와 아래에 있는 플레이어 표시</li>
</ul>
<h3 id="Non-functional-requirements"><a href="#Non-functional-requirements" class="headerlink" title="Non-functional requirements"></a>Non-functional requirements</h3><ul>
<li>실시간 점수 업데이트</li>
<li>점수업데이트는 리더보드에 실시간으로 반영</li>
<li>일반적인 확장성, 가용성 및 안정성 요구사항</li>
</ul>
<h3 id="Back-of-the-envelope-estimation"><a href="#Back-of-the-envelope-estimation" class="headerlink" title="Back-of-the-envelope estimation"></a>Back-of-the-envelope estimation</h3><p>솔루션이 해결해야 할 잠재적 규모와 챌린지를 결정하기 위해 몇 가지 계산을 살펴보자.</p>
<p>DAU가 500만 명인 게임에서 24시간 동안 플레이어가 고르게 분포되어 있다면 초당 평균 사용자 수는 50명(5,000,000 DAU / 10^5 = ~50명)이 될 것이다. 그러나 사용량이 고르페 분포되어 있지 않을 가능성이 높으며, 시간대가 다른 많은 사람들이 게임을 플레이하는 저녁 시간대에 피크가 발생할 가능성이 높다. 이를 고려하기 위해 최대 부하가 평균의 5배라고 가정할 수 있다. 따라서 초당 250명의 사용자에 대한 최대 부하를 허용해야 한다.</p>
<h2 id="Step-2-Propose-High-Level-Design-and-Get-Buy-In"><a href="#Step-2-Propose-High-Level-Design-and-Get-Buy-In" class="headerlink" title="Step 2 - Propose High-Level Design and Get Buy-In"></a>Step 2 - Propose High-Level Design and Get Buy-In</h2><h3 id="API-design"><a href="#API-design" class="headerlink" title="API design"></a>API design</h3><p>고수준에서 아래 API가 필요하다.</p>
<p><strong>POST /v1/scores</strong></p>
<p>사용자가 게임에서 승리하면 순위표에서 사용자의 위치를 업데이트한다. 요청 매개변수는 아래와 같다. 게임 서버에서만 호출할 수 있는 내부 API여야 한다. 클라이언트는 리더보드를 직접 업데이트할 수 없어야 한다.</p>
<ul>
<li>Request</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Field</strong></th>
<th style="text-align:left"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">user_id</td>
<td style="text-align:left">The user who wins a game.</td>
</tr>
<tr>
<td style="text-align:left">points</td>
<td style="text-align:left">The number of points a user gained by winning a game.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Response</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Name</strong></th>
<th style="text-align:left"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">200 OK</td>
<td style="text-align:left">Successfully updated a user’s score.</td>
</tr>
<tr>
<td style="text-align:left">400 Bad Request</td>
<td style="text-align:left">Failed to update a user’s score.</td>
</tr>
</tbody>
</table>
</div>
<p><strong>GET /v1/scores</strong></p>
<p>상위 10명의 플레이어를 리더보드에서 가져온다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;user_id&quot;: &quot;user_id1&quot;,</span><br><span class="line">      &quot;user_name&quot;: &quot;alice&quot;,</span><br><span class="line">      &quot;rank&quot;: 1,</span><br><span class="line">      &quot;score&quot;: 12543</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;user_id&quot;: &quot;user_id2&quot;,</span><br><span class="line">      &quot;user_name&quot;: &quot;bob&quot;,</span><br><span class="line">      &quot;rank&quot;: 2,</span><br><span class="line">      &quot;score&quot;: 11500</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">  &quot;total&quot;: 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>GET /v1/scores/{:user_id}</strong></p>
<p>특정 유저의 정보를 가져온다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Field</strong></th>
<th style="text-align:left"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">user_id</td>
<td style="text-align:left">The ID of the user whose rank we would like to fetch.</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;user_info&quot;: &#123;</span><br><span class="line">        &quot;user_id&quot;: &quot;user5&quot;,</span><br><span class="line">        &quot;score&quot;: 1000,</span><br><span class="line">        &quot;rank&quot;: 6,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="High-level-architecture"><a href="#High-level-architecture" class="headerlink" title="High-level architecture"></a>High-level architecture</h3><p>고수준의 디자인 다이어그램은 아래 나와있다. 이 디자인에는 두 가지 서비스가 있다. 게임 서비스는 사용자가 게임을 플레이할 수 있도록 하고 리더보드 서비스는 리더보드를 생성하고 표시한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231225225436788.png" alt=""></p>
<ol>
<li>플레이어가 게임에서 승리하면 클라이언트는 게임 서비스에 요청을 보낸다.</li>
<li>게임 서비스는 승리가 유효한지 확인하고 리더보드 서비스를 호출해 점수를 업데이트한다.</li>
<li>리더보드 서비스는 리더보드 스토어에서 사용자의 점수를 업데이트한다.</li>
<li>플레이어는 리더보드 서비스를 직접 호출해 다음과 같은 리더보드 데이터를 가져온다.<ol>
<li>상위 10명의 플레이어</li>
<li>플레이어의 리더보드상 순위</li>
</ol>
</li>
</ol>
<p>이 디자인을 결정하기 전에 몇 가지 대안을 고려한 결과 이 디자인을 채택하지 않기로 결정했다. 이에 대한 thought process를 살펴보고 여러 옵션을 비교하는 것이 도움이 될 것이다.</p>
<p><strong>Should the client talk to the leaderboard service directly?</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231225225647323.png" alt=""></p>
<p>대체 설계에서는 점수가 클라이언트에 의해 설정된다. 이 옵션은 플레이어가 프록시를 입력해 점수를 마음대로 변경할 수 있는 중간자 공격에 노출되기 때문에 안전하지 않다. 따라서 점수는 서버 사이드에서 설정해야 한다.</p>
<p>온라인 포커와 같은 서버가 권한을 가진 게임의 경우 클라이언트가 점수를 설정하기 위해 게임 서버를 명시적으로 호출하지 않아도 된다. 게임 서버는 모든 게임 로직을 처리하며, 게임 종료 시점을 파악해 클라이언트의 개입 없이 점수를 설정할 수 있다.</p>
<p><strong>Do we need a message queue between the game service and the leaderboard service?</strong></p>
<p>이 질문에 대한 답은 게임 점수가 어떻게 사용되는지에 따라 크게 달라진다. 데이터가 다른 곳에서 사용되거나 여러 기능을 지원하는 경우, 아래와 같이 Kafka에 데이터를 넣는 것이 좋다. 이렇게 하면 리더보드 서비스, 분석 서비스, 푸시 알림 서비스 등 여러 소비자가 동일한 데이터를 사용할 수 있다. 특히 게임에서 다른 플레이어에게 점수 업데이트를 알려야 하는 턴제 게임이나 멀티 플레이어 게임의 경우 더욱 그렇다. 이는 면접관과의 대화에서 명시적으로 요구되는 사항이 아니기 때문에 설계 시 메세지 큐를 사용하지 않는다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231225225933864.png" alt=""></p>
<h3 id="Data-models"><a href="#Data-models" class="headerlink" title="Data models"></a>Data models</h3><p>시스템의 핵심 구성 요소 중 하나는 리더보드 스토어다. RDB, Redis, NoSQL의 세 가지 잠재적 솔루션에 대해 살펴본다.</p>
<h4 id="Relational-database-solution"><a href="#Relational-database-solution" class="headerlink" title="Relational database solution"></a>Relational database solution</h4><p>먼저 한 걸음 물러나서 가장 간단한 솔루션부터 시작하자. 규모가 중요하지 않고 사용자가 소수에 불과하다면 어떻게 해야할까?</p>
<p>관계형 데이터베이스 시스템(RDS)을 사용하는 간단한 리더보드 솔루션을 선택할 가능성이 높다. 각 월별 리더보드는 사용자 ID와 점수 column이 포함된 데이터베이스 테이블로 표시할 수 있다. 사용자가 매치에서 승리하면 해당 사용자가 신규인 경우 1점을 부여하거나 기존 점수를 1점 올리면 된다. 리더보드에서 사용자의 순위를 결정하려면 점수에 따라 테이블을 내림차순으로 정렬한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231225230144725.png" alt=""></p>
<p>실제로 리더보드 테이블에는 game_id, 타임스탬프 등의 추가 정보가 있다. 그러나 리더보드를 쿼리하고 업데이트하는 방법의 기본 로직은 동일하게 유지된다. 간단히 설명하기 위해 리더보드 테이블에는 이번 달의 리더보드데이터만 저장된다고 가정한다.</p>
<p><strong>A user wins a point:</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231225230304855.png" alt=""></p>
<p>모든 점수 업데이트가 1씩 증가한다고 가정한다. 사용자의 해당 월의 리더보드에 아직 항목이 없는 경우 첫 번째 삽입이 이루어진다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO leaderboard (user_id, score) VALUES (&#x27;mary1934&#x27;, 1);</span><br></pre></td></tr></table></figure>
<p>사용자의 업데이트는 아래와 같다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE leaderboard set score=score + 1 where user_id=&#x27;mary1934&#x27;;</span><br></pre></td></tr></table></figure>
<p><strong>Find a user’s leaderboard position:</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231225230357950.png" alt=""></p>
<p>사용자의 순위를 얻기 위해 우리는 리더보드 태이블의 점수로 정렬된 순위를 질의해야 한다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT (@rownum := @rownum + 1) AS rank, user_id, score</span><br><span class="line">FROM leaderboard</span><br><span class="line">ORDER BY score DESC;</span><br></pre></td></tr></table></figure>
<p>질의 결과는 아래와 같을 것이다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>rank</strong></th>
<th style="text-align:left"><strong>user_id</strong></th>
<th style="text-align:left"><strong>score</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">happy_tomato</td>
<td style="text-align:left">987</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">mallow</td>
<td style="text-align:left">902</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">smith</td>
<td style="text-align:left">870</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">mary1934</td>
<td style="text-align:left">850</td>
</tr>
</tbody>
</table>
</div>
<p>이 솔루션은 데이터 집합이 작을 때 효과가 있지만 수백만 개의 row가 있는 경우 쿼리 속도가 매우 느려진다.</p>
<p>사용자의 순위를 파악하려면 모든 플레이어 순위표의 정확한 위치에 정렬해야 정확한 순위를 정확히 파악할 수 있다. 점수가 중복될 수도 있으므로 순위는 단순히 목록에서 사용자의 위치가 아니라는 점을 기억해야 한다.</p>
<p>SQL 데이터베이스는 지속적으로 변화하는 대량의 정보를 처리해야 할 때 성능이 떨어진다. 수백만 개의 row에 대해 순위 연산을 시도하면 수 초가 걸리기 때문에 원하는 실시간 접근 방식에 적합하지 않다. 데이터가 지속적으로 변경되기 때문에 캐시를 고려하는 것도 불가능하다.</p>
<p>관계형 데이터베이스는 이 구현에 필요한 읽기 쿼리의 높은 부하를 처리하도록 설계되지 않았다. 배치 작업으로 수행하면 RDS를 성공적으로 사용할 수 있지만, 리더보드에서 사용자의 실시간 순위를 반환해야 하는 요구 사항과 맞지 않다.</p>
<p>우리가 할 수 있는 한 가지 최적화는 인덱스를 추가하고 LIMIT 절을 사용해 스캔할 페이지 수를 제한하는 것이다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT (@rownum := @rownum + 1) AS rank, user_id, score</span><br><span class="line">FROM leaderboard</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 10</span><br></pre></td></tr></table></figure>
<p>그러나 이 접근 방식은 확장성이 떨어진다. 첫째, 순위를 결정하기 위해 기본적으로 테이블 스캔이 필요하기 때문에 사용자의 순위를 찾는 작업은 성능이 좋지 않다. 둘째, 이 접근 방식은 순위표의 최상위에 있지 않은 사용자의 순위를 결정하는 간단한 솔루션을 제공하지 못한다.</p>
<h4 id="Redis-solution"><a href="#Redis-solution" class="headerlink" title="Redis solution"></a>Redis solution</h4><p>수백만 명의 사용자에 대해서도 예측 가능한 성능을 제공하고, 복잡한 DB 쿼리에 의존하지 않고도 일반적인 리더보드 작업에 쉽게 액세스할 수 있는 솔루션을 찾고자 했다. Redis는 이런 문제에 대한 잠재적인 해결책을 제공한다. Redis는 KV 쌍을 지원하는 인메모리 데이터 스토어다. 메모리에서 작동하기 때문에 빠른 읽기 및 쓰기가 가능하다. Redis에는 리더보드 시스템 설계 문제를 해결하는데 이상적인 sorted set이라는 데이터 유형이 있다.</p>
<h5 id="What-are-sorted-sets"><a href="#What-are-sorted-sets" class="headerlink" title="What are sorted sets?"></a>What are sorted sets?</h5><p>sorted set은 집합과 유사한 데이터 유형이다. sorted set의 각 멤버는 점수와 연관된다. 집합의 멤버는 고유해야 하지만 점수는 중복될 수 있다. 점수는 오름차순으로 정렬된 집합의 순위를 매기는데 사용된다.</p>
<p>리더보드 사용 사례는 정렬된 집합에 완벽하게 매핑된다. 내부적으로 정렬된 집합은 해시테이블과 스킵 리스트라는 두 가지 데이터 구조로 구현된다. 해시 테이블은 사용자를 점수에 매핑하고 스킵 리스트는 점수를 사용자에 매핑한다. sorted set에서 사용자는 점수별로 정렬된다. </p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231225231057900.png" alt=""></p>
<p>이 포스트에서는 sorted set구현에 대한 자세한 내용은 다루지 않고 개략적인 아이디어만 살펴본다.</p>
<p>스킵 리스트는 빠른 검색을 가능하게 하는 리스트 구조다. 기본 정렬 링크 목록과 다단계 인덱스로 구성된다. 아래에서 리슽트는 단일 링크드 리스트다. 삽입, 제거, 검색 작업의 시간 복잡도는 O(n)이다.</p>
<p>이 연산을 더 빠르게 하는 방법은 이진 검색 알고리즘 처럼 빠르게 중간 값에 도달하는 것이다. 이를 위해 다른 모든 노드를 스킵 레벨 1 인덱스를 추가한 뒤, 레벨 1 인덱스의 다른 모든 노드를 스킵 레벨 2의 인덱스를 추가한다. 새로운 레벨이 추가될 때마다 다른 모든 노드를 건너 뛰는 방식으로 레벨을 계속 추가한다. 노드 간의 거리가 n / 2 - 1이 되면 이 추가를 중지한다. </p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231225231930155.png" alt=""></p>
<p>데이터 세트가 작으면 스킵 리스트를 사용한 속도 개선 효과가 분명하지 않다. 아래는 5단계 인덱스가 있는 스킵 리스트의 예를 보여준다. 기본 링크 목록에서는 올바른 노드에 도달하기 위해 62개의 노드를 이동해야 한다. 스킵리스트에서는 11개의 노드만 통과하면 된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231225232037384.png" alt=""></p>
<p>sorted set은 삽입 또는 업데이트 시 각 요소가 자동으로 올바른 순서로 배치되고 sorted set에서 추가 또는 검색 작업의 복잡도가 logarithmic이기 때문에 관계형 데이터베이스보다 성능이 뛰어나다. 이와 대조적으로 관계형 데이터베이스에서 특정 사용자의 순위를 계산하려면 중첩 쿼리를 실행해야 한다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *,(SELECT COUNT(*) FROM leaderboard lb2</span><br><span class="line">WHERE lb2.score &gt;= lb1.score) RANK</span><br><span class="line">FROM leaderboard lb1</span><br><span class="line">WHERE lb1.user_id = &#123;:user_id&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="Implementation-using-Redis-sorted-sets"><a href="#Implementation-using-Redis-sorted-sets" class="headerlink" title="Implementation using Redis sorted sets"></a>Implementation using Redis sorted sets</h5><p>sorted set이 빠르다는것을 알았으니 이제 리더보드를 작성하는데 사용할 연산을 살펴보자.</p>
<ul>
<li>ZADD : 사용자가 아직 존재하지 않는 경우 사용자를 집합에 삽입한다. 그렇지 않으면 사용자의 점수를 업데이트 한다. O(logn)</li>
<li>ZINCRBY : 사용자의 점수를 지정된 증분만큼 증가시킨다. 사용자가 집합에 존재하지 않으면 점수가 0에서 시작한다고 가정한다. O(logn)</li>
<li>ZRANGE / ZREVRANGE : 점수를 기준으로 정렬된 사용자 범위를 가져온다. 순서, 항목 수, 시작 위치를 지정할 수 있다. O(logn + m), n is number of elements, m is number of entries to fetch</li>
<li>ZRANK / ZREVRANK : 오름차순 / 내림차순으로 정렬된 모든 사용자의 위치를 log 복잡도로 가져온다.</li>
</ul>
<p><strong>Workflow with sorted sets</strong></p>
<ol>
<li>사용자가 점수를 획득한다.</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231225232444291.png" alt=""></p>
<p>매월 새로운 리더보드 sorted set을 생성하고 이전 리더보드는 과거 데이터 저장소로 이동한다. 사용자가 매치에서 승리하면 1점을 얻게 되므로 ZINCRBY를 호출해 해당 월의 순위표에서 사용자의 점수를 1점씩 증가시키거나, 아직 순위표에 없는 경우 해당 사용자를 순위표 집합에 추가할 수 있다. 사용자 ‘mary1934’가 매치에서 승리한 후 점수를 추가하는 쿼리는 다음과 같다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY leaderboard_feb_2021 1 &#x27;mary1934&#x27;</span><br></pre></td></tr></table></figure>
<ol>
<li>사용자가 상위 10명의 유저를 질의한다.</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231225232628627.png" alt=""></p>
<p>가장 높은 점수를 원하므로 내림차순으로 멤버를 가져오기 위해 ZREVRANGE를 호출하고, 각 사용자의 총 점수와 가장 높은 점수를 가진 사용자 집합도 반환하도록 ‘WITHSCORES’ 속성을 전달한다. 다음은 2021년 2월 리더보드에서 상위 10명의 플레이어를 가져온다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE leaderboard_feb_2021 0 9 WITHSCORES</span><br></pre></td></tr></table></figure>
<p>반환된 값은 다음과 같다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(user2,score2),(user1,score1),(user5,score5)...]</span><br></pre></td></tr></table></figure>
<ol>
<li>사용자 자신의 리더보드 순위를 가져온다.</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231225232800001.png" alt=""></p>
<p>순위표에서 사용자의 순위를 가져오기 위해 ZREVRANK를 호출해 순위표에서 사용자의 순위를 검색한다. 다시 말하지만, 높은 점수부터 낮은 점수까지 순위를 매겨야 하기 때문에 REV를 사용한다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANK leaderboard_feb_2021 &#x27;mary1934&#x27;</span><br></pre></td></tr></table></figure>
<ol>
<li>사용자의 순위표에서 상대적 위치를 가져온다.</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231225232858711.png" alt=""></p>
<p>명시적 요구 사항은 아니지만, 원하는 플레이어의 위 아래에 있는 결과의 수가 포함된 ZREVRANGE를 사용하면 사용자의 상대적인 위치를 쉽게 가져올 수 있따. 예를 들어 사용자 ‘Mallow007’의 순위가 361이고 그 위 아래에 있는 4명의 플레이어를 가져오고 싶다면 다음 명령을 사용한다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE leaderboard_feb_2021 357 365</span><br></pre></td></tr></table></figure>
<h5 id="Storage-requirement"><a href="#Storage-requirement" class="headerlink" title="Storage requirement"></a>Storage requirement</h5><p>최소한 사용자 ID와 점수는 저장해야 한다. 최악의 시나리오는 월간 활성 사용자 2,500만 명 모두가 최소 한 번 이상 게임에서 승리하고 모두 해당 월의 리더보드에 진입한 경우다. ID가 24자 문자열이고 점수가 16비트 정수라고 가정하면 리더보드 항목당 26바이트의 스토리지가 필요하다. MAU당 리더보드 항목이 하나라는 최악의 시나리오를 가정하면 26byte * 25 M = 650 M byte ~= 650 MB의 리더보드 스토리지가 Redis 캐시에 필요하다. 스킵 리스트의 오버헤드와 sorted set의 해시를 고려해 메모리 사용량을 두배로 늘린다고 가정해도 최신 Redis 서버 한 대면 데이터를 저장하기 충분하다.</p>
<p>고려해야 할 또 다른 관련 요소는 CPU 및 I/O 사용량이다. back-of-the-envelope 추정치의 피크 QPS는 초당 2500개의 업데이트다. 이는 단일 Redis 서버 성능 범위에 존재한다.</p>
<p>Redis 캐시의 한 가지 우려는 Redis 노드가 실패할 수 있기 때문에 지속성에 있다. 다행이도 Redis는 지속성을 지원하지만, 디스크에서 대규모 Redis 인스턴스를 다시 시작하는 것은 느리다. 일반적으로 Redis는 읽기 복제본으로 구성되며, 메인 인스턴스가 실패하면 읽기 복제본이 승경되고 새 읽기 복제본이 연결된다.</p>
<p>또한 MySQL과 같은 관계형 데이터베이스는 2개의 보조 테이블(user, point)을 필요로 한다. User 테이블에는 사용자 ID와 사용자의 이름이 저장된다. Point 테이블에는 게임에서 승리한 사용자 ID, 점수, 타임스탬프가 포함된다. 이 데이터는 플레이 기록과 같은 다른 게임 기능에 활용될 수 있으며, 인프라 장애 발생 시 Redis 리더보드를 다시 생성하는 데에도 사용될 수 있다.</p>
<p>작은 성능 최적화의 일환으로, 검색 빈도가 가장 높은 상위 10명의 플레이어를 위해 사용자 세부 정보의 추가 캐시를 생성하는 것이 좋을 수 있다. 그러나 이는 많은 양의 데이터에 해당하지는 않는다.</p>
<h2 id="Step-3-Design-Deep-Dive"><a href="#Step-3-Design-Deep-Dive" class="headerlink" title="Step 3 - Design Deep Dive"></a>Step 3 - Design Deep Dive</h2><p>개략적 설계에 대해 살펴봤으니 아래 사항에 대해 논의해보자.</p>
<ul>
<li>클라우드 프로바이더 사용 여부<ul>
<li>자체 서비스 관리</li>
<li>AWS와 같은 서비스 프로바이더 활용</li>
</ul>
</li>
<li>Redis 확장</li>
<li>NoSQL</li>
</ul>
<h4 id="To-use-a-cloud-provider-or-not"><a href="#To-use-a-cloud-provider-or-not" class="headerlink" title="To use a cloud provider or not"></a>To use a cloud provider or not</h4><p>기존 인프라에 따라 일반적으로 솔루션을 배포하는 데는 두 가지 옵션이 있다. 각각 살펴보자.</p>
<h5 id="Manage-our-own-services"><a href="#Manage-our-own-services" class="headerlink" title="Manage our own services"></a>Manage our own services</h5><p>이 접근 방식에서는 매월 리더보드 sorted set을 만들어 해당 기간의 리더보드 데이터를 저장한다. sorted set에는 회원 및 점수 정보가 저장된다. 이름과 프로필 이미지 등 사용자에 대한 나머지 세부 정보는 MySQL 데이터베이스에 저장된다. 순위표를 가져올 때 순위표 데이터 외에도 API 서버는 데이터베이스를 쿼리해 순위표에 표시할 해당 사용자의 이름과 프로필 이미지도 가져온다. 이 작업이 장기적으로 너무 비효율적이라면 사용자 프로필 캐시를 활용해 상위 10명의 플레이어에 대한 사용자 세부 정보를 저장할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231226165311808.png" alt=""></p>
<h5 id="Build-on-the-cloud"><a href="#Build-on-the-cloud" class="headerlink" title="Build on the cloud"></a>Build on the cloud</h5><p>두 번째 접근 방식은 클라우드 인프라를 활용하는 것이다. 이 섹션에는 기존 인프라가 AWS에 구축되어 있으므로 클라우드에 리더보드를 구축하는 것이 자연스럽다고 가정한다. 이 설계에는 두 가지 주요 AWS 기술인 Amazon API Gateway와 AWS Lambda를 사용할 것이다. Amazon API 게이트웨이는 RESTful API의 HTTP 엔드포인트를 정의하고 모든 백엔드 서비스에 연결할 수 있는 방법을 제공한다. 우리는 이를 사용해 AWS 람다에 연결한다. Restful API와 람다 함수 간의 매핑은 아래와 같다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>APIs</strong></th>
<th><strong>Lambda function</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>GET /v1/scores</td>
<td>LeaderboardFetchTop10</td>
</tr>
<tr>
<td>GET /v1/scores/{:user_id}</td>
<td>LeaderboardFetchPlayerRank</td>
</tr>
<tr>
<td>POST /v1/scores</td>
<td>LeaderboardUpdateScore</td>
</tr>
</tbody>
</table>
</div>
<p>AWS Lambda는 가장 인기있는 서버리스 컴퓨팅 플랫폼 중 하나다. 서버를 직접 프로비저닝 하거나 관리할 필요 없이 코드를 실행할 수 있다. 필요할 때만 실행되며 트래픽에 따라 자동으로 확장된다. 서버리스는 클라우드 서비스에서 가장 핫한 주제 중 하나이며 모든 주요 클라우드 서비스 제공업체에서 지원한다.</p>
<p>고수준에서 우리 게임은 Amazon API 게이트웨이를 호출하고, 이 게이트웨이는 적절한 람다 함수를 호출한다. AWS 람다 함수를 사용해 스토리지 계층(Redis와 MySQL 모두)에서 적절한 명령을 호출하고, 그 결과를 다시 API 게이트웨이로 반환한 다음 애플리케이션으로 반환한다.</p>
<p>서버 인스턴스를 스핀업하지 않고도 필요한 쿼리를 수행하기 위해 람다 함수를 활용할 수 있다. AWS는 람다 함수에서 호출할 수 있는 Redis 클라이언트에 대한 지원을 제공한다. 또한 DAU 증가와 같은 필요에 따라 자동 확장이 가능하다.</p>
<p><strong>Use case 1: scoring a point</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231226165726471.png" alt=""></p>
<p><strong>Use Case 2: retrieving leaderboard</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231226165738010.png" alt=""></p>
<p>람다의 장점은 서버리스 접근 방식이며, 인프라가 필요에 따라 기능을 자동 확장한다는 점이다. 즉 확장 및 환경 설정과 유지 관리를 관리할 필요가 없다. 이런 점을 고려할 때 게임을 처음부터 새로 구축하는 경우 서버리스 접근 방식을 사용하는 것이 좋다.</p>
<h4 id="Scaling-Redis"><a href="#Scaling-Redis" class="headerlink" title="Scaling Redis"></a>Scaling Redis</h4><p>DAU가 500만 명이라면 스토리지와 QPS 관점에서 Redis 캐시 하나면 충분하다. 하지만 원래 규모의 100배인 5억 DAU가 있다고 가정해보자. 이제 리더보드의 크기가 최악의 경우 65GB(650MB <em> 100)까지 올라가고, 초당 쿼리 수는 250,000(2,500 </em> 100)개 까지 올라간다. 따라서 샤딩 솔루션이 필요하다.</p>
<h5 id="Data-sharding"><a href="#Data-sharding" class="headerlink" title="Data sharding"></a>Data sharding</h5><p>샤딩은 고정 또는 해시 파티션의 두 가지 방식 중 하나를 고려한다.</p>
<p><strong>Fixed partition</strong></p>
<p>고정 파티션을 이해하는 한 가지 방법은 순위표의 전체 점수 범위를 살펴보는 것이다. 한 달 동안 획득한 포인트의 범위가 1에서 1,000까지이고 데이터를 범위별로 나눈다고 가정해 보자. 예를 들어, 아래와 같이 샤드가 10개이고 각 샤드의 점수 범위는 100점(1-100, 101-200, …)일 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231226170018914.png" alt=""></p>
<p>이 기능이 제대로 작동하려면 순위표 전체에 점수가 고르게 분포되어야 한다. 그렇지 않으면 각 샤드의 점수 범위를 조정해 비교적 고른 분포가 되도록 해야한다. 이 접근 방식에서는 애플리케이션 코드에서 데이터를 직접 샤딩한다.</p>
<p>사용자의 점수를 삽입하거나 업데이트할 때 사용자가 어느 샤드에 있는지 알아야 한다. 이를 위해 MySQL 데이터베이스에서 사용자의 현재 점수를 계산할 수 있다. 이 방법이 효과적일 수 있지만, 더 효율적인 옵션은 사용자 ID에서 점수로의 매핑을 저장하는 보조 캐시를 생성하는 것이다. 사용자가 점수를 높이고 샤드 간에 이동할 때는 주의해야 한다. 이 경우 현재 샤드에서 사용자를 제거하고 새 샤드로 이동해야 한다.</p>
<p>리더보드에서 상위 10명의 플레이어를 가져오려면 가장 높은 점수를 받은 샤드에서 상위 10명의 플레이어를 가져와야 한다. 사용자의 순위를 가져오려면 현재 샤드 내의 순위와 모든 샤드에서 점수가 높은 플레이어의 총 수를 계산해야 한다. 샤드 내 총 플레이어 수는 “info keysapce” 명령을 통해 O(1)로 검색할 수 있다.</p>
<h5 id="Hash-partition"><a href="#Hash-partition" class="headerlink" title="Hash partition"></a>Hash partition</h5><p>두 번째 접근 방식은 Redis 클러스터를 사용하는 것으로, 점수가 매우 클러스터링 되거나 뭉쳐있는 경우에 적합하다. Redis 클러스터는 여러 Redis 노드에 걸쳐 데이터를 자동으로 샤딩하는 방법을 제공한다. 일관된 해싱이 아니라 모든 키가 해시 슬롯의 일부인 다른 형태의 샤딩을 사용한다. 해시 슬롯은 16384개이며 <code>CRC16(key) % 16384</code>를 수행해 주어진 키의 해시 슬롯을 계산할 수 있다. 이를 통해 모든 키를 재분배하지 않고도 클러스터에서 노드를 쉽게 추가하고 제거할 수 있다. 아래 그림은 노드 분할의 예제이다.</p>
<ul>
<li>첫 번째 노드는 슬롯 [0, 5500]을 포함한다.</li>
<li>두 번재 노드는 슬롯 [5501, 11000]을 포함한다.</li>
<li>세 번째 노드는 슬롯 [11001, 16383]을 포함한다.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231226170617061.png" alt=""></p>
<p>업데이트는 해당 샤드에 있는 사용자의 점수를 변경하기만 하면 된다. 리더보드에서 상위 10명의 플레이어를 검색하는 것은 더욱 복잡하다. 각 샤드에서 상위 10명의 플레이어를 수집하고 애플리케이션이 데이터를 정렬하도록 해야한다. 이런 쿼리는 대기 시간을 줄이기 위해 병렬화할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231226170707127.png" alt=""></p>
<p>이 접근 방식에는 몇 가지 한계가 있다.</p>
<ul>
<li>리더보드에서 상위 K개의 결과를 반환해야 하는 경우, 각 샤드에서 많은 항목이 반환되고 정렬해야 하므로 지연 시간이 길어진다.</li>
<li>파티션이 많은 경우 쿼리가 가장 느린 파티션을 기다려야하기 때문에 지연 시간이 길어진다.</li>
<li>이 접근 방식의 또 다른 문제는 특정 사용자의 순위를 결정하는 간단한 솔루션을 제공하지 못한다는 것이다.</li>
</ul>
<p>따라서 우리는 첫 번째 솔루션인 고정 파티션을 선택한다.</p>
<h5 id="Sizing-a-Redis-node"><a href="#Sizing-a-Redis-node" class="headerlink" title="Sizing a Redis node"></a>Sizing a Redis node</h5><p>Redis 노드의 크기를 조정할 때 고려해야할 여러 사항이 있다. 쓰기 작업이 많은 애플리케이션은 장애 발생 시 스냅샷을 생성하기 위해 모든 쓰기를 수용할 수 있어야 하므로 더 많은 가용 메모리가 필요하다. 안전을 위해 쓰기 사용량이 많은 애플리케이션에는 메모리 용량을 두배로 할당한다.</p>
<p>Redis는 여러 클라이언트가 여러 쿼리를 실행하는 것을 시뮬레이션하고 주어진 하드웨어에 대한 초당 요청 수를 반환해 Redis 설정 성능의 벤치마킹에 도움을 주는 Redis-benchmark 라는 도구를 제공한다. </p>
<h4 id="Alternative-solution-NoSQL"><a href="#Alternative-solution-NoSQL" class="headerlink" title="Alternative solution: NoSQL"></a>Alternative solution: NoSQL</h4><p>고려할 수 있는 대안 솔루션은 NoSQL 데이터베이스다. 다음과 같은 속성을 가진 NoSQL이 선호된다.</p>
<ul>
<li>동일한 파티션 내의 항목을 점수별로 효율적으로 정렬</li>
<li>쓰기에 최적화됨</li>
</ul>
<p>Amazon의 DynamoDB, Cassandra 또는 MongoDB와 같은 NoSQL 데이터베이스가 적합할 수 있다. 이 포스트에서는 DynamoDB를 예로 든다. 다이나모DB는 안정적인 성능과 뛰어난 확장성을 제공하는 NoSQL 데이터베이스다. 기본 키 이외의 속성을 가진 데이터에 효율적으로 엑세스할 수 있도록 하기 위해 다이나모DB에서 글로벌 보조 인덱스를 활용할 수 있다. 글로벌 보조 인덱스는 상위 테이블의 일부 속성을 포함하지만 다른 기본 키를 사용해 구성된다. 예시를 살펴보자.</p>
<p>업데이트된 시스템 다이어그램은 아래 나와있다. Redis와 MySQL이 DynamoDB로 대체되었다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231226171348350.png" alt=""></p>
<p>체스 게임의 순위표를 디자인하고 초기 테이블이 아래 표시되어 있다고 가정해보자.</p>
<p>이는 순위표와 사용자 테이블의 비정규화된 뷰이며 순위표를 렌더링하는 데 필요한 모든것을 포함하고 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231226171427302.png" alt=""></p>
<p>이 테이블 구성표는 작동하지만 확장성이 좋지 않다. 더 많은 행이 추가되면 상위 점수를 찾기 위해 전체 테이블을 스캔해야 한다. 선형 스캔을 피하려면 인덱스를 추가해야 한다. 첫 번째 시도는 아래와 같이 “game_name#{year-month}”을 파티션 키로, 점수를 정렬 키로 사용하는 것이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231226171516940.png" alt=""></p>
<p>이 방법은 효과가 있지만 부하가 높을 때 문제가 발생한다. 다이나모DB는 일관된 해싱을 사용해 여러 노드에 데이터를 분할한다. 각 항목은 파티션 키에 따라 해당 노드에 존재한다. 데이터가 파티션 간에 고르게 분산되도록 데이터를 구조화하고자 한다. 테이블 설계에서는 최근 한 달 동안 모든 데이터가 한 파티션에 저장되고 해당 파티션이 핫 파티션이 된다. 이 문제를 어떻게 해결할 수 있을까?</p>
<p>데이터를 N개의 파티션으로 분할하고 파티션 키에 파티션 번호(user_id % number_of_partitons)를 추가하면 된다. 이 패턴을 write sharding이라고 한다. 쓰기 샤딩은 읽기 및 쓰기 작업 모두에 복잡성을 더하므로 장단점을 신중히 고려해야 한다.</p>
<p>두 번째 질문은 얼마나 많은 파티션을 만들어야 할까? 이는 쓰기 볼륨 또는 DAU를 기준으로 할 수 있다. 기억해야 할 중요한 점은 파티션의 부하와 읽기 복잡성 사이에는 절충점이 있다는 것이다. 같은 달의 데이터는 여러 파티션에 고르게 분산되어 있기 때문에 단일 파티션의 부하가 훨씬 가볍다. 그러나 특정 월의 항목을 읽으려면 모든 파티션을 쿼리하고 결과를 병합해야 하므로 읽기 복잡성이 증가한다.</p>
<p>업데이트 된 파티션 키와 스키마 테이블은 다음과 같다. <code>game_name#&#123;year-month&#125;#p&#123;partition_number&#125;</code>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231226171841386.png" alt=""></p>
<p>글로벌 보조 인덱스는 <code>game_name#&#123;year-month&#125;#p&#123;partition_number&#125;</code>를 파티션 키로, 점수를 정렬 키로 사용한다. 결국에는 모두 자체 파티션 내에서 정렬된 N개의 파티션이 생성된다. 파티션이 3개라고 가정하면 상위 10개 순위표를 가져오기 위해 앞서 언급한 “분산 수집”이라는 접근 방식을 사용한다. 각 파티션에서 상위 10개의 결과를 가져온 다음 애플리케이션이 모든 파티션에서 결과를 정렬할 수 있도록 한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231226172002917.png" alt=""></p>
<p>파티션 수는 어떻게 결정해야 할까? 이를 위해선 신중한 벤치마킹이 필요할 수 있다. 파티션이 많으면 각 파티션의 부하가 줄어들지만 최종 순위표를 작성하기 위해 더 많은 파티션에 분산시켜야 하므로 복잡성이 증가한다. 벤치마킹을 활용하면 장단점을 보다 명확히 파악할 수 있다.</p>
<p>하지만 앞서 언급한 Redis 파티션 솔루션과 같이 이 접근 방식은 사용자의 상대적 순위를 결정하는 간단한 솔루션을 제공하지 않는다. 하지만 사용자 위치의 백분위 수를 구하는 것은 가능하다. 이는 충분히 좋은 방법일 수 있다. 실제 상황에서 플레이어가 상위 10~20%에 속한다고 말하는 것이 1,200,001과 같은 정확한 순위를 표시하는 것보다 더 나을 수 있다. 따라서 규모가 충분히 커서 샤딩이 필요한 경우, 모든 샤드에서 점수 분포가 거의 동일하다고 가정할 수 있다. 이 가정이 사실이라면, 각 샤드에 대한 점수 분포를 분석하고 그 결과를 캐싱하는 크론 작업이 있을 수 있다.</p>
<p>결과는 다음과 같다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10th percentile = score &lt; 100</span><br><span class="line">20th percentile = score &lt; 500</span><br><span class="line">...</span><br><span class="line">90th percentile = score &lt; 6500</span><br></pre></td></tr></table></figure>
<p>그러면 사용자의 상대적 백분위 순위를 빠르게 구할 수 있다.</p>
<h3 id="Step-4-Wrap-Up"><a href="#Step-4-Wrap-Up" class="headerlink" title="Step 4 - Wrap Up"></a>Step 4 - Wrap Up</h3><p>이 포스트에선 수백만 DAU 규모의 실시간 게임 리더보드 구축을 위한 솔루션을 살펴봤다. MySQL 데이터베이스를 사용하는 간단한 솔루션을 검토했지만 수백만 명의 사용자로 확장할 수 없기 때문에 이 접근 방식을 거부했다. 그 다음 Redis sorted set을 사용해 리더보드를 설계했다. 또한 여러 Redis 캐시에서 샤딩을 활용해 솔루션을 5억 DAU까지 확장하는 방안도 검토했다. 또한 대체 NoSQL 솔루션도 제안했다.</p>
<p>아래는 다뤄볼만한 다른 주제들이다.</p>
<p><strong>Faster retrieval and breaking tie</strong></p>
<p>Redis 해시는 문자열 필드와 값 사이의 map을 제공한다. 두 가지 사용 사례에 해시를 활용할 수 있다.</p>
<ul>
<li>리더보드에 표시할 수 있는 사용자 오브젝트에 대한 사용자 ID map을 저장하는 경우. 이렇게 하면 사용자 오브젝트를 가져오기 위해 데이터베이스로 이동하는 것보다 더 빠르게 검색할 수 있다.</li>
<li>두 명의 플레이어가 동일한 점수를 받은 경우, 누가 먼저 점수를 받았는지에 따라 사용자 순위를 매길 수 있다. 사용자의 점수를 증가시킬 때 가장 최근에 이긴 게임의 타임스탬프에 사용자 ID의 map을 저장할 수 있다. 동점일 경우 타임스탬프가 오래된 사용자가 더 높은 순위를 차지한다.</li>
</ul>
<p><strong>System failure recovery</strong></p>
<p>Redis 클러스터는 잠재적으로 대규모 장애를 경험할 수 있다. 위의 설계를 고려할 때 사용자가 게임에서 이길 때마다 MySQL 데이터베이스가 타임스탬프가 있는 항목을 기록한다는 사실을 활용하는 스크립트를 만들 수 있다. 각 사용자에 대한 모든 항목을 반복하고 사용자별로 항목당 한 번씩 ZINCRBY를 호출할 수 있다. 이렇게 하면 대규모 장애가 발생했을 때 필요한 경우 오프라인에서 리더보드를 다시 만들 수 있다.</p>
<h2 id="Chapter-Summary"><a href="#Chapter-Summary" class="headerlink" title="Chapter Summary"></a>Chapter Summary</h2><p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231226172625558.png" alt=""></p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2023/12/25/System%20Design/ByteByteGo/book/real-time-gaming-leaderboard/">https://songhayoung.github.io/2023/12/25/System%20Design/ByteByteGo/book/real-time-gaming-leaderboard/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2024 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>