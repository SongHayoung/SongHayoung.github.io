<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[ByteByteGo] How to Choose a Replication Strategy"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[ByteByteGo] How to Choose a Replication Strategy | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#How-to-Choose-a-Replication-Strategy"><span class="toc-number">1.</span> <span class="toc-text">How to Choose a Replication Strategy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Multi-Leader-Replication"><span class="toc-number">2.</span> <span class="toc-text">Multi-Leader Replication</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Managing-Conflict"><span class="toc-number">2.1.</span> <span class="toc-text">Managing Conflict</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Last-Write-Wins"><span class="toc-number">2.1.1.</span> <span class="toc-text">Last Write Wins</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Conflict-free-Replicated-Data-Types-CRDTs"><span class="toc-number">2.1.2.</span> <span class="toc-text">Conflict-free Replicated Data Types (CRDTs)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Operational-Transformation"><span class="toc-number">2.1.3.</span> <span class="toc-text">Operational Transformation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Application-specific-Resolution"><span class="toc-number">2.1.4.</span> <span class="toc-text">Application-specific Resolution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Partitioning"><span class="toc-number">2.2.</span> <span class="toc-text">Data Partitioning</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Replication-Lag-and-Inconsistent-Reads"><span class="toc-number">2.3.</span> <span class="toc-text">Replication Lag and Inconsistent Reads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Use-Cases"><span class="toc-number">2.4.</span> <span class="toc-text">Use Cases</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tradeoffs-and-Challenges"><span class="toc-number">2.5.</span> <span class="toc-text">Tradeoffs and Challenges</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Leaderless-Replication"><span class="toc-number">3.</span> <span class="toc-text">Leaderless Replication</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Quorum-Writes-and-Reads"><span class="toc-number">3.1.</span> <span class="toc-text">Quorum Writes and Reads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Benefits-and-Drawbacks"><span class="toc-number">3.2.</span> <span class="toc-text">Benefits and Drawbacks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Conflict-Resolution-Strategies"><span class="toc-number">3.3.</span> <span class="toc-text">Conflict Resolution Strategies</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Choosing-a-Replication-Strategy"><span class="toc-number">4.</span> <span class="toc-text">Choosing a Replication Strategy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#System-Size-and-Complexity"><span class="toc-number">4.1.</span> <span class="toc-text">System Size and Complexity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Consistency-Needs"><span class="toc-number">4.2.</span> <span class="toc-text">Consistency Needs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Geographic-Distribution"><span class="toc-number">4.3.</span> <span class="toc-text">Geographic Distribution</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Read-Write-Workloads"><span class="toc-number">4.4.</span> <span class="toc-text">Read&#x2F;Write Workloads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Replication-Factor"><span class="toc-number">4.5.</span> <span class="toc-text">Replication Factor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Replication-Strategy-Examples"><span class="toc-number">4.6.</span> <span class="toc-text">Replication Strategy Examples</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Online-Retail-Application"><span class="toc-number">4.6.1.</span> <span class="toc-text">Online Retail Application</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gaming-Application"><span class="toc-number">4.6.2.</span> <span class="toc-text">Gaming Application</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ride-Sharing-Application"><span class="toc-number">4.6.3.</span> <span class="toc-text">Ride Sharing Application</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">5.</span> <span class="toc-text">Conclusion</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.instagram.com/hayoung0_0/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">9162</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">191</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">60</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[ByteByteGo] How to Choose a Replication Strategy</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-09-08</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/Byte-Byte-Go/">Byte Byte Go</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1.6k</span><span class="post-meta__separator">|</span><span>Reading time: 9 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="How-to-Choose-a-Replication-Strategy"><a href="#How-to-Choose-a-Replication-Strategy" class="headerlink" title="How to Choose a Replication Strategy"></a>How to Choose a Replication Strategy</h2><span id="more"></span>
<p>이번 포스트에서는 multi-leader와 leaderless 복제라는 두 가지 접근 방식을 살펴본다. 두 가지 설계를 대조하고, 작동 방식을 자세히 살펴본다. 마지막으로 핵심 복제 모델과 시스템 요구 사항 및 제약 조건에 따라 올바른 전략을 선택하는 방법을 알아본다.</p>
<h2 id="Multi-Leader-Replication"><a href="#Multi-Leader-Replication" class="headerlink" title="Multi-Leader Replication"></a>Multi-Leader Replication</h2><p>Leader-Leader 복제라고도 하는 다중 리더 복제는 각각 쓰기 요청을 수신하고 처리할 수 있는 여러 개의 기본 노드를 사용하는 방식이다. 이런 리더는 서로 간에 데이터를 복제하여 최신 상태를 유지한다. 각 리더에는 읽기 확장을 위한 팔로워 복제본도 있을 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230908212623256.png" alt=""></p>
<p>이 모델에서 가장 큰 장점은 쓰기 가용성이 향상된다는 점이다. 액티브 리더가 여러명일 경우, 한 노드에 장애가 발생해도 다른 리더가 쓰기 요청을 계속 처리하므로 쓰기가 중단되지 않는다. 이는 실패한 리더가 새 리더를 구할 때까지 쓰기를 중단하는 리더-팔로워 설계를 개선한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230908212723293.png" alt=""></p>
<p>하지만 멀티리더 복제에는 여러 가지 어려움이 따른다. 예를 들어, 여러 명의 리더가 쓰기 요청을 처리하는 경우 리더가 동시에 동일한 데이터를 수정할 때 충돌하는 변경 사항이 발생할 수 있다.</p>
<h3 id="Managing-Conflict"><a href="#Managing-Conflict" class="headerlink" title="Managing Conflict"></a>Managing Conflict</h3><p>여러 리더가 동시에 쓰기 작업을 수행할 수 있는 다중 리더 복제 모델에서 충돌은 자연스러운 결과다. 효과적인 충돌 관리는 복잡한 작업이지만 데이터 일관성과 무결성을 보장하는데 매우 중요하다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230908212844322.png" alt=""></p>
<p>아래는 일반적으로 사용되는 몇 가지 충돌 해결 전략이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230908212909257.png" alt=""></p>
<h4 id="Last-Write-Wins"><a href="#Last-Write-Wins" class="headerlink" title="Last Write Wins"></a>Last Write Wins</h4><p>이 방법은 가장 최근 변경 사항이 우선 적용되는 간단한 방법이다. 구현하기는 쉽지만 중요한 업데이트가 삭제될 위험이 있다.</p>
<h4 id="Conflict-free-Replicated-Data-Types-CRDTs"><a href="#Conflict-free-Replicated-Data-Types-CRDTs" class="headerlink" title="Conflict-free Replicated Data Types (CRDTs)"></a>Conflict-free Replicated Data Types (CRDTs)</h4><p>CRDT를 사용하면 충돌하는 변경 사항을 병합하여 원활하게 조정할 수 있다. CRDT는 카운터, 집합, 목록과 같은 다양한 종류의 데이터에 대해 다양한 유형으로 제공되며, 별도의 충돌 해결 프로세스 없이 자동으로 충돌을 해결한다.</p>
<h4 id="Operational-Transformation"><a href="#Operational-Transformation" class="headerlink" title="Operational Transformation"></a>Operational Transformation</h4><p>운영 변환은 실시간 협업 애플리케이션에서 자주 사용된다. 데이터 상태뿐만 아니라 작업 자체를 고려한다. 이 방법은 구현하기는 복잡하지만 세밀한 제어가 가능하다.</p>
<h4 id="Application-specific-Resolution"><a href="#Application-specific-Resolution" class="headerlink" title="Application-specific Resolution"></a>Application-specific Resolution</h4><p>경우에 따라 충돌 해결 로직을 애플리케이션 레벨로 푸시할 수 있다. 애플리케이션은 도메인별 규칙을 사용하거나 충돌 해결을 위해 사람의 개입을 포함할 수 있다.</p>
<h3 id="Data-Partitioning"><a href="#Data-Partitioning" class="headerlink" title="Data Partitioning"></a>Data Partitioning</h3><p>또 다른 대안은 충돌하는 변경 사항을 최소화하기 위해 여러 리더에 걸쳐 데이터를 분할하는 것이다. 하지만 파티션 간 트랜잭션을 구현하려면 세심한 조정이 필요하며, 사용량이 많은 데이터 파티션의 잠재적인 핫스팟을 효과적으로 관리해야 한다. 이 전략은 클러스터 전반의 전체 쓰기 처리량을 줄일 수 있다는 점에 주목할 필요가 있다.</p>
<h3 id="Replication-Lag-and-Inconsistent-Reads"><a href="#Replication-Lag-and-Inconsistent-Reads" class="headerlink" title="Replication Lag and Inconsistent Reads"></a>Replication Lag and Inconsistent Reads</h3><p>리더-팔로워 복제와 마찬가지로 다중 리더 시스템은 복제 지연과 일관성 없는 읽기에 취약하다. 업데이트가 완전히 전파될 때까지 리더 간에 일시적인 불일치가 발생할 수 있다. 애플리케이션은 이를 염두에 두고 설계해야 한다.</p>
<h3 id="Use-Cases"><a href="#Use-Cases" class="headerlink" title="Use Cases"></a>Use Cases</h3><p>전세계에 사용자가 있는 애플리케이션의 경우, 다중 리더 복제를 사용하면 최종 사용자가 가까운 리더 노드와 상호작용할 수 있어 지연 시간을 줄일 수 있다. 금융 거래 플랫폼과 같이 다운타임을 감당할 수 없는 시스템은 여러 리더를 두는 것이 유리할 수 있다. 한 노드가 다운되더라도 운영은 계속된다.</p>
<p>쓰기 부하가 많은 애플리케이션의 경우 쓰기 작업을 여러 리더 노드에 분산하면 단일 노드가 병목 현상을 일으키는 것을 방지할 수 있다.</p>
<h3 id="Tradeoffs-and-Challenges"><a href="#Tradeoffs-and-Challenges" class="headerlink" title="Tradeoffs and Challenges"></a>Tradeoffs and Challenges</h3><p>기본적으로 다중 리더 복제는 높은 쓰기 가용성, 내결함성, 전세계에 분산된 데이터 접근성을 우선시하는 애플리케이션에 특히 유용하다. 많은 최신 데이터베이스가 이 복제 전략을 기본으로 또는 확장 기능을 통해 다양한 수준의 성공을 거두며 활용할 수 있다.</p>
<p>다중 리더 복제는 고가용성을 제공하지만 합의, 충돌 감지 및 해결 메커니즘에 대한 신중한 설계가 필요하다. 잘 구현하면 쓰기 처리량과 가용성을 극대화하는 강력한 접근 방식이 될 수 있다.</p>
<h2 id="Leaderless-Replication"><a href="#Leaderless-Replication" class="headerlink" title="Leaderless Replication"></a>Leaderless Replication</h2><p>리더리스 복제는 쿼럼 기반 접근 방식을 취한다. 리더 없는 시스템에서는 네트워크의 모든 노드가 쓰기 작업을 수락할 수 있는 권한을 갖는다. 단일 리더가 없다는 것은 시스템의 역학을 근본적으로 변화시킨다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230908213730512.png" alt=""></p>
<h3 id="Quorum-Writes-and-Reads"><a href="#Quorum-Writes-and-Reads" class="headerlink" title="Quorum Writes and Reads"></a>Quorum Writes and Reads</h3><p>이제 리더리스 복제를 뒷받침하는 핵심 개념인 ‘쿼럼 쓰기 및 읽기’ 부터 알아보자. 리더가 없는 시스템에서는 읽기 또는 쓰기 작업의 유효성을 검사하기 위해 단일 노드에 의존하지 않는다. 대신 특정 수의 노드 간의 합의를 목표로 한다. 이 숫자를 “쿼럼”이라고 한다. 쿼럼 접근 방식을 사용하면 모든 노드에서 완전한 합의가 필요하지 않으므로 고가용성과 데이터 정확성의 균형을 맞출 수 있다.</p>
<p>이 시스템에서는 세 가지 중요한 값을 사용한다.</p>
<ul>
<li>n은 시스템의 총 노드 수다.</li>
<li>쓰기 쿼럼인 w는 쓰기가 성공한것으로 간주되기 위해 동의해야 하는 최소 노드 수다.</li>
<li>읽기 쿼럼인 r은 읽기가 유효하기 위해 동의해야 하는 최소 노드 수다.</li>
</ul>
<p>강력한 일관성을 위해 일반적인 가이드라인은 w + r &gt; n이다. 이는 모든 읽기가 모든 쓰기와 겹치지 않도록 보장하고 가장 최근 값을 반환한다.</p>
<p>예를 들어 노드가 3개인 시스템(n=3)을 가정해보자. w를 2로 구성하면 쓰기 요청이 성공한 것으로 간주되기 전에 3개의 노드 중 2개의 노드가 이를 승인해야 한다는 뜻이다. 노드 중 하나가 다운되더라도 쓰기 작업은 계속될 수 있다. 이 아이디어는 읽기에서도 유사하게 작동한다. r이 2로 설정되어 있으면 읽기 작업은 2개의 노드를 쿼리하여 두 노드 사이의 가장 최근 데이터를 반환한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230908214053995.png" alt=""></p>
<p>w + r이 n에 가까울수록 최신 데이터를 읽을 확률이 높아진다. 극단적인 경우, r = n이면 모든 노드가 올바른 값에 동의하는데 시간이 걸릴 수 있지만 최신 데이터를 읽을 수 있다. 다른 극단적인 경우, w = n이면 r이 무엇이든 항상 최신 값을 읽는다. 물론 w값이 높으면 모든 노드가 데이터를 승인할 때까지 기다려야 하므로 쓰기 작업 속도가 느려진다.</p>
<h3 id="Benefits-and-Drawbacks"><a href="#Benefits-and-Drawbacks" class="headerlink" title="Benefits and Drawbacks"></a>Benefits and Drawbacks</h3><p>리더리스 복제는 여러 가지 장점을 제공하는데, 가장 큰 장점은 가용성이다. 잠재적인 장애 지점 역할을 하는 단일 리더가 없기 때문에 시스템은 개별 노드 장애를 큰 영향 없이 견딜 수 있다. 또한 구현 및 유지 관리가 복잡할 수 있는 복잡한 리더 선출 절차의 필요성을 피할 수 있다.</p>
<p>하지만 모든 시스템이 그렇듯 리더리스 복제 역시 완벽하지는 않다. 리더리스 복제는 충돌 해결이라는 중요한 과제를 가진다. 신뢰할 수 있는 단일 소스가 없는 경우, 여러 노드가 동일한 데이터의 서로 다른 버전을 보유하게 될 수 있다. 이런 불일치는 어떤 버전을 유지해야 하는지에 대한 의문을 제기한다.</p>
<h3 id="Conflict-Resolution-Strategies"><a href="#Conflict-Resolution-Strategies" class="headerlink" title="Conflict Resolution Strategies"></a>Conflict Resolution Strategies</h3><p>다행히도 이런 충돌을 처리할 수 있는 몇 가지 전략이 있다. 한 가지 방법은 타임스탬프 또는 버전 번호를 사용하는 것이다. 이 방법에서는 타임스탬프가 가장 최근이거나 버전 번호가 가장 높은 데이터가 진실로 간주된다. 또 다른 방법은 애플리케이션별 로직을 사용하는 것이다. 이 전략은 충돌이 발생할 때 어떤 버전이 올바른지 결정하는 규칙을 애플리케이션 내에 설정하는 것이다. 예를 들어 특정 필드에 대해 숫자 값이 더 높은 버전을 유지하는 규칙을 설정할 수 있다.</p>
<p>리더리스 복제가 실제로 작동하는 것을 보려면 Apache Cassandra와 같은 시스템을 살펴볼 수 있다. Cassandra는 쿼럼 기반 접근 방식을 사용하는데, 읽기 및 쓰기 모두 노드 전체에 걸쳐 승인 쿼럼이 필요하다. 쓰기는 모든 복제 노드로 전송되는 반면, 읽기는 읽기 쿼럼을 충족할 만큼의 노드만 쿼리한다. 타임스탬프는 충돌 해결에 사용된다. 이러한 설계 덕분에 Cassandra는 리더 없이도 고가용성을 제공할 수 있다. 또한 쿼럼 설정에 따라 최종적인 일관성 수준부터 강력한 수준까지 조정할 수 있다. 일반적으로 리더가 없지만 Cassandra는 경량 트랜잭션과 같은 특정 기능에 대해 리더 기반 접근 방식을 사용한다.</p>
<h2 id="Choosing-a-Replication-Strategy"><a href="#Choosing-a-Replication-Strategy" class="headerlink" title="Choosing a Replication Strategy"></a>Choosing a Replication Strategy</h2><p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230908225916894.png" alt=""></p>
<p>복제 전략을 선택할 때는 몇 가지 주요 요소를 평가해야 한다. 최적의 접근 방식은 특정 시스템 아키텍처와 애플리케이션 요구 사항에 따라 달라진다.</p>
<h3 id="System-Size-and-Complexity"><a href="#System-Size-and-Complexity" class="headerlink" title="System Size and Complexity"></a>System Size and Complexity</h3><p>시스템의 크기와 복잡성은 중요한 요소다. 시스템이 크고 복잡하면 복제가 더 어려워진다. 동기식 복제는 노드 간에 대량의 데이터를 복사할 때 응답 시간을 느리게 할 수 있다. 더 작고 단순한 시스템에서는 이러한 문제가 발생하지 않을 수 있다. 복잡한 데이터 구조는 충돌 해결에도 문제를 일으킨다. 일부 복제 전략은 다른 복제 전략보다 복잡성을 더 잘 처리한다. 또한 더 복잡한 시스템일수록 더 복잡한 모니터링 및 충돌 해결 메커니즘이 필요할 수 있다.</p>
<h3 id="Consistency-Needs"><a href="#Consistency-Needs" class="headerlink" title="Consistency Needs"></a>Consistency Needs</h3><p>애플리케이션에 어느 정도의 일관성이 필요할까? 강력한 일관성이 요구되는 애플리케이션은 복제본이 동기화되도록 하기 위해 동기 복제가 필요할 수 있다. 하지만 이는 성능과 가용성에 영향을 미친다. 약간의 불일치를 허용하는 애플리케이션은 비동기 복제를 사용하여 복제본 지연에도 불구하고 응답 시간 및 가용성을 개선할 수 있다.</p>
<h3 id="Geographic-Distribution"><a href="#Geographic-Distribution" class="headerlink" title="Geographic Distribution"></a>Geographic Distribution</h3><p>지리적 분포와 네트워크 지연 시간에 미치는 영향을 고려해야 한다. 여러 지역에 걸쳐 있는 시스템은 동기식 복제의 지연 시간 요구 사항으로 인해 어려움을 겪는다. 리더리스 및 멀티리더 복제는 글로벌 배포에서 네트워크 지연을 더 잘 견뎌낸다. 분산된 인프라에도 불구하고 가용성을 극대화한다. 또한 국경을 넘나드는 데이터 복제에는 서로 다른 데이터 보호 규정이 적용될 수 있다는 점에 유의해야 한다.</p>
<h3 id="Read-Write-Workloads"><a href="#Read-Write-Workloads" class="headerlink" title="Read/Write Workloads"></a>Read/Write Workloads</h3><p>워크로드 특성이 복제 선택에 영향을 미친다. 읽기가 많은 시스템은 리더-팔로워 복제에 적합하다. 읽기 요청을 팔로워 복제본에 분산하여 부하를 분산하고 응답 시간을 개선할 수 있다. 쓰기 중심 시스템에는 쓰기가 병렬화된 멀티리더 또는 리더리스 복제가 더 적합하다.</p>
<h3 id="Replication-Factor"><a href="#Replication-Factor" class="headerlink" title="Replication Factor"></a>Replication Factor</h3><p>복제 계수는 비용과 내구성의 균형을 유지한다. 복제 계수가 높을수록 더 많은 복제본을 통해 복원력이 향상되지만 스토리지 및 관리 오버헤드도 증가한다. 특정 시스템 요구 사항에 따라 최적의 인수는 달라질 수 있지만, 일반적으로 3의 인수가 과도한 오버헤드 없이 우수한 가용성을 제공하는데 적합하다.</p>
<p>완벽한 선택은 없으며, 각각의 고유한 시스템 아키텍처와 애플리케이션에 따라 더 나은 절충안을 찾을 수 있을 뿐이다. </p>
<h3 id="Replication-Strategy-Examples"><a href="#Replication-Strategy-Examples" class="headerlink" title="Replication Strategy Examples"></a>Replication Strategy Examples</h3><h4 id="Online-Retail-Application"><a href="#Online-Retail-Application" class="headerlink" title="Online Retail Application"></a>Online Retail Application</h4><ul>
<li>방대한 제품 카탈로그로 인해 데이터베이스가 크고 복잡해짐</li>
<li>주문 처리를 위한 강력한 일관성 필요</li>
<li>여러 지역에 배포</li>
<li>제품 검색을 위한 읽기 작업이 대부분</li>
</ul>
<p>권장 전략은 리더-팔로워 복제를 통해 대용량 데이터를 처리하고, 강력한 일관성을 보장하며, 여러 지역에 걸쳐 읽기를 분산시킨다.</p>
<h4 id="Gaming-Application"><a href="#Gaming-Application" class="headerlink" title="Gaming Application"></a>Gaming Application</h4><ul>
<li>플레이어 데이터는 비교적 간단함</li>
<li>우수한 게임플레이를 위해 지연시간에 매우 민감함</li>
<li>게임 상태 업데이트를 위해 읽기 및 쓰기량이 많음</li>
<li>짧은 지연 시간을 위해 지역 내에서 동작</li>
</ul>
<p>권장 전략은 단일 리전에서 빠른 읽기/쓰기를 위한 멀티 리더 복제다.</p>
<h4 id="Ride-Sharing-Application"><a href="#Ride-Sharing-Application" class="headerlink" title="Ride Sharing Application"></a>Ride Sharing Application</h4><ul>
<li>중간 수준의 복잡성 데이터</li>
<li>고가용성을 위해 궁극적인 일관성이 필요함</li>
<li>트립 업데이트를 위한 쓰기 작업량이 많은 워크로드</li>
<li>비용에 민감한 인프라</li>
</ul>
<p>권장 전략은 효율적인 쓰기를 위한 리더리스 복제다. 충돌 해결은 낮은 인프라 비용으로 최종적인 일관성을 제공한다.</p>
<p>애플리케이션 요구사항에 따라 시스템 특성을 평가하면 성능, 확장성, 안정성에 최적화된 복제 전략을 수립할 수 있다. 완벽한 선택은 없으며, 각각의 고유한 아키텍처와 애플리케이션에 대해 더 나은 절충안을 찾을 수 있을 뿐이다. 비즈니스 요구사항이나 확장이 변경되면 선택한 복제 전략을 다시 평가해야 할 수도 있다는 점을 기억해야 한다.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>복제는 견고하고 가용성이 높은 분산 시스템을 구축하는데 중요한 기술이다. 이 포스트에서는 널리 사용되는 복제 전략과 장단점을 살펴봤다. 리더-팔로워 복제는 강력한 일관성을 제공하지만 단일 장애 지점을 나타낸다. 멀티 리더는 쓰기 가용성을 향상시키지만 복잡성을 초래한다. 리더리스 복제는 리더를 완전히 제거하여 가용성을 우선시한다.</p>
<p>보편적으로 이상적인 복제 전략은 없다. 최선의 접근 방식은 일관성 요구사항, 인프라 비용, 워크로드 패턴과 같은 요소에 따라 달라진다. 유능한 시스템 설계자는 이러한 장단점을 이해하고 애플리케이션 요구 사항과 비즈니스 요구사항에 맞는 전략을 선택해야 한다.</p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2023/09/08/System%20Design/ByteByteGo/private/how-to-choose-a-replication-strategy/">https://songhayoung.github.io/2023/09/08/System%20Design/ByteByteGo/private/how-to-choose-a-replication-strategy/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2023 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>