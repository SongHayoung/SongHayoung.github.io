<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[System Design] Stock Exchange"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[System Design] Stock Exchange | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Stock-Exchange"><span class="toc-number">1.</span> <span class="toc-text">Stock Exchange</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-1-Understand-the-Problem-and-Establish-Design-scope"><span class="toc-number">2.</span> <span class="toc-text">Step 1 - Understand the Problem and Establish Design scope</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Non-functional-requirements"><span class="toc-number">2.1.</span> <span class="toc-text">Non-functional requirements</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Back-of-the-envelope-estimation"><span class="toc-number">2.1.1.</span> <span class="toc-text">Back-of-the-envelope estimation</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-2-Propose-High-Level-Design-and-Get-Buy-In"><span class="toc-number">3.</span> <span class="toc-text">Step 2 - Propose High-Level Design and Get Buy-In</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Business-Knowledge-101"><span class="toc-number">3.1.</span> <span class="toc-text">Business Knowledge 101</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#High-level-design"><span class="toc-number">3.2.</span> <span class="toc-text">High-level design</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Trading-flow"><span class="toc-number">3.2.1.</span> <span class="toc-text">Trading flow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Market-data-flow"><span class="toc-number">3.2.2.</span> <span class="toc-text">Market data flow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reporting-flow"><span class="toc-number">3.2.3.</span> <span class="toc-text">Reporting flow</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-Design"><span class="toc-number">3.3.</span> <span class="toc-text">API Design</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-models"><span class="toc-number">3.4.</span> <span class="toc-text">Data models</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Product-order-execution"><span class="toc-number">3.4.1.</span> <span class="toc-text">Product, order, execution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Order-book"><span class="toc-number">3.4.2.</span> <span class="toc-text">Order book</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Candlestick-chart"><span class="toc-number">3.4.3.</span> <span class="toc-text">Candlestick chart</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-3-Design-Deep-Dive"><span class="toc-number">4.</span> <span class="toc-text">Step 3 - Design Deep Dive</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Performance"><span class="toc-number">4.1.</span> <span class="toc-text">Performance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event-sourcing"><span class="toc-number">4.2.</span> <span class="toc-text">Event sourcing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#High-availability"><span class="toc-number">4.3.</span> <span class="toc-text">High availability</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fault-tolerance"><span class="toc-number">4.4.</span> <span class="toc-text">Fault tolerance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Matching-algorithms"><span class="toc-number">4.5.</span> <span class="toc-text">Matching algorithms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Determinism"><span class="toc-number">4.6.</span> <span class="toc-text">Determinism</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Market-data-publisher-optimizations"><span class="toc-number">4.7.</span> <span class="toc-text">Market data publisher optimizations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Distribution-fairness-of-market-data"><span class="toc-number">4.8.</span> <span class="toc-text">Distribution fairness of market data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multicast"><span class="toc-number">4.9.</span> <span class="toc-text">Multicast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Colocation"><span class="toc-number">4.10.</span> <span class="toc-text">Colocation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Network-security"><span class="toc-number">4.11.</span> <span class="toc-text">Network security</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wrap-Up"><span class="toc-number">5.</span> <span class="toc-text">Wrap Up</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-Summary"><span class="toc-number">6.</span> <span class="toc-text">Chapter Summary</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/hayoung-song-9523b61bb/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">10832</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">193</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">61</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[System Design] Stock Exchange</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-01-08</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/System-Design-Interview/">System Design Interview</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">5.6k</span><span class="post-meta__separator">|</span><span>Reading time: 34 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Stock-Exchange"><a href="#Stock-Exchange" class="headerlink" title="Stock Exchange"></a>Stock Exchange</h2><span id="more"></span>
<p>이 포스트에선 전자 증권 거래소 시스템을 설계한다.</p>
<p>거래소의 기본 기능은 구매자와 판매자의 효율적인 매칭을 촉진하는 것이다. 이 기본 기능은 시간이 지나도 변치 않는다. 컴퓨터가 등장하기 전에는 사람들이 물물교환을 하거나 서로에게 소리를 지르며 매칭을 요청하는 방식으로 유형의 상품을 교환했다. 오늘날 주문은 슈퍼컴퓨터에 의해 자동으로 처리되며, 사람들은 상품 교환뿐만 아니라 투기 및 차익거래도 거래한다. 기술은 거래 환경을 크게 변화시켰고 전자 시장 거래량을 크게 증가시켰다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240108222902648.png" alt=""></p>
<h2 id="Step-1-Understand-the-Problem-and-Establish-Design-scope"><a href="#Step-1-Understand-the-Problem-and-Establish-Design-scope" class="headerlink" title="Step 1 - Understand the Problem and Establish Design scope"></a>Step 1 - Understand the Problem and Establish Design scope</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Candidate: Which securities are we going to trade? Stocks, options, or futures?</span><br><span class="line">Interviewer: For simplicity, only stocks.</span><br><span class="line"></span><br><span class="line">Candidate: Which types of order operations are supported: placing a new order, canceling an order, or replacing an order? Do we need to support limit order, market order, or conditional order?</span><br><span class="line">Interviewer: We need to support the following: placing a new order and canceling an order. For the order type, we only need to consider the limit order.</span><br><span class="line"></span><br><span class="line">Candidate: Does the system need to support after-hours trading?</span><br><span class="line">Interviewer: No, we just need to support the normal trading hours.</span><br><span class="line"></span><br><span class="line">Candidate: Could you describe the basic functions of the exchange? And the scale of the exchange, such as how many users, how many symbols, and how many orders?</span><br><span class="line">Interviewer: A client can place new limit orders or cancel them, and receive matched trades in real-time. A client can view the real-time order book (the list of buy and sell orders). The exchange needs to support at least tens of thousands of users trading at the same time, and it needs to support at least 100 symbols. For the trading volume, we should support billions of orders per day. Also, the exchange is a regulated facility, so we need to make sure it runs risk checks.</span><br><span class="line"></span><br><span class="line">Candidate: Could you please elaborate on risk checks?</span><br><span class="line">Interviewer: Let’s just do simple risk checks. For example, a user can only trade a maximum of 1 million shares of Apple stock in one day.</span><br><span class="line"></span><br><span class="line">Candidate: I noticed you didn’t mention user wallet management. Is it something we also need to consider?</span><br><span class="line">Interviewer: Good catch! We need to make sure users have sufficient funds when they place orders. If an order is waiting in the order book to be filled, the funds required for the order need to be withheld to prevent overspending.</span><br></pre></td></tr></table></figure>
<h3 id="Non-functional-requirements"><a href="#Non-functional-requirements" class="headerlink" title="Non-functional requirements"></a>Non-functional requirements</h3><ul>
<li><strong>Availability</strong> : 최소 99.99%. 거래소에 있어 가용성은 매우 중요하다. 단 몇 초라도 다운타임이 발생하면 평판에 해를 끼칠 수 있다.</li>
<li><strong>Fault tolerance</strong> : 프로덕션 인시던트의 영향을 제한하려면 내결함성과 빠른 복구 메커니즘이 필요하다.</li>
<li><strong>Latency</strong> : 왕복 지연 시간은 밀리초 수준이여야 하며, 특히 99번째 백분위수 지연 시간에 중점을 두어야 한다. 왕복 지연 시간은 시장가 주문이 거래소에 들어오는 순간부터 시장가 주문이 채결된 상태로 반환되는 시점까지의 시간이다. 99번재 백분위수 지연 시간이 지속적으로 높으면 소수의 사용자에게는 끔찍한 사용자 환경을 초래한다.</li>
<li><strong>Security</strong> : 거래소는 계정 관리 시스템을 갖추고 있어야 한다. 법률 준수를 위해 거래소는 새 계정을 개설하기 전에 사용자 신원 확인을 위한 KYC(Known Your Client)를 수행한다. 시장 데이터가 포함된 웹 페이지와 같은 공개 리소스의 경우, 분산 서비스 거부(DDoS) 공격을 방지해야 한다.</li>
</ul>
<h4 id="Back-of-the-envelope-estimation"><a href="#Back-of-the-envelope-estimation" class="headerlink" title="Back-of-the-envelope estimation"></a>Back-of-the-envelope estimation</h4><ul>
<li>100 symbols</li>
<li>1B orders per day</li>
<li>NYSE는 월요일부터 금요일 오전 9시 30분부터 오후 4시까지 총 6.5시간을 운영한다.</li>
<li>QPS: 10B / 6.5 / 3600 =~ 43,000</li>
<li>Peak QPS : 5 * QPS = 215,000. 거래량은 오전에 시장이 처음 열릴 때와 오후에 시장이 닫히기 전에 훨씬 더 높다.</li>
</ul>
<h2 id="Step-2-Propose-High-Level-Design-and-Get-Buy-In"><a href="#Step-2-Propose-High-Level-Design-and-Get-Buy-In" class="headerlink" title="Step 2 - Propose High-Level Design and Get Buy-In"></a>Step 2 - Propose High-Level Design and Get Buy-In</h2><p>고수준 설계 전에 거래소 설계에 도움이 되는 몇 가지 기본 개념과 용어에 대해 간략히 알아보자.</p>
<h3 id="Business-Knowledge-101"><a href="#Business-Knowledge-101" class="headerlink" title="Business Knowledge 101"></a>Business Knowledge 101</h3><p><strong>Broker</strong></p>
<p>대부분의 소매 고객은 브로커를 통해 거래소와 거래한다. 이런 브로커는 개인 사용자가 거래를 하고 시장 데이터를 볼 수 있는 친숙한 사용자 인터페이스를 제공한다.</p>
<p><strong>Institutional client</strong></p>
<p>기관 고객은 전문 트레이딩 소프트웨어를 사용해 대량으로 거래한다. 기관 고객마다 요구 사항이 다르다. 예를 들어 연기금은 안정적인 수익을 목표로 한다. 거래 빈도는 낮지만 거래할 때는 거래량이 많다. 이들은 대규모 주문이 시장에 미치는 영향을 최소화하기 위해 주문 분할과 같은 기능이 필요하다. 일부 헤지펀드는 시장 조성을 전문으로 하며 수수료 리베이트를 통해 수익을 얻는다. 이들은 지연 시간이 짧은 트레이딩 능력이 필요하므로 리테일 고객처럼 웹 페이지나 모바일 앱에서 시장 데이터를 볼 수 없다.</p>
<p><strong>Limit order</strong></p>
<p>지정가 주문은 가격이 고정된 매수 또는 매도 주문이다. 즉시 일치하는 ㅎ ㅗ가를 찾지 못할 수도 있고 부분적으로만 일치할 수도 있다.</p>
<p><strong>Market order</strong></p>
<p>시장가 주문은 가격을 지정하지 않는다. 시장가 주문은 즉시 시장가로 체결된다. 시장가 주문은 체결을 보장하기 위해 비용을 희생한다. 급변하는 특정 시장 상황에서 유용하다.</p>
<p><strong>Market data levels</strong></p>
<p>미국 주식시장에는 L1, L2, L3 세 가지 호가 등급이 있다. L1 시장 데이터에는 최고 매수 호가, 매도 호가 및 수량이 포함된다. 매수 호가는 구매자가 주식에 대해 지불할 의사가 있는 가장 높은 가격을 말한다. 매도 호가는 매도자가 주식을 팔고자 하는 최저 가격을 나타낸다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240108223849315.png" alt=""></p>
<p>L2는 L1보다 더 많은 가격 정보를 담고 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240108223924651.png" alt=""></p>
<p>L3는 가격 레벨과 각 가격 레벨에서 대기중인 수량을 보여준다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240108224002819.png" alt=""></p>
<p><strong>Candlestick chart</strong></p>
<p>캔들 차트는 특정 기간 동안의 주가를 나타낸다. 캔들 스틱은 일정 시간 간격 동안 시장의 시가, 종가, 고가, 저가를 표시한다. 일반적인 시간 간격은 1분, 5분, 1시간, 1주일, 1개월이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240108224115697.png" alt=""></p>
<p><strong>FIX</strong></p>
<p>금융 정보 교환 프로토콜의 약자인 FIX(Financial Information eXchange)는 1991년에 만들어졌다. 증권 거래 정보를 교환하기 위한 벤더 중립적인 통신 프로토콜이다. FIX로 인코딩된 증권 거래의 예는 아래와 같다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8=FIX.4.2 | 9=176 | 35=8 | 49=PHLX | 56=PERS | 52=20071123-05:30:00.000 | 11=ATOMNOCCC9990900 | 20=3 | 150=E | 39=E | 55=MSFT | 167=CS | 54=1 | 38=15 | 40=2 | 44=15 | 58=PHLX EQUITY TESTING | 59=0 | 47=C | 32=0 | 31=0 | 151=15 | 14=0 | 6=0 | 10=128 |</span><br></pre></td></tr></table></figure>
<h3 id="High-level-design"><a href="#High-level-design" class="headerlink" title="High-level design"></a>High-level design</h3><p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240108224252017.png" alt=""></p>
<p>먼저 거래 흐름을 통해 주문을 추적한다. 이는 엄격한 대기 시간 요건을 갖춘 중요한 경로다. 이 흐름에서는 모든 것이 빠르게 진행되어야 한다.</p>
<ul>
<li>Step 1 : 고객이 브로커의 웹 또는 모바일 앱을 통해 주문한다.</li>
<li>Step 2 : 브로커가 주문을 거래소에 전송한다.</li>
<li>Step 3 : 주문이 클라이언트 게이트웨이를 통해 거래소에 들어간다. 클라이언트 게이트웨이는 입력 유효성 검사, 호가 제한, 인증, 정규화 등과 같은 기본적인 게이트키핑 기능을 수행한다. 그런 다음 클라이언트 게이트웨이는 주문을 주문 관리자에게 전달한다.</li>
<li>Step 4 - 5 : 주문 관리자는 위험 관리자가 설정한 규칙에 따라 위험 점검을 수행한다.</li>
<li>Step 6 : 위험 점검을 통과한 주문 관리자는 지갑에 주문에 필요한 자금이 충분한지 확인한다.</li>
<li>Step 7 - 9 : 주문이 매칭 엔진으로 전송된다. 일치하는 주문이 발견되면 매칭 엔진은 매수 측과 매도 측에 각각 하나씩 두 개의 체결을 내보낸다. 재생할 때 매칭 결과가 결정적이라는 것을 보장하기 위해 주문과 체결은 모두 시퀀서에서 시퀀싱된다.</li>
<li>Step 10 - 14 : 체결이 클라이언트에게 반환된다.</li>
</ul>
<p>다음으로 시장 데이터 흐름을 따라 매칭 엔진에서 데이터 서비스를 통해 브로커까지 주문 체결을 추적한다.</p>
<ul>
<li>Step M1 : 매칭 엔진은 매칭이 이루어지면 체결 스트림을 생성한다. 스트림은 시장 데이터 퍼블리셔로 전송된다.</li>
<li>Step M2 : 시장 데이터 게시자는 체결 및 주문 스트림에서 캔들 스틱 차트와 호가창을 시장 데이터로 구성한다. 그런 다음 시장 데이터를 데이터 서비스로 전송한다.</li>
<li>Step M3 : 시장 데이터는 실시간 분석을 위해 전용 스토리지에 저장된다. 브로커는 데이터 서비스에 연결해 시의적절한 시장 데이터를 얻는다. 브로커는 시장 데이터를 고객에게 전달한다.</li>
</ul>
<p>마지막으로 리포터의 흐름을 살펴보자.</p>
<ul>
<li>Step R1 - R2 : 리포터는 주문과 체결에서 필요한 모든 리포팅 필드를 수집하고 통합 기록을 데이터베이스에 쓴다.</li>
</ul>
<p>거래 흐름(1 ~ 14단계)는 임계 경로에 있지만 시장 데이터 흐름과 리포팅 흐름은 임계 경로에 있지 않다는 점에 유의해야 한다. 이 두 흐름은 서로 다른 지연 시간 요건을 가지고 있다.</p>
<h4 id="Trading-flow"><a href="#Trading-flow" class="headerlink" title="Trading flow"></a>Trading flow</h4><p>거래 흐름은 거래소의 임계 경로에 있다. 모든 것이 빠르게 진행되어야 한다. 거래 흐름의 핵심은 매칭 엔진이다.</p>
<p><strong>Matching engine</strong></p>
<p>매칭 엔진은 크로스 엔진이라고도 한다. 매칭 엔진의 주요 역할은 다음과 같다.</p>
<ul>
<li>각 심볼에 대한 order book을 유지한다. Order book은 심볼에 대한 매수 및 매도 주문 목록이다.</li>
<li>매수 및 매도 주문 매칭. 매칭 결과로 매수와 매도측에 각각 하나씩 두 개의 체결이 발생한다. 매칭 함수는 빠르고 정확해야 한다.</li>
<li>체결 스트림을 시장 데이터로 배포한다.</li>
</ul>
<p>고가용성 매칭 엔진 구현은 결정론적 순서로 매치를 생성할 수 있어야 한다. 즉, 알려진 주문 순서가 입력으로 주어지면 매칭 엔진은 해당 순서가 재생될 때 출력으로 동일한 순서로 체결을 생성해야 한다. 이 결정론은 고가용성의 기초가 된다.</p>
<p><strong>Sequencer</strong></p>
<p>시퀀서는 매칭 엔진을 결정론적으로 만드는 핵심 구성 요소다. 시퀀서는 매칭 엔진에서 처리하기 전에 들어오는 모든 주문에 시퀀스 ID를 스탬프 처리한다. 또한 매칭 엔진이 완료한 모든 실행 쌍에 시퀀스 ID를 스탬프 처리한다. 즉, 시퀀서에는 인바운드 인스턴스와 아웃바운드 인스턴스가 있으며, 각각 고유한 시퀀스를 유지한다. 각 시퀀서에서 생성된 시퀀스는 누락된 숫자를 쉽게 감지할 수 있도록 인련번호여야 한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240108225506468.png" alt=""></p>
<p>아래와 같은 이유로 들어오는 주문과 나가는 실행에는 시퀀스 ID가 찍혀있다.</p>
<ul>
<li>적시성 및 공정성</li>
<li>빠른 복구 / 재생</li>
<li>정확한 1회성 보장</li>
</ul>
<p>시퀀서는 시퀀스 ID만 생성하는 것이 아니다. 메세지 대기열의 역할도 한다. 메세지를 매칭 엔진으로 보내는 메세지 큐와 메세지를 주문 관리자에게 다시 보내는 메세지 큐가 있다. 또한 주문과 실행을 위한 이벤트 저장소이기도 하다. 이는 매칭 엔진에 연결된 두 개의 카프카 이벤트 스트림 중 하나는 들어오는 주문용이고 다른 하나는 나가는 실행용인 것과 비슷하다.</p>
<p><strong>Order manager</strong></p>
<p>주문 관리자는 한쪽 끝에서 주문을 받고 다른 쪽 끝에서 실행을 받는다. 주문의 상태를 관리한다.</p>
<p>주문 관리자는 클라이언트 게이트웨이에서 인바운드 주문을 수신하고 다음을 수행한다.</p>
<ul>
<li>위험 확인을 위해 주문을 보낸다. 위험 확인에 대한 요구 사항은 간단하다. 예를 들어, 사용자의 거래량이 하루 100만 달러 미만인지 확인한다.</li>
<li>사용자의 지갑과 주문을 대조해 거래를 감당할 수 있는 충분한 자금이 있는지 확인한다.</li>
<li>지갑은 주문을 시퀀서에게 전송하고 시퀀스 ID가 찍힌 주문을 시퀀서로 보낸다. 그런 다음 시퀀싱된 주문은 매칭 엔진에 의해 처리된다. 새 주문에는 많은 속성이 있지만 모든 속성을 매칭 엔진에 보낼 필요는 없다. 데이터 전송 시 메세지 크기를 줄이기 위해 주문 관리자는 필요한 속성만 전송한다.</li>
</ul>
<p>다른 한편으로 주문 관리자는 시퀀서를 통해 매칭 엔진으로부터 실행을 수신한다. 주문 관리자는 클라이언트 게이트웨이를 통해 체결된 주문에 대한 체결을 브로커에게 반환한다.</p>
<p>주문 관리자는 빠르고 효율적이며 정확해야 한다. 주문 관리자는 주문의 현재 상태를 유지한다. 실제로 다양한 상태 전환을 관리하는 문제는 주문 관리자를 복잡하게 만드는 주요 원인이다. 실제 거래소 시스템에는 수만 개의 케이스가 관련되어 있을 수 있다. 이벤트 소싱은 주문 관리자의 설계에 적합하다. </p>
<p><strong>Client gateway</strong></p>
<p>클라이언트 게이트웨이는 거래소의 게이트키퍼다. 클라이언트가 주문한 주문을 받아 주문 관리자에게 라우팅한다. </p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240108231134688.png" alt=""></p>
<p>클라이언트 게이트웨이는 중요한 경로에 있으며 지연 시간에 민감하다. 가벼워야 한다. 가능한 빨리 올바른 목적지로 주문을 전달한다. 위의 기능은 중요하지만 가능한 빨리 완료되어야 한다. 클라이언트 게이트웨이에 어떤 기능을 넣을지, 어떤 기능을 빼야 할지 결정하는 것은 설계상의 트레이드 오프다. 일반적으로 복잡한 기능은 매칭 엔진과 리스크 점검에 맡기는 것이 좋다.</p>
<p>리테일 고객과 기관 고객을 위한 다양한 유형의 클라이언트 게이트웨이가 있다. 주요 고려사항은 지연 시간, 거래량, 보안 요구 사항이다. 예를 들어, 마켓 메이커와 같은 기관은 거래소에 많은 유동성을 제공한다. 이들은 매우 짧은 지연 시간을 요구한다. 아래는 거래소에 대한 다양한 클라이언트 게이트웨이 연결을 보여준다. 극단적인 예로 코로케이션 엔진을 들 수 있다. 이는 거래소의 데이터 센터에 있는 브로커가 임대한 일부 서버에서 실행되는 거래 엔진 스프트웨어다. 지연 시간은 말 그대로 빛이 코로케이션 서버에서 거래소 서보로 이동하는데 걸리는 시간이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240108231429534.png" alt=""></p>
<h4 id="Market-data-flow"><a href="#Market-data-flow" class="headerlink" title="Market data flow"></a>Market data flow</h4><p>시장 데이터 퍼블리셔(MDP)는 매칭 엔진에서 체결을 받고 체결 스트림에서 오더북과 캔들 스틱 차트를 작성한다. 나중에 데이터 모델 섹션에서 설명하는 호가창과 캔들 차트를 통칭해 시장 데이터라고 한다. 시장 데이터는 데이터 서비스로 전송되어 가입자가 사용할 수 있다. MDP의 구현과 이것이 시장 데이터 흐름의 다른 구성 요소와 어떻게 맞물리는지를 보여준다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240108232852383.png" alt=""></p>
<h4 id="Reporting-flow"><a href="#Reporting-flow" class="headerlink" title="Reporting flow"></a>Reporting flow</h4><p>거래소에서 필수적인 부분 중 하나는 리포팅이다. 리포터는 거래의 핵심 경로에 있지는 않지만 시스템의 중요한 부분이다. 리포터는 거래 내역, 세금 보고, 규정 준수 보고, 결제 등을 제공한다. 거래 흐름에는 효율성과 지연 시간이 중요하지만, 리포터는 지연 시간에 덜 민감하다. 보고자에게는 정확성과 규정 준수가 핵심 요소다.</p>
<p>들어오는 주문과 나가는 체결 모두에서 속성을 취합하는 것이 일반적이다. 들어오는 새 주문에는 주문 세부 정보만 포함되며, 나가는 체결에는 일반적으로 주문 ID, 가격 수량, 체결 상태만 포함된다. 리포터는 보고서를 위해 두 소스의 속성을 병합하기로 한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240108233042825.png" alt=""></p>
<h3 id="API-Design"><a href="#API-Design" class="headerlink" title="API Design"></a>API Design</h3><p>고객은 브로커를 통해 증권 거래소와 상호작용해 주문, 체결 조회, 시장 데이터 보기, 분석을 위한 과거 데이터 다운로드 등을 수행한다. 브로커와 클라이언트 게이트웨이 사이의 인터페이스를 지정하기 위해 아래 RESTful 규칙을 사용한다.</p>
<p>REST API는 헤지 펀드와 같은 기관 고객의 지연 시간 요구 사항을 충족하지 못할 수도 있다. 이런 기관을 위해 구축된 특수 소프트웨어는 다른 프로토콜을 사용할 가능성이 높지만, 프로토콜이 무엇이든 간에 아래 언급된 기본 기능은 지원되어야 한다.</p>
<p><strong>Order</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /v1/order</span><br></pre></td></tr></table></figure>
<p>이 엔드포인트는 주문을 처리한다. 인증이 필요하다.</p>
<p>Parameters</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">symbol: the stock symbol. String</span><br><span class="line">side: buy or sell. String</span><br><span class="line">price: the price of the limit order. Long</span><br><span class="line">orderType: limit or market (note we only support limit orders in our design). String</span><br><span class="line">quantity: the quantity of the order. Long</span><br></pre></td></tr></table></figure>
<p>Response</p>
<p>Body:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id: the ID of the order. Long</span><br><span class="line">creationTime: the system creation time of the order. Long</span><br><span class="line">filledQuantity: the quantity that has been successfully executed. Long</span><br><span class="line">remainingQuantity: the quantity still to be executed. Long</span><br><span class="line">status: new/canceled/filled. String</span><br><span class="line">rest of the attributes are the same as the input parameters</span><br></pre></td></tr></table></figure>
<p>Code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">200: successful</span><br><span class="line">40x: parameter error/access denied/unauthorized</span><br><span class="line">500: server error</span><br></pre></td></tr></table></figure>
<p><strong>Execution</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /execution?symbol=&#123;:symbol&#125;&amp;orderId=&#123;:orderId&#125;&amp;startTime=&#123;:startTime&#125;&amp;endTime=&#123;:endTime&#125;</span><br></pre></td></tr></table></figure>
<p>이 엔드포인트는 실행 정보를 쿼리한다. 인증이 필요하다.</p>
<p>Parameters</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">symbol: the stock symbol. String</span><br><span class="line">orderId: the ID of the order. Optional. String</span><br><span class="line">startTime: query start time in epoch \[11\]. Long</span><br><span class="line">endTime: query end time in epoch. Long</span><br></pre></td></tr></table></figure>
<p>Response</p>
<p>Body:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">executions: array with each execution in scope (see attributes below). Array</span><br><span class="line">id: the ID of the execution. Long</span><br><span class="line">orderId: the ID of the order. Long</span><br><span class="line">symbol: the stock symbol. String</span><br><span class="line">side: buy or sell. String</span><br><span class="line">price: the price of the execution. Long</span><br><span class="line">orderType: limit or market. String</span><br><span class="line">quantity: the filled quantity. Long</span><br></pre></td></tr></table></figure>
<p>Code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">200: successful</span><br><span class="line">40x: parameter error/not found/access denied/unauthorized</span><br><span class="line">500: server error</span><br></pre></td></tr></table></figure>
<p><strong>Order book</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /marketdata/orderBook/L2?symbol=&#123;:symbol&#125;&amp;depth=&#123;:depth&#125;</span><br></pre></td></tr></table></figure>
<p>이 엔드포인트는 지정된 깊이의 심볼에 대한 L2 Order book 정보를 쿼리한다.</p>
<p>Parameters</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">symbol: the stock symbol. String</span><br><span class="line">depth: order book depth per side. Int</span><br></pre></td></tr></table></figure>
<p>Response</p>
<p>Body:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bids: array with price and size. Array</span><br><span class="line">asks: array with price and size. Array</span><br></pre></td></tr></table></figure>
<p>Code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">200: successful</span><br><span class="line">40x: parameter error/not found/access denied/unauthorized</span><br><span class="line">500: server error</span><br></pre></td></tr></table></figure>
<p><strong>Historical prices (candlestick charts)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /marketdata/candles?symbol=&#123;:symbol&#125;&amp;resolution=&#123;:resolution&#125;&amp;startTime=&#123;:startTime&#125;&amp;endTime=&#123;:endTime&#125;</span><br></pre></td></tr></table></figure>
<p>이 엔드포인트는 시간 범위와 해상도가 지정된 기호에 대한 캔들 차트 데이터를 쿼리한다.</p>
<p>Parameters</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">symbol: the stock symbol. String</span><br><span class="line">resolution: window length of the candlestick chart in seconds. Long</span><br><span class="line">startTime: start time of the window in epoch. Long</span><br><span class="line">endTime: end time of the window in epoch. Long</span><br></pre></td></tr></table></figure>
<p>Response</p>
<p>Body:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">candles: array with each candlestick data (attributes listed below). Array</span><br><span class="line">open: open price of each candlestick. Double</span><br><span class="line">close: close price of each candlestick. Double</span><br><span class="line">high: high price of each candlestick. Double</span><br><span class="line">low: low price of each candlestick. Double</span><br></pre></td></tr></table></figure>
<p>Code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">200: successful</span><br><span class="line">40x: parameter error/not found/access denied/unauthorized</span><br><span class="line">500: server error</span><br></pre></td></tr></table></figure>
<h3 id="Data-models"><a href="#Data-models" class="headerlink" title="Data models"></a>Data models</h3><h4 id="Product-order-execution"><a href="#Product-order-execution" class="headerlink" title="Product, order, execution"></a>Product, order, execution</h4><p>상품은 상품 유형, 트레이딩 심볼, UI 표시 심볼, 결제 통화, lot 크기, 틱 크기 등 거래되는 심볼의 속성을 설명한다. 이 데이터는 자주 변경되지 않는다. 주로 UI 표시를 위해 사용된다. 이 데이터는 모든 데이터베이스에 저장할 수 있으며 캐시 가능성이 높다.</p>
<p>주문은 매수 또는 매도 주문의 인바운드 주문을 나타낸다. 체결은 아웃바운드 체결 결과를 나타낸다. 체결은 체결이라고도 한다. 모든 주문에 체결이 있는 것은 아니다. 매칭 엔진의 출력에는 매칭된 주문의 매수 및 매도 측을 나타내는 두 개의 체결이 포함된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240109211514423.png" alt=""></p>
<p>주문과 체결은 거래소에서 가장 중요한 데이터다. 고수준 설계에서 언급한 세 가지 흐름 모두에서 약간씩 다른 형태로 만나게 된다.</p>
<ul>
<li>중요 거래 경로에서는 주문과 체결이 데이터베이스에 저장되지 않는다. 고성능을 달성하기 위해 이 경로는 메모리에서 거래를 실행하고 하드 디스크 또는 공유 메모리를 활용해 주문과 체결을 지속하고 공유한다. 특히 주문과 체결은 빠른 복구를 위해 시퀀서에 저장되며, 시장은 마감된 후 데이터가 보관된다.</li>
<li>리포터는 조정 및 세금 신고와 같은 사용 사례를 보고하기 위해 주문과 체결을 데이터베이스에 기록한다.</li>
<li>체결은 시장 데이터 프로세서로 전달되어 호가창과 캔들스틱 차트 데이터를 재구성한다.</li>
</ul>
<h4 id="Order-book"><a href="#Order-book" class="headerlink" title="Order book"></a>Order book</h4><p>호가창은 특정 증권 또는 금융상품에 대한 매수 및 매도 주문 목록으로 가격 수준별로 정리되어 있다. 이는 빠른 주문 매칭을 위한 매칭 엔진의 핵심 데이터 구조다. 효율적인 호가창 데이터 구조는 다음과 같은 요건을 충족해야 한다.</p>
<ul>
<li>일정한 조회 시간. 연산에는 가격 수준 또는 가격 수준 간의 거래량 가져오기가 포함된다.</li>
<li>빠른 추가 / 취소 / 실행 작업, 가급적 O(1) 시간 복잡도. 작업에는 새 주문, 주문 최소, 주문 매칭이 포함된다.</li>
<li>빠른 업데이트. (주문 교체)</li>
<li>최적의 매수 / 매도 호가 조회</li>
<li>가격 레벨 이터레이션</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240109212150342.png" alt=""></p>
<p>위 예시에서 Apple 주식 2700주에 대한 대량 시장가 매수 주문이 있다. 매수 주문은 최고 호가 대기열의 모든 매도 주문과 100.11 호가 대기열의 첫 번째 대기열의 첫 번재 매도 주문과 일치한다. 이 대량 주문이 채결되면 매수 / 매도 스프레드가 넓어지고 가격이 한 단계 상승한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriceLevel</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Price limitPrice;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> totalVolume;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orders;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>&lt;Side&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Side side;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Price, PriceLevel&gt; limitMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderBook</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Book&lt;Buy&gt; buyBook;</span><br><span class="line">    <span class="keyword">private</span> Book&lt;Sell&gt; sellBook;</span><br><span class="line">    <span class="keyword">private</span> PriceLevel bestBid;</span><br><span class="line">    <span class="keyword">private</span> PriceLevel bestOffer;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;OrderID, Order&gt; orderMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>코드가 위에 명시된 모든 설계 요건을 충족할까? 예를 들어 지정가 주문을 추가 / 취소할 때 시간 복잡도가 O(1)인가? 여기서는 리스트를 사용하고 있으므로 정답은 아니오다. 보다 효율적인 호가창을 만들려면 “주문”의 데이터 구조를 더블 링크드 리스트로 변경해 삭제 유형의 연산도 O(1)이 되도록 한다. 이런 연산의 시간 복잡도를 O(1)로 만드는 방법을 살펴보자.</p>
<ol>
<li>새 주문을 넣는다는 것은 PriceLevel의 꼬리에 새 주문을 추가하는 것을 의미한다. 이중으로 연결된 목록의 경우 시간 복잡도는 O(1)이다.</li>
<li>주문을 일치시키는 것은 가격 레벨 헤드에서 주문을 삭제하는 것을 의미한다. 더블 링크드 리스트의 시간 복잡도는 O(1)이다. </li>
<li>주문을 취소한다는 것은 오더북에서 주문을 삭제한다는 뜻이다. 우리는 OrderBook의 orderMap을 활용해 취소할 주문을 O(1) 시간 내에 찾는다. 주문을 찾은 후 “주문” 목록이 단일 링크된 목록인 경우, 주문을 삭제하려면 코드가 전체 목록을 순회해 이전 포인터를 찾아야 한다. 이 경우 O(n) 시간이 걸렸을 것이다. 이제 목록이 이중 연결되었으므로 주문 자체에 이전 주문에 대한 포인터가 있으므로 코드가 전체 주문 목록을 순회하지 않고도 주문을 삭제할 수 있다.</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240109212832540.png" alt=""></p>
<p>호가창 데이터 구조는 매칭 엔진이 생성한 체결 스트림에서 L1, L2, L3 데이터를 재구성하기 위해 시장 데이터 프로세서에서도 많이 사용된다.</p>
<h4 id="Candlestick-chart"><a href="#Candlestick-chart" class="headerlink" title="Candlestick chart"></a>Candlestick chart</h4><p>캔들스틱 차트는 시장 데이터를 생성하는 시장 데이터 프로세서의 또 다른 핵심 데이터 구조다. 캔들 스틱 클래스와 캔들 스틱 차트 클래스로 이를 모델링한다. 캔들 스틱의 주기가 경과하면 다음 주기에 대한 새 캔들스틱 클래스가 인스턴스화되고, 캔들스틱 차트 인스턴스의 링크드 리스트에 추가된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Candlestick</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> openPrice;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> closePrice;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> highPrice;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> lowPrice;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> volume;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timestamp;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> interval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CandlestickChart</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Candlestick&gt; sticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>캔들 차트에서 많은 종목의 가격 이력을 여러 시간 간격으로 추적하려면 많은 메모리가 소모된다. 어떻게 최적화할 수 있을까?</p>
<ol>
<li>미리 할당된 링 버퍼를 사용해 스틱을 보관해 새 오브젝트 할당 횟수를 줄인다.</li>
<li>메모리에 있는 스틱의 수를 제한하고 나머지는 디스크에 보존한다.</li>
</ol>
<p>시장 데이터는 일반적으로 실시간 분석을 위해 인메모리 컬럼형 데이터베이스 (e.g. KDB)에 유지된다. 시장이 마감된 후 데이터는 히스토리성 데이터베이스에 유지된다.</p>
<h2 id="Step-3-Design-Deep-Dive"><a href="#Step-3-Design-Deep-Dive" class="headerlink" title="Step 3 - Design Deep Dive"></a>Step 3 - Design Deep Dive</h2><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>비기능적 요구 사항에서 설명한 것처럼 지연 시간은 거래소에 매우 중요하다. 평균 지연 시간이 낮아야 할 뿐만 아니라 전반적인 지연 시간도 안정적이어야 한다. 안정성 수준을 가늠하는 좋은 척도는 99번째 백분위수 지연 시간이다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Latency = ∑executionTimeAlongCriticalPath</span><br></pre></td></tr></table></figure>
<p>지연 시간을 줄이는 방법에는 두 가지가 있다.</p>
<ol>
<li>중요 경로에 있는 작업의 수를 줄인다.</li>
<li>각 작업에 소요되는 시간을 단축한다.<ol>
<li>네트워크 및 디스크 사용량을 줄이거나 제거한다.</li>
<li>각 작업의 실행 시간을 줄인다.</li>
</ol>
</li>
</ol>
<p>첫 번째 요점을 살펴보자. 고수준의 설계에서 볼 수 있듯이 중요 거래 경로에는 다음이 포함된다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gateway -&gt; order manager -&gt; sequencer -&gt; matching engine</span><br></pre></td></tr></table></figure>
<p>중요 경로에는 필요한 구성 요소만 포함되며, 지연 시간을 줄이기 위해 로깅도 중요 경로에서 제거된다.</p>
<p>이제 두 번째 요점을 살펴보자. 고수준 설계에서 중요 경로의 구성 요소는 네트워크를 통해 연결된 개별 서버에서 실행된다. 왕복 네트워크 지연 시간은 약 500ms다. 중요 경로에 있는 여러 컴포넌트가 모두 네트워크를 통해 통신하는 경우 총 네트워크 지연 시간은 한 자리수 ms로 늘어난다. 또한 시퀀서는 이벤트를 디스크에 지속시키는 이벤트 저장소다. 순차적 쓰기의 성능 이점을 활용하는 효율적인 설계를 가정하더라도 디스크 액세스 지연 시간은 여전히 수십ms 단위로 측정된다.</p>
<p>네트워크와 디스크 액세스 지연 시간을 모두 고려하면 총 엔드투엔드 지연 시간은 수십 ms에 달한다. 거래소 초창기에는 이 수치가 상당한 수준이었지만, 거래소들이 초 저지연 경쟁을 벌이면서 더 이상 충분하지 않다.</p>
<p>경쟁에 앞서 나가기 위해 거래소는 시간이 지남에 따라 주로 네트워크 및 디스크 액세스 지연 시간을 줄이거나 없애는 옵션을 모색해 중요 경로의 엔드투엔드 지연 시간을 수십 ms로 줄이기 위해 설계를 발전시키고 있다. 오랜 시간 테스트를 거친 설계는 모든 것을 동일한 서버에 배치해 네트워크 홉을 제거한다. 모든 컴포넌트가 동일한 서버에 있으면 이벤트 저장소인 mmap을 통해 통신할 수 있다.</p>
<p>아래는 모든 컴포넌트를 단일 서버에 배치한 지연 시간이 짧은 설계를 보여준다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240109223346861.png" alt=""></p>
<p>자세히 살펴볼 만한 디자인들이 있다.</p>
<p>먼저 위 다이어그램의 애플리케이션 루프에 초점을 맞춰보자. 애플리케이션 루프는 흥미로운 개념이다. 애플리케이션 루프는 실행할 작업을 계속 폴링하는 기본 작업 실행 메커니즘이다. 엄격한 지연 시간 예산을 충족하려면 가장 미션 크리티컬한 작업만 애플리케이션 루프에서 처리해야 한다. 이 메커니즘의 목표는 각 구성 요소의 실행 시간을 줄이고 예측 가능한 실행 시간을 보장하는 것이다. 다이어그램의 각 상자는 컴포넌트를 나타낸다. 컴포넌트는 서버의 프로세스다. CPU 효율성을 극대화하기 위해 각 애플리케이션 루프는 단일 스레드로 구성되며 스레드는 고정된 CPU 코어에 할당된다. </p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240109223602628.png" alt=""></p>
<p>이 다이어그램에서 주문 관리자의 애플리케이션 루프는 CPU 1에 고정되어 있다. 애플리케이션 루프를 CPU에 고정하면 상당한 이점이 있다.</p>
<ul>
<li>컨텍스트 스위칭이 힐요 없다. CPU 1은 주문 관리자의 애플리케이션 루프에 완전히 할당된다.</li>
<li>상태를 업데이트하는 스레드가 하나뿐이므로 잠금이 없고 따라서 잠금 경합도 없다.</li>
</ul>
<p>이 두 가지 모두 99번째 백분위수 지연 시간을 낮추는데 기여한다.</p>
<p>CPU pinning의 단점은 코딩이 더 복잡해진다는 것이다. 엔지니어는 각 작업이 애플리케이션 루프 스레드를 너무 오래 점유하지 않도록 각 작업에 걸리는 시간을 신중히 분석해 후속 작업을 잠재적으로 차단할 수 있게 해야한다.</p>
<p>이제 mmap에 대해 알아보자. mmap은 파일을 프로세스의 메모리에 매핑하는 <code>mmap(2)</code>라는 이름의 POSIX 호환 UNIX 시스템 호출을 나타낸다.</p>
<p><code>mmap(2)</code>는 프로세스 간에 메모리를 고성능으로 공유하기 위한 메커니즘을 제공한다. 백업 파일이 <code>/dev/shm</code>에 있을 때 성능 이점은 배가된다. <code>dev/shm</code>은 메모리 백업 파일 시스템이다. <code>dev/shm</code>에 있는 파일에 대해 <code>mmap(2)</code>를 수행하면 공유 메모리에 대한 액세스가 전혀 디스크 액세스로 이어지지 않는다.</p>
<p>최신 교환기는 이 점을 활용해 중요 경로에서 가능한 한 많은 디스크 액세스를 제거한다. 서버에서 <code>mmap(2)</code>는 중요 경로의 구성 요소가 통신하는 메세지 버스를 구현하는데 사용된다. 이 통신 경로에는 네트워크나 디스크 액세스가 없으며, 이 mmap 메세지 버스에서 메세지를 전송하는데는 ms 미만이 걸린다. </p>
<h3 id="Event-sourcing"><a href="#Event-sourcing" class="headerlink" title="Event sourcing"></a>Event sourcing</h3><p>이벤트 소싱의 개념은 어렵지 않다. 기존 애플리케이션에서는 상태가 데이터베이스에 유지된다. 문제가 발생하면 문제의 원인을 추적하기 어렵다. 데이터베이스는 현재 상태만 유지하며, 현재 상태를 유발한 이벤트에 대한 기록이 없다.</p>
<p>이벤트 소싱에서는 현재 상태를 저장하는 대신 모든 상태 변경 이벤트에 대한 변경 불가능한 로그를 보관한다. 이런 이벤트는 진실 소스의 원천이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240109224138767.png" alt=""></p>
<p>왼쪽은 일반적인 데이터베이스 스키마다. 이 스키마는 주문의 주문 상태를 추적하지만 주문이 현재 상태에 도달하는 방법에 대한 정보는 포함하지 않는다. 오른쪽은 이벤트 소싱에 대응하는 스키마다. 주문 상태를 변경하는 모든 이벤트를 추적하며, 모든 이벤트를 순서대로 재생해 주문 상태를 복구할 수 있다.</p>
<p>아래는 mmap 이벤트 저장소를 메세지 버스로 사용하는 이벤트 소싱 설계를 보여준다. 이는 Kafka의 pub-sub 설계와 매우 유사하다. </p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240109224302978.png" alt=""></p>
<p>다이어그램에서 외부 도메인은 FIX를 사용해 트레이딩 도메인과 통신한다.</p>
<ul>
<li>게이트웨이는 빠르고 컴팩트한 인코딩을 위해 FIX를 “FIX over Simple Binary Encoding (SBE)”로 변환하고 이벤트 스토어 클라이언트를 통해 각 주문을 미리 정의된 형식으로 NewOrderEvent로 전송한다.</li>
<li>주문 관리자는 이벤트 스토어에서 NewOrderEvent를 수신해 유효성을 검사한 후 내부 주문 상태에 추가한다. </li>
<li>그런 다음 주문이 매칭 코어로 전송된다. 주문이 일치하면 OrderFilledEvent가 생성되어 이벤트 저장소로 전송된다.</li>
<li>시장 데이터 프로세서와 리포터 같은 다른 컴포넌트는 이벤트 스토어에 가입하고 그에 따라 이벤트를 처리한다. 이 설계는 상위 수준 설계를 따르지만 이벤트 소싱 패러다임에서 더 효율적으로 작동하도록 몇 가지 조정 사항이 있다.</li>
</ul>
<p>첫 번째 차이점은 주문 관리자다. 주문 관리자는 다른 컴포넌트에 내장된 재사용 가능한 라이브러리가 된다. 주문의 상태가 여러 컴포넌트에 중요하기 때문에 이런 설계가 합리적이다. 다른 컴포넌트가 주문 상태를 업데이트하거나 쿼리하기 위해 중앙화된 주문 관리자를 사용하면 특히 다이어그램의 리포터의 경우처럼 해당 컴포넌트가 중요한 거래 경로에 있지 않은 경우 지연 시간이 길어질 수 있다. 각 컴포넌트가 자체적으로 주문 상태를 유지하지만 이벤트 소싱을 사용하면 상태가 동일하고 재생이 보장된다.</p>
<p>또 다른 주요 차이점은 시퀀서가 없다는 점이다. 이벤트 소싱 설계에서는 모든 메세지에 대해 하나의 단일 이벤트 저장소가 있다. 이벤트 저장소 항목에는 “시퀀스” 필드가 포함되어 있다. 이 필드는 시퀀서에 의해 삽입된다.</p>
<p>각 이벤트 스토어에는 하나의 시퀀서만 있다. 시퀀서가 여러 개 있으면 이벤트 스토어에 대한 쓰기 권한을 놓고 서로 경쟁하게 되므로 좋지 않다. 거래소와 같이 바쁜 시스템에서는 잠금 경합으로 인해 많은 시간이 낭비될 수 있다. 따라서 시퀀서는 이벤트를 이벤트 스토어로 보내기 전에 이벤트의 순서를 정하는 단일 작성자다. 메세지 저장소 역할도 하는 고수준 설계의 시퀀서와 달리, 여기서 시퀀서는 한 가지 간단한 작업만 수행하며 매우 빠르다. </p>
<p>시퀀서는 각 컴포넌트에 로컬 링 버퍼에서 이벤트를 가져온다. 각 이벤트에 대해 이벤트에 시퀀스 ID를 스탬프하고 이벤트 저장소로 보낸다. 기본 시퀀서가 다운될 경우를 대비해 고가용성을 위한 백업 시퀀서를 보유할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240109225153995.png" alt=""></p>
<h3 id="High-availability"><a href="#High-availability" class="headerlink" title="High availability"></a>High availability</h3><p>고가용성을 위해 우리는 99.99%의 가동률을 목표로 설계했다. 이는 거래소의 다운타임이 하루 8.64초에 불과하다는 의미다. 서비스가 중단되면 거의 즉각적 복구가 필요하다.</p>
<p>고가용성을 달성하려면 다음 사항을 고려해야 한다.</p>
<ul>
<li>거래소 아키텍처에서 단일 장애 지점을 파악한다. 예를 들어, 매칭 엔진의 장애는 거래소에 재앙이 될 수 있다. 따라서 기본 인스턴스와 함께 중복 인스턴스를 설정한다.</li>
<li>장애 감지 및 백업 인스턴스로의 페일오버 결정이 빨라야 한다.</li>
</ul>
<p>클라이언트 게이트웨이와 같은 stateless 서비스의 경우 서버를 추가해 쉽게 수평정 확장이 가능하다. 주문 관리자 및 매칭 엔진과 같은 stateful 컴포넌트는 복제본 간에 상태 데이터를 복사할 수 있어야 한다.</p>
<p>아래는 데이터를 복사하는 방법의 예를 보여준다. 핫 매칭 엔진은 기본 인스턴스로 작동하고, 웜 엔진은 정확히 동일한 이벤트를 수신하고 처리하지만 이벤트 스토어로 어떤 이벤트도 전송하지 않는다. 기본 인스턴스가 다운되면 웜 인스턴스가 즉시 기본 인스턴스를 이어받아 이벤트를 전송할 수 있다. 웜 보조 인스턴스가 다운되어 다시 시작하면 항상 이벤트 저장소의 모든 상태를 복구할 수 있다. 이벤트 소싱은 거래소 아키텍처에 매우 적합하다. 내재된 경정론으로 인해 상태 복구가 쉽고 정확하다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240109225604464.png" alt=""></p>
<p>기본 엔진에서 잠재적인 문제를 감지할 수 있는 메커니즘을 설계해야 한다. 하드웨어와 프로세스에 대한 일반적인 모니터링 외에도 매칭 엔진에서 하트비트를 보낼 수 있다. 하트비트를 제때 받지 못하면 매칭 엔진에 문제가 있는 것일 수 있다.</p>
<p>이 핫 웜 설계의 문제점은 단일 서버의 경계 내에서만 작동한다는 것이다. 고가용성을 달성하려면 이 개념을 여러 대의 컴퓨터 또는 데이터센터 전체로 확장해야 한다. 이 설정에서는 전체 서버가 핫 또는 웜 상태이며, 전체 이벤트 스토어가 핫 서버에서 모든 웜 복제본으로 복제된다. 여러 머신에 걸쳐 전체 이벤트 스토어를 복제하는 데는 시간이 걸린다. 모든 웜 서버에 이벤트 메세지를 효율적으로 브로드캐스트하기 위해 안정적인 UDP를 사용할 수 있다. </p>
<h3 id="Fault-tolerance"><a href="#Fault-tolerance" class="headerlink" title="Fault tolerance"></a>Fault tolerance</h3><p>위의 핫-웜 디자인은 비교적 간단하다. 비교적 잘 작동하지만 웜 인스턴스도 다운되면 어떻게 될까? 확률은 낮지만 치명적인 상황이 발생할 수 있으므로 이에 대비해야 한다.</p>
<p>이런 문제들은 핵심 데이터를 여러 도시에 있는 데이터 센터에 복제해 DR을 구성한다. 내결함성 시스템을 만들기 위해서는 많은 질문에 답해야 한다.</p>
<ol>
<li>기본 인스턴스가 다운되면 언제 어떻게 백업 인스턴스로 페일오버를 결정할 것인가?</li>
<li>백업 인스턴스 중 리더 인스턴스는 어떻게 선택할까?</li>
<li>필요 복구 시간(Recovery Time Objective, RTO)는 얼마인가?</li>
<li>어떤 기능을 복구(Recovery Point Objective, RPO)해야 하나? 성능이 저하된 상태에서도 시스템이 작동할 수 있나?</li>
</ol>
<p>이제 질문에 하나씩 답해보자.</p>
<p>먼저 “다운”이 실제로 무엇을 의미하는지 이해해야 한다. 이는 생각만큼 간단하지 않다. 다음 상황을 생각해보라.</p>
<ol>
<li>시스템이 잘못된 경보를 전송해 불필요한 장애 조치를 유발할 수 있다.</li>
<li>코드의 버그로 인해 기본 인스턴스가 다운될 수 있다. 동일한 버그로 인해 장애 조치 후 백업 인스턴스가 다운될 수 있다. 모든 백업 인스턴스가 버그로 인해 중단되면 시스템을 더 이상 사용할 수 없게 된다.</li>
</ol>
<p>이는 해결하기 어려운 문제다. 다음은 몇 가지 제안 사항이다. 새 시스템을 처음 출시할 때는 수동으로 장애 조치를 수행해야 할 수도 있다. 충분한 신호와 운영 경험을 수집하고 시스템에 대한 신뢰도가 높아진 후에야 장애 감지 프로세스를 자동화할 수 있다. 카오스 엔지니어링은 엣지 케이스를 파악하고 운영 경험을 더 빨리 쌓을 수 있는 좋은 방법이다.</p>
<p>장애 조치 결정이 올바르게 내려지면 어떤 서버가 인계받을 지 어떻게 결정할까? 다행히 이 문제는 well known이다. Raft와 같은 리더 선출 알고리즘이 있다. 아래는 자체 이벤트 저장소가 있는 5개의 노드로 구성된 Raft 클러스터를 보여준다. 현재 리더는 다른 모든 인스턴스(팔로워)에 데이터를 전송한다. Raft에서 작업을 수행하는데 필요한 최소 투표 수는 (N/2 + 1)이며, 여기서 N은 클러스터의 구성원 수다. 이 예에서 최소 값이 3이다.</p>
<p>다음 다이어그램은 팔로워가 RPC를 통해 리더로부터 재 이벤트를 수신하는 과정을 보여준다. 이벤트는 팔로워 자체 MMAP 이벤트 저장소에 저장된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240111215450000.png" alt=""></p>
<p>리더 선출 과정을 간단히 살펴보자. 리더는 팔로워에게 하트비트 메세지를 보낸다. 팔로워가 일정 시간 동안 하트비트 메세지를 받지 못하면 새로운 선거를 시작하는 선거 타임아웃이 트리거된다. 선거 타임아웃에 도달한 첫 번째 팔로워는 후보자가 되어 나머지 팔로워에게 투표를 요청한다. 첫 번째 팔로워가 과반수 이상의 표를 받으면 새로운 리더가 된다. 첫 번째 팔로워의 임기 값이 새 노드보다 낮으면 리더가 될 수 없다. 여러 명의 팔로워가 동시에 후보가 되는 경우를 “분할 투표”라고 한다. 이 경우 선거가 시간 초과되고 새로운 선거가 시작된다. Raft에서는 시간을 임의의 간격으로 나누어 정상적인 운영과 선거를 나타낸다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240111215633169.png" alt=""></p>
<p>복구 시간 목표(RTO)는 비즈니스에 심각한 피해를 주지 않으면서 애플리케이션이 다운될 수 있는 시간을 의미한다. 증권 거래소의 경우 2단계 RTO를 달성해야 하며, 이를 위해서는 반드시 서비스 자동 페일오버가 필요하다. 이를 위해 우선순위에 따라 서비스를 분류하고 최소한의 서비스 수준을 유지하기 위한 성능 저하 전략을 정의한다.</p>
<p>마지막으로 데이터 손실에 대한 허용 오차를 파악해야 한다. 복구 지점 목표(RPO)는 비즈니스에 심각한 피해가 발생하기 전에 손실될 수 있는 데이터의 양, 즉 손실 허용 범위를 의미한다. 실제로 이는 데이터를 자주 백업하는 것을 의미한다. 증권 거래소의 경우 데이터 손실은 용납할 수 없으므로 RPO는 거의 0에 가깝다. Raft를 사용하면 데이터 사본을 많이 확보할 수 있고 클러스터 노드 간에 상태 협의가 이루어지도록 보장한다. 현재 리더가 충돌하면 새로운 리더가 즉시 작동할 수 있어야 한다.</p>
<h3 id="Matching-algorithms"><a href="#Matching-algorithms" class="headerlink" title="Matching algorithms"></a>Matching algorithms</h3><p>아래 의사코드는 매칭이 어떻게 작동하는지 고수준에서 설명한다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Context handleOrder(OrderBook orderBook, OrderEvent orderEvent) &#123;</span><br><span class="line">    if (orderEvent.getSequenceId() != nextSequence) &#123;</span><br><span class="line">        return Error(OUT_OF_ORDER, nextSequence);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!validateOrder(symbol, price, quantity)) &#123;</span><br><span class="line">        return ERROR(INVALID_ORDER, orderEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Order order = createOrderFromEvent(orderEvent);</span><br><span class="line">    switch (msgType):</span><br><span class="line">        case NEW:</span><br><span class="line">            return handleNew(orderBook, order);</span><br><span class="line">        case CANCEL:</span><br><span class="line">            return handleCancel(orderBook, order);</span><br><span class="line">        default:</span><br><span class="line">            return ERROR(INVALID_MSG_TYPE, msgType);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Context handleNew(OrderBook orderBook, Order order) &#123;</span><br><span class="line">    if (BUY.equals(order.side)) &#123;</span><br><span class="line">        return match(orderBook.sellBook, order);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return match(orderBook.buyBook, order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Context handleCancel(OrderBook orderBook, Order order) &#123;</span><br><span class="line">    if (!orderBook.orderMap.contains(order.orderId)) &#123;</span><br><span class="line">        return ERROR(CANNOT_CANCEL_ALREADY_MATCHED, order);</span><br><span class="line">    &#125;</span><br><span class="line">    removeOrder(order);</span><br><span class="line">    setOrderStatus(order, CANCELED);</span><br><span class="line">    return SUCCESS(CANCEL_SUCCESS, order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Context match(OrderBook book, Order order) &#123;</span><br><span class="line">    Quantity leavesQuantity = order.quantity - order.matchedQuantity;</span><br><span class="line">    Iterator&lt;Order&gt; limitIter = book.limitMap.get(order.price).orders;</span><br><span class="line">    while (limitIter.hasNext() &amp;&amp; leavesQuantity &gt; 0) &#123;</span><br><span class="line">        Quantity matched = min(limitIter.next.quantity, order.quantity);</span><br><span class="line">        order.matchedQuantity += matched;</span><br><span class="line">        leavesQuantity = order.quantity - order.matchedQuantity;</span><br><span class="line">        remove(limitIter.next);</span><br><span class="line">        generateMatchedFill();</span><br><span class="line">    &#125;</span><br><span class="line">    return SUCCESS(MATCH_SUCCESS, order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>의사 코드는 FIFO 매칭 알고리즘을 사용한다. 특정 가격 수준에서 먼저 들어온 주문이 먼저 매칭되고 마지막에 들어온 주문이 마지막으로 매칭된다.</p>
<p>매칭 알고리즘에는 여러 가지가 있다. 이런 알고리즘은 선물 거래에서 일반적으로 사용된다. 예를 들어, LMM(Lead Market Maker) 알고리즘이 있는 FIFO는 미리 정의된 비율에 따라 FIFO 대기열 보다 먼저 특정 수량을 LMM에 할당하고 LMM 회사는 거래소와 협상해 특권을 얻는다.</p>
<h3 id="Determinism"><a href="#Determinism" class="headerlink" title="Determinism"></a>Determinism</h3><p>기능적 결정론과 지연 결정론이 모두 있다. 기능적 결정론은 이전 섹션에서 다루었다. 시퀀서 및 이벤트 소싱과 같은 설계 선택은 이벤트가 동일한 순서로 재생될 경우 결과가 동일하도록 보장한다.</p>
<p>함수 결정론에서는 이벤트가 발생하는 실제 시간은 대부분 중요하지 않다. 중요한 것은 이벤트의 순서다. 아래는 시간 차원에서 불연속적인 불규칙한 점의 이벤트 타임스탬프를 연속적인 점으로 변환하여 재생 / 복구에 소요되는 시간을 크게 줄일 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240111220227049.png" alt=""></p>
<p>지연 시간 결정론은 각 거래에 대해 시스템 전체에서 거의 동일한 지연 시간을 갖는 것을 의미한다. 이는 비즈니스의 핵심이다. 이를 측정하는 수학적 방법이 있는데, 99번째 백분위수 지연 시간 또는 99.99번째 백분위수 지연시간이다. 지연 시간을 계산하기 위해 HdrHistogram을 활용할 수 있다. 99번째 백분위수 지연 시간이 낮다면, 해당 거래소는 거의 모든 거래에서 안정적인 성능을 제공한다.</p>
<p>지연 시간의 큰 변동을 조사하는 것이 중요하다. 예를 들어, 자바에서는 safe-point가 대부분의 원인이다. STW와 같은 GC가 그 예다.</p>
<h3 id="Market-data-publisher-optimizations"><a href="#Market-data-publisher-optimizations" class="headerlink" title="Market data publisher optimizations"></a>Market data publisher optimizations</h3><p>매칭 알고리즘에서 볼 수 있듯이 L3 호가창 데이터는 시장을 더 잘 볼 수 있게 해준다. 공개된 API를 사용할 수 있지만, 자세한 호가창을 위해서는 비용이 많이 든다. 많은 헤지펀드가 거래소 실시간 API를 통해 데이터를 직접 기록해 캔들차트와 기타 기술적 분석을 위한 차트를 만든다.</p>
<p>시장 데이터 게시자(MDP)는 매칭 엔진에서 일치하는 결과를 받아 이를 바탕으로 오더북과 캔들차트를 재구성한다. 그런 다음 구독자에게 데이터를 게시한다.</p>
<p>오더북 재구축은 위의 매칭 알고리즘 섹션에서 언급한 의사 코드와 유사하다. MDP는 다양한 레벨을 가진 서비스다. 예를 들어, 리테일 클라이언트는 기본적으로 5단계의 L2데이터만 볼 수 있으며 10단계까지 보려면 추가 비용을 지불해야 한다. MDP의 메모리는 영원히 확장할 수 없으므로 캔들스틱에 상한선을 설정해야 한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240111220634971.png" alt=""></p>
<p>이 설계는 링버퍼를 활용한다. 원형 버퍼라고도 하는 링 버퍼는 헤드가 테일과 연결된 고정 크기 큐다. 생산자가 지속적으로 데이터를 생성하면 하나 이상의 소비자가 데이터를 가져온다. 링버퍼의 공간은 미리 할당되어 있다. 객체를 생성하거나 할당 해제할 필요가 없다. 데이터 구조에도 잠금이 없다. 데이터 구조를 더욱 효율적으로 만드는 다른 기술도 있다. 예를 들어, 패딩은 링 버퍼의 시퀀스 번호가 다른 어떤 것과도 캐시 라인에 포함되지 않도록 한다.</p>
<h3 id="Distribution-fairness-of-market-data"><a href="#Distribution-fairness-of-market-data" class="headerlink" title="Distribution fairness of market data"></a>Distribution fairness of market data</h3><p>주식 거래에서 다른 거새로에 비해 지연 시간이 짧다는 것은 미래를 예측할 수 있는 선구안이 있다는 소리다. 규제를 받는 거래소의 경우 모든 시장 데이터 수신자가 동시에 데이터를 받을 수 있도록 보장하는 것이 중요하다. 예를 들어, MDP는 데이터 구독자 목록을 보유하고 있으며, 구독자의 순서는 퍼블리셔에 연결한 순서에 따라 결정되며, 항상 첫 번째 구독자가 먼저 데이터를 수신한다. 똑똑한 고객들은 시장이 열리면 가장 먼저 데이터를 받기 위해 경쟁할 것이다.</p>
<p>이를 완화할 수 있는 몇 가지 방법이 있다. 안정적인 UDP를 사용하는 멀티캐스트는 한 번에 많은 참가자에게 업데이트를 브로드캐스트하는데 좋은 솔루션이다. MDP는 가입자가 연결할 때 임의의 순서를 할당할 수도 있다. </p>
<h3 id="Multicast"><a href="#Multicast" class="headerlink" title="Multicast"></a>Multicast</h3><p>데이터는 세 가지 유형의 프로토콜을 통해 인터넷을 통해 전송될 수 있다.</p>
<ul>
<li>Unicast : 한 소스에서 한 대상으로</li>
<li>Broadcast : 한 소스에서 전체 하위 네트워크로</li>
<li>Multicast : 한 소스에서 다른 서브네트워크에 있을 수 있는 호스트 집합으로</li>
</ul>
<p>멀티캐스트는 교환 설계에서 일반적으로 사용되는 프로토콜이다. 동일한 멀티캐스트 그룹에 여러 수신기를 구성하면 이론상으로는 동시에 데이터를 수신할 수 있다. 그러나 UDP는 신뢰할 수 없는 프로토콜이며 데이터그램이 모든 수신자에게 도달하지 못할 수도 있다. 데이터 재전송을 위한 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NACK-Oriented_Reliable_Multicast">솔루션</a>이 있다.</p>
<h3 id="Colocation"><a href="#Colocation" class="headerlink" title="Colocation"></a>Colocation</h3><p>공정성에 대해 이야기 중이지만, 많은 거래소가 헤지펀드나 브로커의 서버를 거래소와 동일한 데이터 센터에 배치하는 코로케이션 서비스를 제공하는 것은 사실이다. 매칭 엔진에 주문할 때의 지연 시간은 기본적으로 케이블 길이에 비례한다. 코로케이션은 공정성의 개념을 깨뜨리지 않는다. 코로케이션은 유료 VIP 서비스로 간주할 수 있다.</p>
<h3 id="Network-security"><a href="#Network-security" class="headerlink" title="Network security"></a>Network security</h3><p>거래소는 일반적으로 일부 공용 인터페이스를 제공하므로 디도스 공격은 매우 어려운 문제다.</p>
<ol>
<li>퍼블릭 서비스와 데이터를 프라이빗 서비스에서 분리해 DDoS 공격이 가장 중요한 클라이언트에 영향을 미치지 않도록 한다. 동일한 데이터가 제공되는 경우 읽기 전용 복사본을 여러 개 만들어 문제를 격리할 수 있다.</li>
<li>캐싱 계층을 사용해 자주 업데이트되지 않는 데이터를 저장한다. 캐싱이 잘 되어 있으면 대부분의 쿼리가 데이터베이스에 영향을 미치지 않는다.</li>
<li>디도스 공격에 대비해 URL을 강화해야 한다. 예를 들어, <code>https://my.website.com/data?from=123&amp;to=456</code> 같은 URL을 사용하면 공격자가 쿼리 문자열을 변경해 다양한 요청을 쉽게 생성할 수 있다. 대신 다음과 같은 URL이 더 효과적이다. <code>https://my.website.com/data/recent</code> 또한 CDN 계층에서 쿼리도 가능하다.</li>
<li>효과적인 세이프 리스트 / 블랙 리스트 메커니즘이 필요하다. 많은 네트워크 게이트웨이 제품이 이런 유형의 기능을 제공한다.</li>
<li>속도 제한은 DDoS 공격을 방어하는데 자주 사용된다.</li>
</ol>
<h2 id="Wrap-Up"><a href="#Wrap-Up" class="headerlink" title="Wrap Up"></a>Wrap Up</h2><p>이 포스트에선 이상적인 거래소 배포 모델은 모든 것을 하나의 거대한 머신에 구성하는 결론에 도달할 수 있다. 실제로 일부 거래소는 이런 방식으로 구현된다.</p>
<p>최근 암호화폐 산업이 발전함에 따라 많은 암호화폐 거래소가 클라우드 인프라를 사용해 서비스를 배포하고 있다. 일부 탈중앙화 금융 프로젝트는 자동 시장 조성(AMM) 개념을 기반으로 하며 호가창이 필요하지 않다.</p>
<h2 id="Chapter-Summary"><a href="#Chapter-Summary" class="headerlink" title="Chapter Summary"></a>Chapter Summary</h2><p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240111221645218.png" alt=""></p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2024/01/08/System%20Design/ByteByteGo/book/stock-exchange/">https://songhayoung.github.io/2024/01/08/System%20Design/ByteByteGo/book/stock-exchange/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2024 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>