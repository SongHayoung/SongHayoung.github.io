<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[ByteByteGo] Why Do We Need a Message Queue?"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[ByteByteGo] Why Do We Need a Message Queue? | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-Do-We-Need-a-Message-Queue"><span class="toc-number">1.</span> <span class="toc-text">Why Do We Need a Message Queue?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-Message-Queue-Example"><span class="toc-number">2.</span> <span class="toc-text">A Message Queue Example</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Benefits-of-Message-Queues"><span class="toc-number">3.</span> <span class="toc-text">Benefits of Message Queues</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Fan-out"><span class="toc-number">3.1.</span> <span class="toc-text">Fan-out</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Asynchronous-Processing"><span class="toc-number">3.2.</span> <span class="toc-text">Asynchronous Processing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rate-Limiting"><span class="toc-number">3.3.</span> <span class="toc-text">Rate Limiting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Decoupling"><span class="toc-number">3.4.</span> <span class="toc-text">Decoupling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Horizontal-Scalability"><span class="toc-number">3.5.</span> <span class="toc-text">Horizontal Scalability</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Message-Persistence"><span class="toc-number">3.6.</span> <span class="toc-text">Message Persistence</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Batch-Processing"><span class="toc-number">3.7.</span> <span class="toc-text">Batch Processing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Message-Ordering"><span class="toc-number">3.8.</span> <span class="toc-text">Message Ordering</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-Brief-History-of-Message-Queues"><span class="toc-number">4.</span> <span class="toc-text">A Brief History of Message Queues</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.instagram.com/hayoung0_0/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">8625</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">193</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">60</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[ByteByteGo] Why Do We Need a Message Queue?</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-08-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/Byte-Byte-Go/">Byte Byte Go</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1.3k</span><span class="post-meta__separator">|</span><span>Reading time: 7 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Why-Do-We-Need-a-Message-Queue"><a href="#Why-Do-We-Need-a-Message-Queue" class="headerlink" title="Why Do We Need a Message Queue?"></a>Why Do We Need a Message Queue?</h2><span id="more"></span>
<p>이번에는 널리 사용되는 미들웨어인 메세지 큐에 대해 자세히 알아본다. 메세지 큐는 서로 다른 시스템 간의 통신에 자주 사용된다. 아래는 메세지 큐의 개념을 스타벅스에서 작동하는 방식과 비교하여 설명한다.</p>
<p>스타벅스에서는 계산원이 주문을 받고 돈을 받은 다음 고객의 이름을 커피잔에 적어 다음 단계로 넘긴다. 커피 메이커는 주문과 컵을 받아 커피를 만든다. 그런 다음 고객이 카운터에서 커피를 수령한다. 이 세 단계는 비동기적으로 작동한다. 계산원은 주문이 완료될 때까지 기다리지 않고 커피 컵에 주문을 내려놓기만 하면 된다. 커피 메이커는 완성된 커피를 카운터에 내려놓기만 하고 고객이 커피를 픽업할 때까지 기다리지 않는다.</p>
<p>스타벅스에서 주문하면 계산원이 주문을 받고 고객의 이름을 컵에 쓴 후 다음 고객으로 이동한다. 그러면 바리스타가 컵을 들고 음료를 준비한 후 고객이 가져갈 수 있도록 자리를 비운다. 이 프로세스의 장점은 비동기 시스템과 매우 유사하게 각 단계가 독립적으로 작동한다는 것이다. </p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230811132649054.png" alt=""></p>
<p>각 단계가 이전 단계의 완료를 기다릴 필요가 없는 이 비동기 처리 방식은 시스템의 처리량을 크게 증가시킨다.</p>
<h2 id="A-Message-Queue-Example"><a href="#A-Message-Queue-Example" class="headerlink" title="A Message Queue Example"></a>A Message Queue Example</h2><p>이번에는 실제 사례인 이커머스의 플래시 세일에 초점을 맞춰보자. 플래시 세일은 사용자 활동의 급증으로 인해 시스템에 부담을 줄 수 있다. 이런 수요를 관리하기 위해 많은 전략이 사용되며 메세지 대기열은 백엔드 최적화에서 중추적인 역할을 하는 경우가 많다. 간단한 이커머스 플래시 세일 아키텍처는 아래에 나와있다.</p>
<ul>
<li>Step 1 ~ 2 : 고객이 주뭉 서비스에 주문을 한다.</li>
<li>Step 3 : 결제를 처리하기 전에 주문 서비스에서 선택한 재고를 예약한다.</li>
<li>Step 4 : 주문 서비스에서 결제 서비스에 결제 지시를 보낸다. 결제 서비스는 결제 채널, 알림, 분석의 세 가지 서비스로 분산된다.</li>
<li>Step 5.1 and 6.1 : 결제 서비스에서 결제 채널 서비스로 결제 정보를 전송한다. 결제 채널 서비스는 외부 PSP(Payment Service Providers)와 통신하여 거래를 완료한다.</li>
<li>Step 5.2 and 6.2 : 결제 서비스에서 알림 서비스에 알림을 전송하면 알림 서비스는 이메일 또는 SMS를 통해 고객에게 알림을 전송한다.</li>
<li>Step 5.3 : 결제 서비스에서 거래 세부 정보를 분석 서비스로 전송한다.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230811133227740.png" alt=""></p>
<p>여기서 중요한 점은 플래시 세일 기간에는 원활한 사용자 경험이 매우 중요하다는 것이다. 트래픽이 많더라도 서비스 응답성을 유지하기 위해 메세지 대기열을 여러 단계로 통합하여 최적의 성능을 보장할 수 있다.</p>
<h2 id="Benefits-of-Message-Queues"><a href="#Benefits-of-Message-Queues" class="headerlink" title="Benefits of Message Queues"></a>Benefits of Message Queues</h2><h3 id="Fan-out"><a href="#Fan-out" class="headerlink" title="Fan-out"></a>Fan-out</h3><p>결제 서비스는 결제 채널, 알림, 분석 등 서로 다른 목적을 위해 세 가지 다운스트림 서비스로 데이터를 전송한다. 이런 팬아웃 방식은 마치 한 사람이 방에서 메세지를 외치면 이를 들어야 하는 모든 사람이 듣는 것과 같다. 생산자는 메세지를 대기열에 떨어뜨리기만 하면 소비자는 자신의 속도에 맞춰 메세지를 처리한다.</p>
<h3 id="Asynchronous-Processing"><a href="#Asynchronous-Processing" class="headerlink" title="Asynchronous Processing"></a>Asynchronous Processing</h3><p>스타벅스를 비유하자면, 점원이 커피가 만들어질 때까지 기다리지 않는 것처럼 주문 서비스도 결제가 완료될 때까지 기다리지 않는다. 결제 지시가 대기열에 배치되고 결제가 완료되면 고객에게 알림이 전송된다.</p>
<h3 id="Rate-Limiting"><a href="#Rate-Limiting" class="headerlink" title="Rate Limiting"></a>Rate Limiting</h3><p>플래시 세일에는 수만 명의 동시 사용자가 동시에 주문할 수 있다. 열성적인 고객을 수용하는 것과 시스템 안정성을 유지하는 것 사이에서 균형을 맞추는 것이 중요하다. 일반적인 접근 방식은 시스템 용량에 맞게 특정 시간 내에 들어오는 요청 수를 제한하는 것이다. 초과 요청은 거부되거나 잠시 지연된 후 재시도하도록 요청할 수 있다. 이 접근 방식은 시스템이 안정적으로 유지되고 과부하가 걸리지 않도록 보장한다. 통과한 요청의 경우 메세지 큐는 요청이 순서대로 효율적으로 처리되도록 보장한다. 시스템의 한 부분이 일시적으로 지연되더라도 순서가 손실되지 않는다. 처리될 때까지 대기열에 보관된다. 따라서 요청이 폭주하는 상황에서도 원활한 흐름이 보장된다.</p>
<h3 id="Decoupling"><a href="#Decoupling" class="headerlink" title="Decoupling"></a>Decoupling</h3><p>전체적인 아키텍처 내에서 서비스는 서로 긴밀하게 의존하지 않고 잘 정의된 메세지 인터페이스를 사용하여 서로 상호 작용한다. 각 서비스는 독립적으로 수정 및 배포할 수 잇다. 각 구성 요소는 서로 다른 프로그래밍 언어로 개발할 수 있다. 이는 아키텍처 설계에 유연성을 제공한다.</p>
<h3 id="Horizontal-Scalability"><a href="#Horizontal-Scalability" class="headerlink" title="Horizontal Scalability"></a>Horizontal Scalability</h3><p>서비스가 분리되어 있기 때문에 수요에 따라 독립적으로 확장할 수 있다. 각 서비스는 서로 다른 용량의 서비스를 제공할 수 있으므로 계획된 QPS(초당 쿼리 수) 또는 TPS(초당 트랜잭션 수)에 따라 확장할 수 있다.</p>
<h3 id="Message-Persistence"><a href="#Message-Persistence" class="headerlink" title="Message Persistence"></a>Message Persistence</h3><p>메세지 큐는 메세지를 저장하는 미들웨어로도 사용할 수 있다. 업스트림 서비스에 충돌이 발생하면 다운스트림 서비스는 항상 메세지 큐에서 메세지를 가져와 처리할 수 있다. 이런 방식으로 복구 기능은 각 서비스에서 벗어나 메세지 큐의 책임이 된다.</p>
<h3 id="Batch-Processing"><a href="#Batch-Processing" class="headerlink" title="Batch Processing"></a>Batch Processing</h3><p>처리 흐름에서 데이터 집합에 결과를 처리하기 위해 일괄 처리해야 하는 경우가 있다. 예를 들어 결제 서비스에서 분석 서비스에 업데이트를 전송하면 분석 서비스에서는 실시간 업데이트를 수행할 필요 없이 텀블링 창을 설정해 일괄 처리를 할 수 있다. 일괄 처리는 다운스트림 서비스의 요구 사항이므로 결제 서비스에서 이를 알 필요 없이 메세지를 대기열에 놓기만 하면 된다.</p>
<h3 id="Message-Ordering"><a href="#Message-Ordering" class="headerlink" title="Message Ordering"></a>Message Ordering</h3><p>플래시 세일에서는 재고 품목 수가 제한되어 있다. 예를 들어, 플래시 세일에서 iPhone을 10대만 제공하는데 10,000명 이상의 사용자가 주문한다. 주문을 어떻게 결정할까? 메세지 대기열에 모든 주문을 보관하면 자연스럽게 순서가 정해진다. 대기열의 첫 번째 10명이 iPhone을 받게 된다.</p>
<p>아래는 메세지 큐를 통해 서비스가 연결되고 분리된 모든 것을 한 곳에 모아 놓았다. 이런 방식으로 아키텍처는 더 높은 처리량을 달성할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230811134156737.png" alt=""></p>
<h2 id="A-Brief-History-of-Message-Queues"><a href="#A-Brief-History-of-Message-Queues" class="headerlink" title="A Brief History of Message Queues"></a>A Brief History of Message Queues</h2><p>아래는 지난 30년 동안 메세지 큐의 간략한 역사를 보여준다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230811134335957.png" alt=""></p>
<p>IBM MQ는 1993년에 출시되었다. 원래는 MQSeries라고 불렸으며 2002년에 WebSphere MQ로 이름이 변경되었다. 2014년에 IBM MQ로 이름이 변경되었다. IBM MQ는 금융 부분에서 널리 사용되는 매우 성공적인 제품이다. 2020년에도 여전히 10억 달러의 매출을 달성했다. 아래는 IBM MQ의 주요 개념이다.</p>
<p>큐 매니저는 메세지 큐를 위한 논리적 컨테이너이다. 메세지 채널을 통해 다른 큐 매니저에게 데이터를 전송한다. 큐는 메세지를 저장한다. 메세지는 전송할 데이터에 대한 추상화이다. 메세지 헤더에는 라우팅, 저장 및 배달 정보가 들어있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230811134532279.png" alt=""></p>
<p>MSMQ(1997)이나 SQS(2004)와 같은 다른 비-오픈소스 메세지 큐도 있으며 둘 다 해당 에코시스템에서 잘 사용되고 있다. 2003년에 금융 부문의 여러 기관에서 표준화된 메세징 프로토콜을 개발하기를 원했고, 그 결과 JP 모건 체이스에서 AMQP(Advanced Message Queuing Protocol)가 탄생했다. API 수준에서 표준화된 JMS(Java Messaging Service)와 달리 AMQP는 와이어 레벨 프로토콜로, 전송할 데이터의 형식을 지정한다. AMQP의 구현 중 하나인 RabbitMQ는 2007년에 Rabbit Technologies에서 개발했으며, 나중에 VMWare에 인수되었다.</p>
<p>아래는 RabbitMQ의 아키텍처를 보여준다. 그림에서 볼 수 있듯이 이 아키텍처는 IBM MQ와는 다르며 카프카 개념과 더 유사하다. 생산자는 지정된 exchange type으로 exchange에 메세지를 게시한다. 이는 direct, topic, fanout이 될 수 있다. 그러면 exchange는 다양한 메세지 속성과 exchange type에 따라 메세지를 대기열로 라우팅한다. 소비자는 그에 따라 메세지를 받는다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230811134928812.png" alt=""></p>
<p>RabbitMQ에는 최신 메세지 큐 개념이 많이 포함되어 있지만, 거의 20년 전에 개발되었습니다. 당시에는 분산 시스템이 지금처럼 성숙하지 않았기 대문에 대용량 및 동시 요청이 많은 시나리오를 처리하기에는 아키텍처가 제한적이었다.</p>
<p>2011년 초, LinkedIn은 분산 이벤트 스트리밍 플랫폼인 Kafka를 오픈소스화 했다. 이 플랫폼은 프란츠 카프카의 이름을 따서 명명되었다. 이름에서 알 수 있듯이 카프카는 글쓰기에 최적화되어 있다. 실시간 데이터 피드를 처리하기 위한 처리량이 많고 지연 시간이 짧은 플랫폼을 제공한다. 이벤트 스트리밍을 가능하게 하는 통합 이벤트 로그를 제공하며 인터넷 기업에서 널리 사용되고 있다. 아래는 단순화된 카프카 아키텍처를 보여준다.</p>
<p>앞으로 카프카의 아키텍처를 좀 더 자세히 살펴보겠지만, 일반적으로 카프카는 생산자, 브로커, 토픽, 파티션, 소비자를 정의한다. 단순성과 내결함성 덕분에 AMQP 기반 메세지 큐와 같은 이전 제품을 대체할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230811135237603.png" alt=""></p>
<p>야후에서 처음 개발한 Pulsar는 올인원 메세징 및 스트리밍 플랫폼이다. Kafka와 비교했을 때, Pulsar는 다른 제품의 많은 유용한 기능을 통합하고 다양한 기능을 지원한다. 또한, Pulsar 아키텍처는 보다 클라우드 네이티브에 가깝기 때문에 클러스터 확장 및 파티션 마이그레이션 등을 더 잘 지원한다. 아래는 Pulsar 아키텍처의 단순화된 버전을 보여준다.</p>
<p>Kafka와 유사하게 Pulsar에는 토픽이라는 개념이 있다. URI는 아래와 같다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;type&#125;://&#123;tenant&#125;/&#123;namespace&#125;/&#123;topic&#125;</span><br></pre></td></tr></table></figure>
<p>URI에 테넌트 요소가 있다는 것은 Pulsar가 멀티테넌트 환경을 지원한다는 의미이다. 또한 Pulsar는 영구 또는 비영구 토픽을 모두 지원한다. 영구 토픽은 디스크에 메세지를 지속하고 복제하는 반면, 비영구 토픽은 메모리에 상주하며 장애가 발생하면 손실될 수 있다.</p>
<p>Pulsar 아키텍처에는 서빙 레이어와 영구 레이어의 두 가지 레이어가 있다. 서빙 레이어는 여러 브로커로 구성되며 수신 및 발신 메세지를 처리한다. 서빙 레이어는 상태 비저장형이다. 퍼시스턴트 계층을 활용하여 Apache BookKeeper를 통해 메세지를 저장한다. 또 다른 흥미로운 설계는 Pulsar가 기본적으로 계층형 스토리지를 지원한다는 점인데, 이를 통해 AWS S3와 같은 저렴한 객체 스토리지를 활용하여 메세지를 장기적으로 보존할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230811135627166.png" alt=""></p>
<p>결론적으로 메세지 큐는 메세징 미들웨어에서 스트림 처리로 진화했다. 최신 메세지 큐는 일반적으로 이 두 가지 기능을 결합하여 분산 환경에서 내결함성을 지원한다. 각 인기 제품의 탄생으로 메세지 큐의 프로그래밍 패러다임이 바뀌고 비즈니스의 고충이 해결되는 과정을 아래 다이어그램으로 정리하며 마무리한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230811135718902.png" alt=""></p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2023/08/11/System%20Design/ByteByteGo/private/why-do-we-need-a-message-queue/">https://songhayoung.github.io/2023/08/11/System%20Design/ByteByteGo/private/why-do-we-need-a-message-queue/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2023 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>