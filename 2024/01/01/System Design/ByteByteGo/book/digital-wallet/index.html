<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[ByteByteGo] Digital Wallet"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[ByteByteGo] Digital Wallet | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Digital-Wallet"><span class="toc-number">1.</span> <span class="toc-text">Digital Wallet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-1-Understand-the-Problem-and-Establish-Design-Scope"><span class="toc-number">2.</span> <span class="toc-text">Step 1 - Understand the Problem and Establish Design Scope</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Functional-Requirements"><span class="toc-number">2.1.</span> <span class="toc-text">Functional Requirements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Back-of-the-envelope-estimation"><span class="toc-number">2.2.</span> <span class="toc-text">Back-of-the-envelope estimation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-2-Propose-High-Level-Design-and-Get-Buy-In"><span class="toc-number">3.</span> <span class="toc-text">Step 2 - Propose High-Level Design and Get Buy-In</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API-Design"><span class="toc-number">3.1.</span> <span class="toc-text">API Design</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#In-memory-sharding-solution"><span class="toc-number">3.2.</span> <span class="toc-text">In-memory sharding solution</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Distributed-transactions"><span class="toc-number">3.3.</span> <span class="toc-text">Distributed transactions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Database-sharding"><span class="toc-number">3.3.1.</span> <span class="toc-text">Database sharding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Distributed-transaction-two-phase-commit"><span class="toc-number">3.3.2.</span> <span class="toc-text">Distributed transaction: two-phase commit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Distributed-transaction-Try-Confirm-Cancel-TC-C"><span class="toc-number">3.3.3.</span> <span class="toc-text">Distributed transaction: Try-Confirm&#x2F;Cancel (TC&#x2F;C)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Distributed-transaction-Saga"><span class="toc-number">3.3.4.</span> <span class="toc-text">Distributed transaction: Saga</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event-sourcing"><span class="toc-number">3.4.</span> <span class="toc-text">Event sourcing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Background"><span class="toc-number">3.4.1.</span> <span class="toc-text">Background</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Definition"><span class="toc-number">3.4.2.</span> <span class="toc-text">Definition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Wallet-service-example"><span class="toc-number">3.4.3.</span> <span class="toc-text">Wallet service example</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reproducibility"><span class="toc-number">3.4.4.</span> <span class="toc-text">Reproducibility</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Command-query-responsibility-segregation-CQRS"><span class="toc-number">3.4.5.</span> <span class="toc-text">Command-query responsibility segregation (CQRS)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-3-Design-Deep-Dive"><span class="toc-number">4.</span> <span class="toc-text">Step 3 - Design Deep Dive</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/hayoung-song-9523b61bb/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">9944</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">191</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">59</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[ByteByteGo] Digital Wallet</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-01-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/Byte-Byte-Go/">Byte Byte Go</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3.7k</span><span class="post-meta__separator">|</span><span>Reading time: 23 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Digital-Wallet"><a href="#Digital-Wallet" class="headerlink" title="Digital Wallet"></a>Digital Wallet</h2><span id="more"></span>
<p>결제 플랫폼은 일반적으로 고객에게 디지털 지갑 서비스를 제공해 고객이 지갑에 돈을 저장하고 나중에 사용할 수 있도록 한다. 예를 들어, 은행 카드에서 디지털 지갑에 돈을 추가하고 온라인에서 제품을 구매할 때 지갑에 있는 돈으로 결제할 수 있는 옵션이 제공된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101215221491.png" alt=""></p>
<p>디지털 지갑이 제공하는 기능은 돈을 쓰는 것만이 아니다. PayPal과 같은 결제 플랫폼의 경우, 같은 결제 플랫폼에 있는 다른 사람의 지갑으로 직접 돈을 이체할 수도 있다. 은행 간 이체에 비해 디지털 지갑 간 직접 이체는 더 빠르며, 가장 중요한 것은 일반적으로 추가 수수료가 부과되지 않는다는 점이다. 아래는 지갑 간 잔액 이체 작업을 보여준다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101215317954.png" alt=""></p>
<p>지갑 간 잔액 이체 작업을 지원하는 디지털 지갑 애플리케이션의 설계를 살펴보자.</p>
<h2 id="Step-1-Understand-the-Problem-and-Establish-Design-Scope"><a href="#Step-1-Understand-the-Problem-and-Establish-Design-Scope" class="headerlink" title="Step 1 - Understand the Problem and Establish Design Scope"></a>Step 1 - Understand the Problem and Establish Design Scope</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Candidate: Should we only focus on balance transfer operations between two digital wallets? Do we need to worry about other features?</span><br><span class="line">Interviewer: Let’s focus on balance transfer operations only.</span><br><span class="line"></span><br><span class="line">Candidate: How many transactions per second (TPS) does the system need to support?</span><br><span class="line">Interviewer: Let’s assume 1,000,000 TPS.</span><br><span class="line"></span><br><span class="line">Candidate: A digital wallet has strict requirements for correctness. Can we assume transactional guarantees are sufficient?</span><br><span class="line">Interviewer: That sounds good.</span><br><span class="line"></span><br><span class="line">Candidate: Do we need to prove correctness?</span><br><span class="line">Interviewer: This is a good question. Correctness is usually only verifiable after a transaction is complete. One way to verify is to compare our internal records with statements from banks. The limitation of reconciliation is that it only shows discrepancies and cannot tell how a difference was generated. Therefore, we would like to design a system with reproducibility, meaning we could always reconstruct historical balance by replaying the data from the very beginning.</span><br><span class="line"></span><br><span class="line">Candidate: Can we assume the availability requirement is 99.99%</span><br><span class="line">Interviewer: Sounds good.</span><br><span class="line"></span><br><span class="line">Candidate: Do we need to take foreign exchange into consideration?</span><br><span class="line">Interviewer: No, it’s out of scope.</span><br></pre></td></tr></table></figure>
<h3 id="Functional-Requirements"><a href="#Functional-Requirements" class="headerlink" title="Functional Requirements"></a>Functional Requirements</h3><ul>
<li>두 디지털 지갑 간의 잔액 이체 작업 지원</li>
<li>1,000,000 TPS 지원</li>
<li>99.99% 이상의 안정성</li>
<li>트랜잭션 지원</li>
<li>재현성 지원</li>
</ul>
<h3 id="Back-of-the-envelope-estimation"><a href="#Back-of-the-envelope-estimation" class="headerlink" title="Back-of-the-envelope estimation"></a>Back-of-the-envelope estimation</h3><p>TPS에 대해 이야기할 때 트랜잭션 데이터베이스가 사용된다는 것을 의미한다. 오늘날 일반적인 데이터센터 노드에서 실행되는 관계형 데이터베이스는 초당 수천 건의 트랜잭션을 지원할 수 있다. 데이터베이스 노드가 1,000 TPS를 지원할 수 있다고 가정해보자. 1M TPS에 도달하려면 1000개의 데이터베이스 노드가 필요하다.</p>
<p>그러나 이 계산은 약간 부정확하다. 각 이체 명령에는 한 계좌에서 돈을 공제하고 다른 계좌에서 돈을 입금하는 두 가지 작업이 포함되기 때문에 초당 1M의 이체를 지원하려면 2M TPS를 처리해야 하며 이는 2000개의 노드가 필요하다는 의미다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Per-node TPS</th>
<th style="text-align:left">Node Number</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">100</td>
<td style="text-align:left">20,000</td>
</tr>
<tr>
<td style="text-align:left">1,000</td>
<td style="text-align:left">2,000</td>
</tr>
<tr>
<td style="text-align:left">10,000</td>
<td style="text-align:left">200</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Step-2-Propose-High-Level-Design-and-Get-Buy-In"><a href="#Step-2-Propose-High-Level-Design-and-Get-Buy-In" class="headerlink" title="Step 2 - Propose High-Level Design and Get Buy-In"></a>Step 2 - Propose High-Level Design and Get Buy-In</h2><h3 id="API-Design"><a href="#API-Design" class="headerlink" title="API Design"></a>API Design</h3><p>RESTful API 컨벤션을 사용한다. 우리는 하나의 API만 지원하면 된다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>API</strong></th>
<th style="text-align:left"><strong>Detail</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">POST /v1/wallet/balance_transfer</td>
<td style="text-align:left">Transfer balance from one wallet to another</td>
</tr>
</tbody>
</table>
</div>
<p>요청 매개변수는 다음과 같다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Field</strong></th>
<th style="text-align:left"><strong>Description</strong></th>
<th style="text-align:left"><strong>Type</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">from_account</td>
<td style="text-align:left">The debit account</td>
<td style="text-align:left">string</td>
</tr>
<tr>
<td style="text-align:left">to_account</td>
<td style="text-align:left">The credit account</td>
<td style="text-align:left">string</td>
</tr>
<tr>
<td style="text-align:left">amount</td>
<td style="text-align:left">The amount of money</td>
<td style="text-align:left">string</td>
</tr>
<tr>
<td style="text-align:left">currency</td>
<td style="text-align:left">The currency type</td>
<td style="text-align:left">string (ISO 4217 [3])</td>
</tr>
<tr>
<td style="text-align:left">transaction_id</td>
<td style="text-align:left">ID used for deduplication</td>
<td style="text-align:left">uuid</td>
</tr>
</tbody>
</table>
</div>
<p>응답은 다음과 같다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Status&quot;: &quot;success&quot;</span><br><span class="line">  &quot;Transaction_id&quot;: &quot;01589980-2664-11ec-9621-0242ac130002&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>한 가지 언급할 만한 점은 “금액” 필드의 데이터 유형이 <code>double</code>이 아닌 <code>string</code> 이라는 점이다. 실제로는 거의 모든 프로그래밍 언어와 데이터베이스에서 지원되기 때문에 여전히 많은 사람들이 float나 double을 사용한다. 정밀도를 잃을 수 있는 잠재적 위험을 이해한다면 이는 적절한 선택이다.</p>
<h3 id="In-memory-sharding-solution"><a href="#In-memory-sharding-solution" class="headerlink" title="In-memory sharding solution"></a>In-memory sharding solution</h3><p>지갑 애플리케이션은 모든 사용자 계정에 대한 계정 잔액을 유지한다. 이 <user, balance> 관계를 나타내는 좋은 데이터 구조는 해시 테이블(map) 또는 KV Store라고 하는 map이다.</p>
<p>인메모리 저장소의 경우 redis가 많이 사용된다. Redis 노드 하나만으로는 1M TPS를 처리하기 충분하지 않다. Redis 노드 클러스터를 설정하고 사용자 계정을 균등히 분산시켜야 한다. 이 과정을 파티셔닝 또는 샤딩이라 한다.</p>
<p>KV 데이터를 N개의 파티션에 분산하려면 키의 해시값을 계산한 후 이를 N으로 나누고 나머지가 파티션의 대상이다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String accountID = &quot;A&quot;;</span><br><span class="line">Int partitionNumber = 7;</span><br><span class="line">Int myPartition = accountID.hashCode() % partitionNumber;</span><br></pre></td></tr></table></figure>
<p>모든 Redis 노드의 파티션 수와 주소는 중앙 집중화된 곳에 저장할 수 있다. 가용성이 높은 config storage 솔루션으로 Zookeeper를 사용할 수 있다. 이 솔루션의 마지막 구성 요소는 이체 명령을 처리하는 서비스다. 지갑 서비스라고 부르는 이 서비스는 몇 가지 핵심적인 역할을 수행한다.</p>
<ol>
<li>이체 명령 수신</li>
<li>이체 명령의 유효성 검사</li>
<li>명령이 유효하면 이체와 관련된 두 사용자의 계정 잔액을 업데이트한다. 클러스터에서 계정 잔액은 서로 다른 Redis 노드에 있을 수 있다.</li>
</ol>
<p>지갑 서비스는 stateless다. 수평적 확장이 용우하다. 아래는 인메모리 솔루션을 보여준다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101220414624.png" alt=""></p>
<p>이 예제에는 3개의 Redis 노드가 있다. A,B,C 라는 세명의 클라이언트가 있으며, 이들의 계정 잔액은 이 세 개의 Redis 노드에 고르게 분산되어 있다. 이 예시에는 잔액 이체 요청을 처리하는 지갑 서비스 노드가 두 개 있다. 지갑 서비스 노드 중 하나가 클라이언트 A에서 클라이언트 B로 1을 이체하라는 전송 명령을 받으면 두 개의 Redis 노드에 두 개의 명령을 내린다. 클라이언트 A의 잔액이 포함된 Redis 노드의 경우, 지갑 서비스는 계정에서 1을 차감한다. 클라이언트 B의 경우, 지갑 서비스는 계정에 1달러를 더한다.</p>
<p><strong>Candidate</strong>: 이 설계에서는 계정 잔액이 여러 Redis 노드에 분산된다. 주키퍼는 샤딩 정보를 유지하는데 사용된다. Stateless 지갑 서비스는 샤딩 정보를 사용해 클라이언트를 위한 Redis 노드를 찾고 그에 따라 계정 잔액을 업데이트 한다.</p>
<p><strong>Interviewer</strong>: 이 설계는 작동하지만 정확성 요구사항을 충족하지 못한다. 지갑 서비스는 송금할 때마다 두 개의 Redis 노드를 업데이트한다. 두 업데이트가 모두 성공한다는 보장은 없다. 예를 들어 첫 번째 업데이트가 완료된 후 두 번째 업데이트가 완료되기 전에 지갑 서비스 노드가 충돌하면 불완전한 이체가 발생한다. 두 업데이트는 하나의 atomic 트랜잭션에 포함되어야 한다.</p>
<h3 id="Distributed-transactions"><a href="#Distributed-transactions" class="headerlink" title="Distributed transactions"></a>Distributed transactions</h3><h4 id="Database-sharding"><a href="#Database-sharding" class="headerlink" title="Database sharding"></a>Database sharding</h4><p>서로 다른 두 스토리지 노드에 대한 업데이트를 원자적으로 수행하려면 어떻게 해야할까? 첫 번째 단계는 각 Redis 노드를 트랜잭션 관계형 데이터베이스 노드로 교체하는 것이다. 아래는 아키텍처를 보여준다. 이번에는 클라이언트 A, B, C가 3개의 Redis 노드가 아닌 3개의 관계형 데이터베이스로 분할된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101221202999.png" alt=""></p>
<p>트랜잯녀 데이터베이스를 사용하면 문제의 일부만 해결할 수 있다. 마지막 섹션에서 언급했듯이 하나의 이전 명령으로 서로 다른 두 데이터베이스에 있는 두 계정을 업데이트해야 할 가능성이 매우 높다. 두 개의 업데이트 작업이 정확히 동시에 처리된다는 보장은 없다. 첫 번째 계정 잔액을 업데이트한 후 지갑 서비스가 다시 시작되었다면 두 번째 계정도 업데이트될지 어떻게 확인할 수 있을까?</p>
<h4 id="Distributed-transaction-two-phase-commit"><a href="#Distributed-transaction-two-phase-commit" class="headerlink" title="Distributed transaction: two-phase commit"></a>Distributed transaction: two-phase commit</h4><p>분산 시스템에서 트랜잭션은 여러 노드에서 여러 프로세스를 포함할 수 있다. 트랜잭션을 원자적으로 만들려면 분산 트랜잭션이 해답이 될 수 있다. 분산 트랜잭션을 구현하는 방법에는 저수준 솔루션과 고수준 솔루션의 두 가지가 있다. 각각을 살펴보자.</p>
<p>저수준 솔루션은 데이터베이스 자체에 의존한다. 가장 일반적으로 사용되는 알고리즘은 2PC다. </p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101221417707.png" alt=""></p>
<ol>
<li>코디네이터는 정상적으로 여러 데이터베이스에 대한 읽기 및 쓰기 작업을 수행한다. 아래서 볼 수 있듯이 데이터베이스 A와 C는 모두 잠겨있다.</li>
<li>애플리케이션이 트랜잭션을 커밋하려고 할 때 코디네이터는 모든 데이터베이스에 트랜잭션을 준비하도록 요청한다.</li>
<li>두 번째 단계에서 코디네이터는 모든 데이터베이스에서 응답을 수집하고 다음을 수행한다.<ol>
<li>모든 데이터베이스가 “yes”라고 응답하면 코디네이터는 모든 데이터베이스에 수신한 트랜잭션을 커밋하도록 요청한다.</li>
<li>어떤 데이터베이스가 “no”로 응답하면 코디네이터는 모든 데이터베이스에 트랜잭션을 중단하도록 요청한다.</li>
</ol>
</li>
</ol>
<p>준비 단계에서는 데이터베이스 트랜잭션에 특별한 수정이 필요하기 때문에 저수준 솔루션이다. 예를 들어, 2PC를 달성하기 위해 이기종 데이터베이스를 조정하는 X/Open XA 표준이 있다. 2PC의 가장 큰 문제점은 다른 노드의 메세지를 기다리는 동안 잠금이 매우 오랫동안 유지될 수 있기 때문에 성능이 좋지 않다는 점이다. 2PC의 또다른 문제는 아래서 볼 수 있듯이 코디네이터가 단일 장애 지점이 될 수 있다는 점이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101221719741.png" alt=""></p>
<h4 id="Distributed-transaction-Try-Confirm-Cancel-TC-C"><a href="#Distributed-transaction-Try-Confirm-Cancel-TC-C" class="headerlink" title="Distributed transaction: Try-Confirm/Cancel (TC/C)"></a>Distributed transaction: Try-Confirm/Cancel (TC/C)</h4><p>TCC는 두 단계로 구성된 보상 트랜잭션의 한 유형이다.</p>
<ol>
<li>첫 번째 단계에서는 코디네이터가 모든 데이터베이스에 트랜잭션을 위한 리소스를 예약하도록 요청한다.</li>
<li>두 번째 단계에서는 코디네이터가 모든 데이터베이스에서 응답을 수집한다.<ol>
<li>모든 데이터베이스가 “yes”로 응답하면 코디네이터는 모든 데이터베이스에 작업을 확인하도록 요청하는데, 이게 Try-Confirm 프로세스다.</li>
<li>어떤 데이터베이스가 “no”로 응답하면 코디네티어는 모든 데이터베이스에 작업 취소를 요청하는 Try-Cancel 프로세스를 수행한다.</li>
</ol>
</li>
</ol>
<p>2PC의 두 단계는 동일한 트랜잭션으로 묶여있지만 TCC에서는 각 단계가 별도의 트랜잭션이라는 점에 유의해야 한다.</p>
<p><strong>TC/C example</strong></p>
<p>A 계좌에서 C 계좌로 1달러를 이체한다고 가정해보자. 아래는 각 단계에서 TCC가 어떻게 실행되는지 요약한 것이다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Phase</th>
<th style="text-align:left">Operation</th>
<th style="text-align:left">A</th>
<th style="text-align:left">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Try</td>
<td style="text-align:left">Balance change: -$1</td>
<td style="text-align:left">Do nothing</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">Confirm</td>
<td style="text-align:left">Do nothing</td>
<td style="text-align:left">Balance change: +$1</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">Cancel</td>
<td style="text-align:left">Balance change: +$1</td>
<td style="text-align:left">Do Nothing</td>
</tr>
</tbody>
</table>
</div>
<p>지갑 서비스가 TCC의 코디네이터라고 가정해보자. 분산 트랜잭션이 시작될 때 계정 A의 잔액은 1이고 계정 C의 잔액은 0이다.</p>
<p><strong>First phase: Try</strong></p>
<p>Try 단계에서 코디네이터 역할을 하는 지갑 서비스는 두 개의 트랜잭션 명령을 두 개의 데이터베이스로 보낸다.</p>
<ol>
<li>계정 A가 포함된 데이터베이스의 경우, 코디네이터는 A의 잔액을 1달러 감소시키는 로컬 트랜잭션을 시작한다.</li>
<li>계정 C가 포함된 데이터베이스에 대해 코디네이터는 NOP(no operation)을 반환한다. 이 예제를 다른 시나리오에 적용할 수 있도록 코디네이터가 이 데이터베이스에 NOP 명령을 보낸다고 가정해보자. 데이터베이스는 NOP 명령에 대해 아무 작업도 수행하지 않고 항상 코디네이터에게 성공 메세지로 응답한다.</li>
</ol>
<p>Try 단계는 아래 나와있다. 굵은 선은 트랜잭션에 의해 잠금이 유지되고 있음을 나타낸다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101222305360.png" alt=""></p>
<p><strong>Second phase: Confirm</strong></p>
<p>두 데이터베이스가 모두 “yes”라고 응답하면 지갑 서비스는 다음 확인 단계를 시작한다.</p>
<p>계정 A의 잔액은 첫 번째 단계에서 이미 업데이트가 되었다. 지갑 서비스는 잔액을 변경할 필요가 없다. 그러나 계정 C는 첫 번째 단계에서 계정 A로부터 아직 1을 받지 못했다. Confirm 단계에서 지갑 서비스는 계정 C의 잔액에 1을 추가해야 한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101222454751.png" alt=""></p>
<p><strong>Second phase: Cancel</strong></p>
<p>첫 번째 Try 단계가 실패하면 어떻게 해야 할까? 위 에서는 계정 C에 대한 NOP 작업이 항상 성공한다고 가정했지만 실제로는 실패할 수도 있다. 예를 들어 C 계정은 불법 계쩡일 수 있으며 규제 당국은 이 계정으로 자금이 유입되거나 유출될 수 없도록 규정하고 있다. 이 경우 분산된 트랜잭션을 취소하고 정리해야 한다.</p>
<p>Try 단계의 트랜잭션에서 계정 A의 잔액이 이미 업데이트 되었기 때문에 지갑 서비스에서 완료된 트랜잭션을 취소하는 것은 불가능하다. 할 수 있는 일은 Try 단계의 트랜잭션 효과를 되돌릴 수 있는 다른 트랜잭션을 시작하는 것, 즉 계정 A에 1달러를 다시 추가하는 것이다.</p>
<p>Try 단계에서 계정 C가 업데이트되지 않았기 때문에 지갑 서비스는 계정 C의 데이터베이스에 NOP 작업을 전송하기만 하면 된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101222729080.png" alt=""></p>
<p><strong>Comparison between 2PC and TC/C</strong></p>
<p>아래는 2PC와 TCC를 비교한 표다. 2PC에서는 두 번째 단계가 시작될 때 모든 로컬 트랜잭션이 완료되지 않고(still locked) TCC에서는 두 번째 단계가 시작될 때 모든 로컬 트랜잭션이 완료된다(unlocked). 즉 2PC의 두 번째 단계는 중단 또는 커밋과 같이 완료되지 않은 트랜잭션을 완료하는 것이고, TCC의 두 번째 단계는 오류가 발생했을 때 이전 트랜잭션 결과를 상쇄하기 위해 역방향 연산을 사용하는 것이다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong> First Phase</strong></th>
<th><strong>Second Phase: success</strong></th>
<th><strong>Second Phase: fail</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>2PC</td>
<td>Local transactions are not done yet</td>
<td>Commit all local transactions Cancel all local transactions</td>
<td>Cancel all local transactions</td>
</tr>
<tr>
<td>TC/C</td>
<td>All local transactions are completed, either committed or canceled</td>
<td>Execute new local transactions if needed</td>
<td>Reverse the side effect of the already committed transaction, or called “undo”</td>
</tr>
</tbody>
</table>
</div>
<p>TCC는 보상에 의한 분산 트랜잭션이라고도 한다. “실행 취소”라고 하는 보상이 비즈니스 로직에서 구현되기 때문에 고수준 솔루션이다. 이 접근 방식의 장점은 데이터베이스에 구애받지 않는다는 것이다. 데이터베이스가 트랜잭션을 지원하는 한 TCC는 작동한다. 단점은 애플리케이션 계층의 비즈니스 로직에서 세부 사항을 관리하고 분산된 트랜잭션의 복잡성을 처리해야 한다는 것이다.</p>
<p><strong>Phase status table</strong></p>
<p>우리는 앞서 질문한 TCC 도중 지갑 서비스가 다시 시작되면 어떻게 되는지에 대해 답을 못했다. 서비스가 다시 시작되면 이전의 모든 작업 기록이 손실될 수 있으며, 시스템에서 복구 방법을 모를 수도 있다.</p>
<p>해결책은 간단하다. TCC의 진행 상황을 트랜잭션 데이터베이스에 phase status 상태로 저장하면 된다. Phase status에는 최소한 다음 정보가 포함된다.</p>
<ul>
<li>분산 트랜잭션의 ID와 콘텐츠</li>
<li>각 데이터베이스의 Try 단계 상태. 상태는 “not sent yet”, “has been sent”, “response received”가 될 수 있다.</li>
<li>두 번째 단계의 이름. “Confirm” 또는 “Cancel”이 될 수 있다. Try 단계의 결과를 사용해 계산할 수 있다.</li>
<li>두 번째 단계의 상태</li>
<li>Out-of-order flag</li>
</ul>
<p>Phase status 테이블은 어디에 두어야 할까? 일반적으로 phase status는 돈이 차감되는 지갑 계정에 포함된 데이터베이스에 저장한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101224013832.png" alt=""></p>
<p><strong>Unbalanced state</strong></p>
<p>Try 단계가 끝날 때 아래 다이어그램에서 1$가 누락된 것을 볼 수 있다.</p>
<p>모든 것이 순조롭게 진행되었다고 가정하면 Try 단계가 끝날 때 계정 A에서 1달러가 차감되고 계정 C는 그대로 유지된다. A와 C의 계정 잔액 합계는 0이 되며 이는 TCC 시작 시점보다 적다. 이는 트랜잭션 후 금액이 동일하게 유지되어야 한다는 회계의 기본 규칙을 위반하는 것이다.</p>
<p>좋은 소식은 트랜잭션 보증이 TCC에 의해 여전히 유지된다는 것이다. TCC는 여러 개의 독립적인 로컬 트랜잭션으로 구성된다. TCC는 애플리케이션에 의해 구동되기 때문에 애플리케이션 자체에서 이런 로컬 트랜잭션 사이의 중간 결과를 확인할 수 있다. 반면, 데이터베이스 트랜잭션 또는 2PC 버전의 분산 트랜잭션은 상위 수준의 애플리케이션에는 보이지 않는 데이터베이스에 의해 유지관리된다.</p>
<p>분산 트랜잭션을 실행하는 동안에는 항상 데이터 불일치가 발생한다. 데이터베이스와 같은 하위 시스템에서 이미 불일치를 수정했기 때문에 불일치가 투명하게 드러날 수도 있다. 그렇지 않은 경우 우리가 직접 처리해야 한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101224429456.png" alt=""></p>
<p><strong>Valid operation orders</strong></p>
<p>Try 단계에서는 3가지 선택지가 있다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Try phase choices</th>
<th style="text-align:left">Account A</th>
<th style="text-align:left">Account C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Choice 1</td>
<td style="text-align:left">-$1</td>
<td style="text-align:left">NOP</td>
</tr>
<tr>
<td style="text-align:left">Choice 2</td>
<td style="text-align:left">NOP</td>
<td style="text-align:left">+$1</td>
</tr>
<tr>
<td style="text-align:left">Choice 3</td>
<td style="text-align:left">-$1</td>
<td style="text-align:left">+$1</td>
</tr>
</tbody>
</table>
</div>
<p>세 가지 선택지 모두 그럴듯해 보이지만, 일부는 유효하지 않다.</p>
<p>선택지 2의 경우 계정 C에서 Try 단계가 성공했지만 계정 A에서 실패한 경우(NOP) 지갑 서비스는 취소 단계로 진입해야 한다. 다른 사람이 개입해 계정 C에서 1을 옮길 가능성이 있다. 나중에 지갑 서비스가 계정 C에서 1을 차감하려고 하면 아무것도 남지 않은 것을 발견하게 되며, 이는 분산 트랜잭션의 트랜잭션 보증을 위반하는 것이다.</p>
<p>선택지 3의 경우 계정 A에서 1을 차감하고 동시에 계정 C에 추가하면 많은 문제가 발생한다. 예를 들어 1이 계정 C에 추가되었지만 계정 A에서 돈을 공제하지 못했다. 이 경우 어떻게 해야할까?</p>
<p>따라서 선택지 2와 선택지 3은 잘못된 선택이며 선택지 1만 유효하다.</p>
<p><strong>Out-of-order execution</strong></p>
<p>TCC의 한 가지 부작용은 순서를 벗어난 실행이다. 예제를 사용하면 훨씬 쉽게 설명할 수 있다. 아래서 볼 수 있듯이 계정 A에서 계정 C로 1달러를 이체하는 위의 예시를 다시 사용한다. Try 단계에서 계정 A에 대한 작업이 실패하면 지갑 서비스에 실패를 반환하고 지갑 서비스는 취소 단계로 진입해 계정 A와 계정 C 모두에 취소 작업을 보낸다.</p>
<p>계정 C를 처리하는 데이터베이스에 네트워크 문제가 발생하여 Try 명령보다 먼저 취소 명령을 받는다고 가정해보자. 이 경우 취소할 것이 없다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101225009786.png" alt=""></p>
<p>순서가 맞지 않는 작업을 처리하기 위해 각 노드는 다음과 같은 업데이트로 기존 로직을 개선해 Try 명령을 받지 않고도 TCC를 취소할 수 있다.</p>
<ul>
<li><p>순서가 맞지 않는 취소 연산은 데이터베이스에 취소 연산은 보았지만 아직 Try 연산은 보지 못했음을 나타내는 플래그를 남긴다.</p>
</li>
<li><p>Try 작업은 항상 out-of-order 플래그가 있는지 여부를 확인하고 플래그가 있는 경우 실패를 반환하도록 개선한다.</p>
</li>
</ul>
<p>이것이 바로 “Phase Status Table” 섹션의 phase status table에 out-of-order 플래그를 추가한 이유다.</p>
<h4 id="Distributed-transaction-Saga"><a href="#Distributed-transaction-Saga" class="headerlink" title="Distributed transaction: Saga"></a>Distributed transaction: Saga</h4><p><strong>Linear order execution</strong></p>
<p>Saga라는 또 다른 인기 있는 분산 트랜잭션 솔루션이 있다. Saga는 마이크로 서비스 아키텍처의 사실상의 표준이다. Saga의 개념은 간단하다.</p>
<ol>
<li>모든 작업이 순서대로 정렬된다. 각 작업은 자체 데이터베이스에서 독립적인 트랜잭션이다.</li>
<li>작업은 첫 번째 작업부터 마지막 작업까지 실행된다. 한 작업이 완료되면 다음 작업이 트리거된다.</li>
<li>작업이 실패하면 전체 프로세스는 보상 트랜잭션을 사용해 현재 작업에서 첫 번째 작업으로 역순으로 롤백하기 시작한다. 따라서 분산 트랜잭션에 n개의 연산이 있는 경우, 정상적인 경우의 연산과 롤백 중 보상 트랜잭션에 대한 또 다른 연산, 즉 2n개의 연산을 준비해야 한다.</li>
</ol>
<p>예제를 사용하면 더 쉽게 이해할 수 있다. 아래는 계정 A에서 계정 C로 1달러를 이체하는 Saga 워크플로우를 보여준다. 상단 가로줄은 일반적인 실행 순서를 보여준다. 두 개의 세로선은 오류가 발생했을 때 시스템이 수행해야 하는 작업을 보여준다. 오류가 발생하면 이체 작업이 롤백되고 클라이언트를 오류 메세지를 받게 된다. “Valid operation orders” 섹션에서 언급했듯이 더하기 연산보다 빼기 연산을 먼저 수행해야 한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101225521896.png" alt=""></p>
<p>연산을 조율하는 방법에는 두 가지가 있다.</p>
<ol>
<li>Choreography. 마이크로서비스 아키텍처에서는 사가 분산 트랜잭션에 관련된 모든 서비스가 다른 서비스의 이벤트를 구독함으로써 작업을 수행한다. 따라서 완전히 탈중앙화된 조정이다.</li>
<li>Orchestration. 단일 코디네이터가 모든 서비스가 올바른 순서로 작업을 수행하도록 지시한다.</li>
</ol>
<p>어떤 코디네이션 모델을 사용할 지는 비즈니스 요구와 목표에 따라 결정된다. 코디네이션 솔루션의 문제점은 서비스가 완전히 비동기식으로 통신하기 때문에 각 서비스가 내부 상태 머신을 유지하여 다른 서비스가 이벤트를 발생시킬 때 수행해야 할 작업을 파악해야 한다는 것이다. 서비스가 많으면 관리가 어려워질 수 있다. 오케스트레이션 솔루션은 복잡성을 잘 처리하므로 일반적으로 디지털 지갑 시스템에서 선호되는 솔루션이다.</p>
<p><strong>Comparison between TC/C and Saga</strong></p>
<p>TCC와 Saga는 모두 어플리케이션 레벨의 분산 트랜잭션이다. 아래는 둘의 차이를 표로 정리했다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">TC/C</th>
<th style="text-align:left">Saga</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Compensating action</td>
<td style="text-align:left">In Cancel phase</td>
<td style="text-align:left">In rollback phase</td>
</tr>
<tr>
<td style="text-align:left">Central coordination</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes (orchestration mode)</td>
</tr>
<tr>
<td style="text-align:left">Operation execution order</td>
<td style="text-align:left">any</td>
<td style="text-align:left">linear</td>
</tr>
<tr>
<td style="text-align:left">Parallel execution possibility</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">No (linear execution)</td>
</tr>
<tr>
<td style="text-align:left">Could see the partial inconsistent status</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">Application or database logic</td>
<td style="text-align:left">Application</td>
<td style="text-align:left">Application</td>
</tr>
</tbody>
</table>
</div>
<p>실제로 어떤 것을 사용해야 할까? 답은 지연 시간 요구 사항에 따라 달라진다. Saga의 작업은 선형 순서로 실행해야 하지만 TCC에서는 병렬로 실행할 수 있다. 따라서 결정은 몇 가지 요인에 따라 달라진다.</p>
<p>지연 시간이 필요하지 않거나 송금 예시 처럼 서비스가 거의 없는 경우에는 둘중 하나를 선택할 수 있다. 마이크로서비스 아키텍처의 트랜드를 따르고 싶다면 Saga를 선택하면 된다.</p>
<p>지연 시간에 민감하고 많은 서비스 / 연산을 포함하는 시스템이라면 TCC가 더 나은 옵션일 수 있다. </p>
<p><strong>Candidate</strong>: 잔액 이체를 트랜잭션으로 처리하기 위해 Redis를 관계형 데이터베이스로 대체하고, 분산 트랜잭션을 구현하기 위해 TCC 또는 Saga를 사용한다.</p>
<p><strong>Interviewer</strong>: 분산 트랜잭션 솔루션은 작동하지만 제대로 작동하지 않는 경우가 있을 수 있다. 예를 들어 사용자가 애플리케이션 수준에서 잘못된 연산을 입력할 수 있다. 이 경우 우리가 지정한 금액이 잘못되었을 수 있다. 문제의 근본 원인을 역추적하고 모든 계정 작업을 감사할 수 있는 방법이 필요하다.</p>
<h3 id="Event-sourcing"><a href="#Event-sourcing" class="headerlink" title="Event sourcing"></a>Event sourcing</h3><h4 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h4><p>실생활에서 디지털 지갑 제공업체는 감사를 받을 수 있다. 외부 감사인은 예를 들어 몇 가지 까다로운 질문을 할 수 있다.</p>
<ol>
<li>특정 시점의 계정 잔액을 알고 있는가?</li>
<li>과거 계정 잔액과 현재 계정 잔액이 정확한지 어떻게 알 수 있는가?</li>
<li>코드 변경 후 시스템 로직이 정확하다는 것을 어떻게 증명할 수 있는가?</li>
</ol>
<p>이런 질문에 체계적으로 답할 수 있는 설계 철학 중 하나가 DDD에서 개발된 기법인 이벤트 소싱이다.</p>
<h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>이벤트 소싱에는 4가지 핵심이 있다.</p>
<ul>
<li>Command</li>
<li>Event</li>
<li>State</li>
<li>State machine</li>
</ul>
<p><strong>Command</strong></p>
<p>명령은 외부에서 의도한 동작을 의미한다. 예를 들어 고객 A에서 고객 C로 1달러를 송금하려는 경우 이 송금 요청은 명령이다.</p>
<p>이벤트 소싱에서는 모든 것이 순서를 갖는 것이 매우 중요하다. 따라서 명령은 일반적으로 FIFO 대기열에 넣는다.</p>
<p><strong>Event</strong></p>
<p>일부 명령은 유효하지 않아 실행되지 않을 수 있으므로 명령은 의도가 아니라 사실이다. 예를 들어, 이체 후 계정 잔액이 마이너스가 되면 이체 작업은 실패한다.</p>
<p>명령은 어떤 조치를 취하기 전에 반드시 유효성 검사를 거쳐야 한다. 명령이 유효성 검사를 통과하면 유효하며 반드시 실행되어야 한다. 이행 결과를 이벤트라고 한다.</p>
<p>명령과 이벤트에는 크게 두 가지 차이점이 있다.</p>
<ol>
<li>이벤트는 검증된 사실을 나타내므로 반드시 실행되어야 한다. 실제로는 보통 이벤트에 과거 시제를 사용한다. 명령이 “1을 A에서 C로 전송”인 경우, 이벤트는 “1을 A에서 C로 전송했다”가 된다.</li>
<li>명령은 무작위성이나 입출력을 포함할 수 있지만 이벤트는 결정론적이여야 한다. 이벤트는 역사적 사실을 나타낸다.</li>
</ol>
<p>이벤트 생성 과정에는 두 가지 중요한 특성이 있다.</p>
<ol>
<li>하나의 명령은 여러 개의 이벤트를 생성할 수 있다. 0개 이상의 이벤트를 생성할 수도 있다.</li>
<li>이벤트 생성에는 무작위성이 포함될 수 있으며, 이는 명령이 항상 동일한 이벤트를 생성한다는 보장이 없다는 것을 의미한다. 이벤트 생성에는 외부 I/O 또는 임의의 숫자가 포함될 수 있다.</li>
</ol>
<p>이벤트의 순서는 명령의 순서를 따라야 한다. 따라서 이벤트도 FIFO 큐에 저장된다.</p>
<p><strong>State</strong></p>
<p>상태는 이벤트가 적용될 때 변경되는 내용이다. 지갑 시스템에서 상태는 모든 클라이언트 계정의 잔액으로, map 데이터 구조로 나타낼 수 있다. 키는 계정 이름 또는 ID이고 값은 계정 잔액이다. KV 스토어는 일반적으로 이런 map 데이터를 저장하는데 사용된다. 관계형 데이터베이스도 KV 스토어로 볼 수 있는데 여기서 키는 기본 키이고 값은 테이블 행이다.</p>
<p><strong>State machine</strong></p>
<p>상태 머신은 이벤트 소싱 프로세스를 구동한다. 두 가지 주요 기능이 있다.</p>
<ol>
<li>명령의 유효성을 검사하고 이벤트를 생성한다.</li>
<li>이벤트를 적용해 상태를 업데이트 한다.</li>
</ol>
<p>이벤트 소싱을 위해서는 상태 머신의 동작이 결정론적이여야 한다. 따라서 상태 머신 자체에 임의성이 포함되어서는 안된다. 예를 들어 I/O를 사용해 외부에서 임의의 것을 읽거나 임의의 숫자를 사용해서는 안된다. 상태에 이벤트를 적용할 때는 항상 동일한 결과를 생성해야 한다.</p>
<p>아래는 이벤트 소싱 아키텍처의 static view를 보여준다. 상태 머신은 명령을 이벤트로 변환하고 이벤트를 적용하는 역하을 담당한다. 상태 머신에는 두 가지 주요 기능이 있기 때문에 일반적으로 명령의 유효성 검사를 위한 상태 머신과 이벤트 적용을 위한 상태 머신을 두 개씩 그려 넣는다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101231457636.png" alt=""></p>
<p>시간 차원을 추가하면 아래는 이벤트 소싱의 dynamic view를 보여준다. 시스템은 계속해서 명령을 수신하고 하나씩 처리한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101231530888.png" alt=""></p>
<h4 id="Wallet-service-example"><a href="#Wallet-service-example" class="headerlink" title="Wallet service example"></a>Wallet service example</h4><p>지갑 서비스의 경우 명령은 잔액 이체 요청이다. 이런 명령은 FIFO 대기열에 넣는다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101231613431.png" alt=""></p>
<p>상태(계정 잔액)가 관계형 데이터베이스에 저장되어 있다고 가정해보자. 상태 머신은 각 명령을 FIFO 순서로 하나씩 검사한다. 각 명령에 대해 계정에 충분한 잔액이 있는지 확인한다. 잔액이 충분하면 상태 머신은 각 계정에 대한 이벤트를 생성한다. 예를 들어 명령이 “A-&gt;1-&gt;C” 인 경우 상태 머신은 두 개의 이벤트를 생성한다. “A:-$1”, “C:+$1”</p>
<p>아래는 상태 머신의 작동 방식을 5단계로 보여준다.</p>
<ol>
<li>명령 대기열에서 명령을 읽는다.</li>
<li>데이터베이스에서 잔액 상태를 읽는다.</li>
<li>명령의 유효성을 검사한다. 유효하면 각 계정에 대해 두 개의 이벤트를 생성한다.</li>
<li>다음 이벤트를 읽는다.</li>
<li>데이터베이스에서 잔액을 업데이트해 이벤트를 적용한다.</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101231911249.png" alt=""></p>
<h4 id="Reproducibility"><a href="#Reproducibility" class="headerlink" title="Reproducibility"></a>Reproducibility</h4><p>이벤트 소싱이 다른 아키텍처에 비해 갖는 가장 중요한 장점은 재현성이다.</p>
<p>앞서 언급한 분산 트랜잭션 솔루션에서는 지갑 서비스가 업데이트된 계정 잔액(상태)을 데이터베이스에 저장한다. 계정 잔액이 변경된 이유를 알기 어렵다. 또한 업데이트 작업 중 과거 잔액 정보가 손실된다. 이벤트 소싱 설계에서는 모든 변경 사항을 변경 불가능한 기록으로 먼저 저장한다. 데이터베이스는 특정 시점의 잔액이 어떻게 보이는지에 대한 업데이트된 뷰로만 사용된다.</p>
<p>이벤트를 처음부터 다시 재생하면 언제든지 과거의 밸런스 상태를 재구성할 수 있다. 이벤트 목록은 불변이고 상태 머신 로직은 결정론적이기 때문에 각 리플레이에서 생성된 과거 상태가 동일하다는 것이 보장된다.</p>
<p>아래는 이벤트를 재생해 지갑 서비스의 상태를 재현하는 방법을 보여준다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101232134442.png" alt=""></p>
<p>재현성은 감사관이 섹션을 시작할때 물었던 어려운 질문에 답하는 데 도움이 된다.</p>
<ul>
<li>특정 시점의 계정 잔액을 알 수 있나요?<ul>
<li>처음부터 계쩡 잔액을 알고 싶은 시점까지 이벤트를 재생해 답을 찾을 수 있다.</li>
</ul>
</li>
<li>과거 계정 잔액과 현재 계정 잔액이 정확한지 어떻게 알 수 있나요?<ul>
<li>이벤트 목록에서 계정 잔액을 다시 계산해 계정 잔액의 정확성을 확인할 수 있다.</li>
</ul>
</li>
<li>코드 변경 후 시스템 로직이 정확하다는 것을 어떻게 증명할 수 있나요?<ul>
<li>이벤트에 대해 서로 다른 버전의 코드를 실행해 결과가 동일한지 확인할 수 있다.</li>
</ul>
</li>
</ul>
<p>감사 기능으로 인해 이벤트 소싱은 종종 지갑 서비스를 위한 사실상의 솔루션으로 선택된다.</p>
<h4 id="Command-query-responsibility-segregation-CQRS"><a href="#Command-query-responsibility-segregation-CQRS" class="headerlink" title="Command-query responsibility segregation (CQRS)"></a>Command-query responsibility segregation (CQRS)</h4><p>지금까지 우리는 한 계좌에서 다른 계좌로 돈을 효율적으로 이체할 수 있도록 지갑 서비스를 설계했다. 하지만 클라이언트는 여전히 계좌 잔액이 얼마인지 알 수 없다. 이벤트 소싱 프레임워크 외부에 있는 클라이언트가 상태를 알 수 있도록 상태(잔액 정보)를 게시할 수 있는 방법이 필요하다.</p>
<p>직관적으로 데이터베이스의 읽기 전용 복사본(과거 상태)를 만들어 외부와 공유할 수 있다. 이벤트 소싱은 약간 다른 방식으로 이 질문에 답한다.</p>
<p>이벤트 소싱은 상태(잔액 정보)를 게시하는 대신 모든 이벤트를 게시한다. 외부 세계는 사용자 정의된 상태를 자체적으로 재구성할 수 있다. 이런 설계 철학을 CQRS라고 한다.</p>
<p>CQRS에서는 상태의 쓰기 부분을 담당하는 하나의 상태 머신이 있지만, 상태의 뷰를 구축하는 읽기 전용 상태 머신이 다수 존재할 수 있다. 이런 뷰는 쿼리에 사용될 수 있다.</p>
<p>이런 읽기 전용 상태 머신은 이벤트 큐에서 다양한 상태 표현을 도출할 수 있다. 예를 들어, 클라이언트가 잔액을 알고 싶어할 경우 읽기 전용 상태 머신이 데이터베이스에 상태를 저장해 잔액 쿼리를 처리할 수 있다. 또 다른 상태 머신은 특정 기간 동안의 상태를 구축해 이중 청구 가능성과 같은 문제를 조사하는 데 도움을 줄 수 있다. 상태 정보는 재무 기록을 조정하는데 도움이 될 수 있는 감사 추적 정보다.</p>
<p>읽기 전용 상태머신은 어느 정도 뒤처지지만 언제든 따라잡을 수 있다. 아키텍처 설계는 결국 일관성을 유지한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101232723716.png" alt=""></p>
<p><strong>Candidate</strong>: 이 설계에서는 이벤트 소싱 아키텍처를 사용해 전체 시스템을 재현하도록 한다. 모든 유효한 비즈니스 기록은 불변의 이벤트 대기열에 저장되어 정확성 검증에 사용될 수 있다.</p>
<p><strong>Interviewer</strong>: 하지만 제안한 이벤트 소싱 아키텍처는 한 번에 하나의 이벤트만 처리하고 여러 외부 시스템과 통신해야 한다. 더 빠르게 만들 수 있을까?</p>
<h2 id="Step-3-Design-Deep-Dive"><a href="#Step-3-Design-Deep-Dive" class="headerlink" title="Step 3 - Design Deep Dive"></a>Step 3 - Design Deep Dive</h2><!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2024/01/01/System%20Design/ByteByteGo/book/digital-wallet/">https://songhayoung.github.io/2024/01/01/System%20Design/ByteByteGo/book/digital-wallet/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2024 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>