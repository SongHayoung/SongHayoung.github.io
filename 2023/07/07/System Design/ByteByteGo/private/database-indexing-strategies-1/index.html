<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[ByteByteGo] Database Indexing Strategies"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[ByteByteGo] Database Indexing Strategies | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Database-Indexing-Strategies"><span class="toc-number">1.</span> <span class="toc-text">Database Indexing Strategies</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Basics-of-Indexing"><span class="toc-number">2.</span> <span class="toc-text">Basics of Indexing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Primer-on-B-Tree"><span class="toc-number">2.1.</span> <span class="toc-text">Primer on B+ Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Clustered-Index"><span class="toc-number">2.2.</span> <span class="toc-text">Clustered Index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Non-clustered-Index"><span class="toc-number">2.3.</span> <span class="toc-text">Non-clustered Index</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Understanding-Index-Types"><span class="toc-number">3.</span> <span class="toc-text">Understanding Index Types</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Primary-Index"><span class="toc-number">3.1.</span> <span class="toc-text">Primary Index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Secondary-Index"><span class="toc-number">3.2.</span> <span class="toc-text">Secondary Index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Composite-Index"><span class="toc-number">3.3.</span> <span class="toc-text">Composite Index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Covering-Index"><span class="toc-number">3.4.</span> <span class="toc-text">Covering Index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unique-Index"><span class="toc-number">3.5.</span> <span class="toc-text">Unique Index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Filtered-Index"><span class="toc-number">3.6.</span> <span class="toc-text">Filtered Index</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Specialized-Indexes"><span class="toc-number">4.</span> <span class="toc-text">Specialized Indexes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmap-Index"><span class="toc-number">4.1.</span> <span class="toc-text">Bitmap Index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spatial-Index"><span class="toc-number">4.2.</span> <span class="toc-text">Spatial Index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Full-text-Index"><span class="toc-number">4.3.</span> <span class="toc-text">Full-text Index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash-Index"><span class="toc-number">4.4.</span> <span class="toc-text">Hash Index</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/hayoung-song-9523b61bb/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">11034</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">196</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">62</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[ByteByteGo] Database Indexing Strategies</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-07-07</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/Byte-Byte-Go/">Byte Byte Go</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2.7k</span><span class="post-meta__separator">|</span><span>Reading time: 16 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Database-Indexing-Strategies"><a href="#Database-Indexing-Strategies" class="headerlink" title="Database Indexing Strategies"></a>Database Indexing Strategies</h2><span id="more"></span>
<p>이 포스트에서는 효과적인 데이터베이스 인덱싱 전략에 대해 알아본다. 데이터베이스 성능은 모든 대규모 데이터 기반 애플리케이션에 매우 중요하다. 잘못 설계된 인덱스와 인덱스 부족은 데이터베이스 애플리케이션 병목 현상의 주요 원인이다. 효율적인 인덱스 설계는 우수한 데이터베이스 및 애플리케이션 성능을 달성하는 데 매우 중요하다. 데이터베이스의 규모가 커짐에 따라 데이터를 검색하고 조작하는 효율적인 방법을 찾는 것이 점점 더 중요해지고 있다. 이러한 효율성을 달성하기 위해서는 잘 설계된 인덱싱 전략이 핵심이다. 이 문서에서는 인덱스 아키텍처에 대해 자세히 살펴보고 애플리케이션의 요구 사항을 충족하는 효과적인 인덱스를 설계하는데 도움이 되는 모범 사례에 대해 알아본다.</p>
<h2 id="Basics-of-Indexing"><a href="#Basics-of-Indexing" class="headerlink" title="Basics of Indexing"></a>Basics of Indexing</h2><p>데이터베이스에서 인덱싱의 기본부터 시작해보자. 인덱스는 책 끝에 있는 색인과 마찬가지로 데이터 검색 작업의 속도를 높여주는 데이터 구조다. 책 색인이 페이지 번호와 함께 키워드를 나열하여 정보를 빠르게 찾을 수 있도록 도와주는 것처럼, 데이터베이스 색인도 데이터베이스 테이블의 모든 행을 스캔할 필요 없이 데이터 검색 속도를 높여주는 비슷한 용도로 사용된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230707195119198.png" alt=""></p>
<p>데이터베이스 인덱스의 구조에는 정렬된 값 목록이 포함되며, 각 값은 해당 값이 있는 데이터 페이지로 연결되는 포인터에 연결된다. 인덱스 페이지는 이러한 체계적인 구조를 유지하여 특정 정보를 보다 효율적으로 찾을 수 있는 방법을 제공한다. 인덱스는 일반적으로 디스크에 저장된다. 인덱스는 데이터 검색 속도를 높이기 위해 테이블과 연결된다. 테이블의 하나 이상의 열에서 만들어진 키가 인덱스를 구성하며, 대부분의 관계형 데이터베이스의 경우 B+ 트리 구조로 저장된다. 이 구조를 통해 데이터베이스는 연관된 행을 효율적으로 찾을 수 있다.</p>
<p>데이터베이스에 적합한 인덱스를 찾는 것은 빠른 쿼리 응답과 업데이트 비용 사이의 균형을 맞추는 작업이다. 좁은 인덱스 또는 열 수가 적은 인덱스는 디스크 공간과 유지보수를 절약할 수 있으며, 넓은 인덱스는 광범위한 쿼리에 대응할 수 있다. 가장 효율적인 인덱스를 찾기 위해 여러 번의 설계 반복이 필요한 경우가 많다.</p>
<p>가장 간단한 형태로 인덱스는 정렬된 데이터 구조에서 이진 검색을 사용하여 <code>O(logN)</code> 시간 복잡도로 검색을 수행할 수 있는 정렬된 테이블이다. 인덱스를 구현하기 위해 B-Tree, 비트맵, 해시맵 등 다양한 데이터 구조가 사용될 수 있다. 이러한 모든 구조는 효율적인 데이터 엑세스를 제공하지만 구현 세부 사항은 다르다. 관계형 데이터베이스의 경우, 인덱스는 종종 B-Tree의 변형인 B+ 트리를 사용하여 구현된다.</p>
<h3 id="Primer-on-B-Tree"><a href="#Primer-on-B-Tree" class="headerlink" title="Primer on B+ Tree"></a>Primer on B+ Tree</h3><p>B+ 트리는 특정 유형의 트리 데이터 구조이며, 이를 이해하려면 이전 버전인 B-Tree에 대한 배경 지식이 필요하다. B-Tree, 즉 균형 트리는 정렬된 데이터를 유지하고 효율적인 데이터 삽입, 삭제, 및 검색 작업을 가능하게 하는 자체 균형 트리 데이터 구조다. 이러한 모든 작업은 <code>O(logN)</code> 시간 내에 수행할 수 있다. B-Tree의 구조는 다음과 같이 구분된다.</p>
<ul>
<li>모든 잎은 같은 레벨에 있으며, 이것이 바로 트리를 “균형 잡힌” 구조로 만드는 것이다.</li>
<li>루트를 제외한 모든 내부 노드는 d(트리의 최소 차수)에서 2d까지의 자식 수를 가진다. 그러나 루트에는 적어도 두 개의 자식이 있다.</li>
<li>자식이 “k”인 비-리프 노드에는 k-1개의 키가 포함된다. 즉 노드에 3개의 자식이 있는 경우(k=3) 각 자식 노드에 해당하는 데이터를 세 부분으로 분할하는 2개의 키(k-1)를 보유하게 된다.</li>
</ul>
<p>B-Tree는 디스크 엑세스 횟수를 최소화하는 설계로 인해 메인 메모리에 맞지 않는 데이터를 저장하는데 탁월한 데이터 구조다. 또한 모든 리프 노드가 동일한 깊이에 있는 균형 잡힌 트리이므로 조회 시간이 일관되고 예측 가능하다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230707195948436.png" alt=""></p>
<p>B+ 트리는 B-Tree의 변형으로 디스크 기반 스토리지 시스템, 특히 데이터베이스 인덱스에 널리 사용된다. B+트리에는 B 트리를 개선한 몇 가지 고유한 특성이 있다.</p>
<ul>
<li>B+ 트리에서는 데이터 포인트(실제 레코드에 대한 포인터)가 리프 노드에만 저장된다. 내부 노드에는 키와 다른 노드에 대한 포인터만 포함된다. 즉, 내부 노드에 더 많은 키를 저장할 수 있으므로 트리의 전체 높이가 줄어든다. 따라서 많은 작업에 필요한 디스크 엑세스 횟수가 줄어든다.</li>
<li>모든 리프 노드는 링크된 목록으로 서로 연결된다. 따라서 범위 쿼리가 효율적이다. 범위의 첫 번째 노드에 엑세스한 다음 링크된 목록을 따라 나머지 노드를 검색할 수 있다.</li>
<li>B+ 트리에서 모든 키는 내부 노드와 리프 노드에 한 번씩 두 번 나타난다. 내부 노드의 키는 원하는 값이 어느 하위 트리에 속할 수 있는지 결정하기 위한 분할점 역할을 한다.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230707200209222.png" alt=""></p>
<p>이러한 기능 덕분에 B+ 트리는 메인 메모리에 맞지 않는 대량의 데이터가 있는 시스템에 특히 적합하다. 리프 노드에서만 데이터에 엑세스할 수 있기 때문에 모든 조회에는 루트에서 리프까지 경로 탐색이 필요하다. 모든 데이터 엑세스 작업에는 일정한 시간이 걸린다. 이러한 예측 가능성 덕분에 B+ 트리는 데이터베이스 인덱싱을 위한 매력적인 선택이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230707200309747.png" alt=""></p>
<p>이제 B+ 트리가 인덱싱에 어떻게 사용되는지 이해했으니, 일반적인 데이터베이스 엔진에서 인덱스를 유지 관리하는데 어떻게 사용되는지 살펴보자.</p>
<h3 id="Clustered-Index"><a href="#Clustered-Index" class="headerlink" title="Clustered Index"></a>Clustered Index</h3><p>클러스터드 인덱스는 테이블의 레코드가 물리적으로 저장되는 방식을 재정렬한다. 행을 무작위로 또는 삽입된 순서대로 저장하지 않는다. 대신 인덱스의 순서에 맞게 정렬하므로 “클러스터된” 이라는 용어가 사용된다. 이 순서를 정렬하는데 사용되는 특정 열을 <code>클러스터드 키</code>라고 한다.</p>
<p>이 배열은 디스크에 있는 데이터의 물리적 순서를 결정한다. 성, 이름 순으로 정렬된 전화번호부라고 생각하면 된다. 전화번호와 주소인 데이터는 정렬된 인덱스와 함께 저장된다.</p>
<p>그러나 실제 데이터 행은 한 가지 순서로만 정렬할 수 있기 때문에 테이블에는 클러스터드 인덱스가 하나만 있을 수 있다. 클러스터드 인덱스를 추가하거나 변경하려면 데이터 행을 물리적으로 다시 정렬해야 하므로 시간이 많이 소요될 수 있다.</p>
<p>클러스터드 키를 신중하게 선택하는 것도 중요하다. 일반적으로 중복 항목을 방지하고 새 데이터를 삽입할 때 페이지 분할을 최소화하려면 고유하고 순차적인 키를 선택하는 것이 좋다. 많은 데이터베이스에서 다른 클러스터드 인덱스가 명시적으로 정의되어 있지 않은 경우 기본 키 제약 조건이 해당 열에 클러스터드 인덱스를 자동으로 생성하는 이유이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230707200716697.png" alt=""></p>
<p>그러나 이 일반적인 지침의 예외는 PostgreSQL이다. PostgreSQL에서는 데이터가 클러스터된 인덱스나 다른 인덱스에 기반하지 않고 삽입된 순서대로 저장된다. 그러나 PostgreSQL은 특정 인덱스와 일치하도록 테이블의 실제 데이터 순서를 변경하는데 사용할 수 있는 CLUSTER 명령을 제공한다. 이 물리적 순서는 데이터가 삽입되거나 업데이트될 때 자동으로 유지되는 것이 아니며, 순서를 유지하려면 CLUSTER 명령을 다시 실행해야 한다는 점에 유의해야 한다.</p>
<h3 id="Non-clustered-Index"><a href="#Non-clustered-Index" class="headerlink" title="Non-clustered Index"></a>Non-clustered Index</h3><p>논 클러스터드 인덱스는 책 뒷부분에 있는 색인과 비슷하다. 각 키에는 해당 값이 포함된 행의 위치를 나타내는 포인터가 있는 고유한 키 값 목록을 유지한다. 포인터는 인덱스 항목을 데이터 페이지에 다시 연결한다. 논 클러스터드 인덱스는 데이터 행과 별도로 저장되므로 데이터의 물리적 순서가 인덱스에 의해 설정된 논리적 순서와 동일하지 않다. 이러한 분리로 인해 논 클러스터드 인덱스를 사용하여 데이터에 엑세스하려면 인덱스에 엑세스하기 위한 디스크 읽기와 데이터에 엑세스하기 위한 디스크 읽기가 최소 두 번 필요하다. 이는 인덱스와 데이터가 하나의 동일한 인덱스인 클러스터드 인덱스와는 대조적이다.</p>
<p>논 클러스터드 인덱스의 가장 큰 장점은 테이블에 여러 개의 논 클러스터드 인덱스를 가질 수 있으며, 각각 다른 유형의 쿼리에 유용하다는 것이다. 클러스터드 인덱스에 포함되지 않은 열을 포함하는 쿼리에 특히 유용하다. 클러스터드 키가 포함되지 않거나 다양한 데이터를 스캔할 필요가 없는 쿼리의 성능을 향상시킨다.</p>
<p>장단점을 고려하는게 중요하다. 논 클러스터드 인덱스는 읽기 작업의 속도를 높일 수 있지만 테이블에서 데이터가 수정될 때마다 각 인덱스를 업데이트해야 하므로 쓰기 작업의 속도가 느려질 수 있다. 특정 테이블에 대해 논 클러스터드 인덱스의 수와 유형을 결정할 때 균형을 맞추는 것이 중요하다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230707201304941.png" alt=""></p>
<h2 id="Understanding-Index-Types"><a href="#Understanding-Index-Types" class="headerlink" title="Understanding Index Types"></a>Understanding Index Types</h2><p>인덱스는 모든 행을 스캔하지 않고도 데이터에 대한 보다 효율적인 경로를 제공함으로써 데이터 검색 속도를 높여준다. 인덱스에는 다양한 유형이 있다. 일반적인 인덱스에 대해 살펴보자.</p>
<h3 id="Primary-Index"><a href="#Primary-Index" class="headerlink" title="Primary Index"></a>Primary Index</h3><p>데이터베이스의 기본 인덱스는 일반적으로 데이터에 엑세스하는 주요 수단이다. 테이블을 만들 때 기본 키는 클러스터드 인덱스를 겸하는 경우가 많으며, 이는 테이블의 데이터가 이 키를 기준으로 디스크에서 물리적으로 정렬된다는 것을 의미한다. 이렇게 하면 기본 키로 검색할 때 데이터를 빠르게 검색할 수 있다.</p>
<p>이 설정의 효율성은 기본 키의 특성에 따라 크게 달라진다. 키가 순차 키인 경우 일반적으로 테이블에 쓰는 것이 효율적이다. 그러나 키가 순차적이지 않은 경우 순서를 유지하기 위해 데이터를 재구성해야 할 수 있다. 이로 인해 쓰기 프로세스의 효율성이 떨어질 수 있다.</p>
<p>기본 키가 클러스터드 인덱스의 역할을 하는 경우가 많지만, 이것은 어렵고 빠른 규칙이 아니다. 클러스터드 인덱스는 반드시 기본 키가 아니더라도 모든 열 또는 열 집합을 기반으로 할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230707201556046.png" alt=""></p>
<h3 id="Secondary-Index"><a href="#Secondary-Index" class="headerlink" title="Secondary Index"></a>Secondary Index</h3><p>특정 시나리오에서는 기본 키만으로는 쿼리를 효율적으로 실행하기에 충분하지 않을 수 있다. 예를 들어 기본 키가 아닌 열을 기반으로 데이터를 필터링하거나 정렬하는 쿼리에는 추가 인덱스가 유용할 수 있다. 이런 경우 보조 인덱스가 유용하다.</p>
<p>보조 인덱스는 기본 테이블의 레코드를 참조하는 정렬된 구조다. 주 인덱스와 달리 보조 인덱스는 클러스터링 되지 않은 인덱스다. 이 인덱스는 별도의 키-값 쌍 목록을 유지하며, 각 키에는 기본 테이블의 해당 레코드에 대한 포인터가 있다.</p>
<p>보조 인덱스는 기본 키가 아닌 열에 대한 쿼리 속도를 높일 수 있지만 쓰기 작업 속도가 느려질 수 있다. 쓰기 작업이 수행될 때마다 영향을 받는 데이터를 포함하는 모든 인덱스가 업데이트 되어야 하기 때문이다. 읽기 작업이 많은 애플리케이션에서는 빠른 쿼리 응답의 이점이 느린 쓰기로 인한 비용보다 더 큰 경우가 많다. 이러한 상황에서는 여러 개의 보조 인덱스를 사용하는 것이 바람직하다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230707201902404.png" alt=""></p>
<h3 id="Composite-Index"><a href="#Composite-Index" class="headerlink" title="Composite Index"></a>Composite Index</h3><p>다중 열 인덱스 또는 연결된 인덱스라고도 하는 복합 인덱스는 인덱스 키에 둘 이상의 열을 포함한다. 이 유형의 인덱스는 특정 열 집합을 기준으로 필터링하거나 정렬하는 쿼리에 특히 유용하다.</p>
<p>예를 들어, ‘Customers’ 테이블이 있고 <code>SELECT * FROM Customers WHERE lastName = &#39;Smith&#39; AND firstName = &#39;John&#39;</code>과 같은 쿼리를 실행하는 경우가 종종 있다고 가정해보자. “lastName” 및 “firstName” 열에 대해 두 개의 개별 인덱스를 만드는 대신, 두 열에 대해 하나의 복합 인덱스를 만들 수 있다.</p>
<p>복합 인덱스에 대해 주의해야 할 한 가지 중요한 세부 사항은 열 순서다. 열 순서는 인덱스의 유용성에 큰 영향을 미칠 수 있다. 위의 예에서 복합 인덱스는 “성”과 “이름”이 모두 포함된 쿼리와 “성”만 포함된 쿼리에 유용할 수 있다. 그러나 “이름”만 포함하는 쿼리에서는 인덱스가 “성”을 먼저 정렬하므로 효율적이지 못하다.</p>
<p>따라서 복합 인덱스를 만들 때는 열 순서를 고려하는 것이 중요하다. 일반적으로 데이터를 가장 좁혀주는 열이 인덱스의 첫 번째가 되어야 한다. 또한 복합 인덱스는 특히 많은 열을 포함할 때 크기가 커지고 더 많은 저장 공간을 사용할 수 있다는 점을 기억할 필요가 있다. 쿼리 성능 개선의 이점과 스토리지 사용량 증가로 인한 비용 사이의 균형을 찾는 것이 중요하다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230707202338734.png" alt=""></p>
<h3 id="Covering-Index"><a href="#Covering-Index" class="headerlink" title="Covering Index"></a>Covering Index</h3><p>커버링 인덱스는 쿼리 성능을 최적화하는데 도움이 될 수 있는 또 다른 유용한 인덱싱 기법이다. 커버링 인덱스의 개념은 쿼리가 인덱스에 의해 “커버”된다는 개념과 관련이 있다.</p>
<p>쿼리의 select, where 및 조인 절에서 참조된 모든 열이 동일한 인덱스에 포함되어 있으면 쿼리가 “커버된” 것으로 간주된다. 즉, 데이터 베이스 엔진은 기초 테이블에서 추가 조회를 수행하지 않고도 인덱스 자체에서 필요한 모든 정보를 검색할 수 있다. 커버링 인덱스를 사용하면 데이터베이스가 인덱스만으로 쿼리에 응답할 수 있어 디스크I/O 작업을 줄일 수 있으므로 특정 쿼리의 성능을 크게 향상시킬 수 있다. 특히 열의 하위 집한은 작지만 잠재적으로 많은 행을 반환하는 대규모 테이블 및 쿼리에 유용하다.</p>
<p>다른 인덱스와 마찬가지로 커버된 인덱스를 유지 관리하면 쓰기 작업에 대한 추가 오버헤드가 발생한다는 점에 유의해라. 광범위한 쿼리를 처리하기 위해 인덱스에 많은 열이 포함되면 인덱스가 커지고 저장 공간을 더 많이 차지할 수 있다. 더 많은 쿼리를 처리하는 것과 스토리지 및 성능 절충점을 관리하는 것 사이에서 균형을 찾는 것이 중요하다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230707202719275.png" alt=""></p>
<h3 id="Unique-Index"><a href="#Unique-Index" class="headerlink" title="Unique Index"></a>Unique Index</h3><p>유니크 인덱스는 이름에서 알 수 있듯이 데이터베이스에서 인덱스 키 값의 고유성을 보장하는 인덱싱 도구다. 이 인덱스 유형은 데이터 무결성을 강화하고 중복 항목을 방지하는 데 유용하다. 예를 들어, ‘email’ 또는 ‘user_id’와 같은 열은 이러한 필드에 중복 항목이 있으면 데이터 무결성 문제가 발생할 수 있으므로 고유 인덱스를 사용하는 것이 이상적이다. 고유 인덱스는 동일한 인덱스 값을 가진 두 행의 입력을 금지하는 방식으로 작동한다.즉, 기존 레코드와 동일한 인덱스 값을 갖게 되는 레코드를 삽입하려고 하면 데이터베이스에서 이를 방지한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230707203220599.png" alt=""></p>
<h3 id="Filtered-Index"><a href="#Filtered-Index" class="headerlink" title="Filtered Index"></a>Filtered Index</h3><p>일부 데이터베이스 시스템에서 부분 인덱스 또는 조건부 인덱스라고도 하는 필터링된 인덱스는 보다 전문화된 인덱스 유형이다. 데이터의 하위 집합에 필터를 적용하여 특정 범위 또는 값 집합에 대한 인덱스를 생성할 수 있다. 이는 데이터의 일부만 자주 엑세스하는 대규모 테이블을 처리할 때 성능을 크게 향상하고 저장 공간을 절약할 수 있다. 예를 들어, 광범위한 제품 정보가 포함된 데이터베이스에서 필터링된 인덱스를 사용하면 “재고” 제품과 관련된 쿼리 속도를 높일 수 있다. 필터링된 인덱스는 인덱스의 크기를 줄이고 유지 관리 오버헤드를 줄임으로써 데이터를 집중적이고 효율적으로 쿼리할 수 있는 방법을 제공한다. 하지만 효과적으로 사용하려면 데이터와 쿼리 워크로드에 대한 충분한 이해가 필요하다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230707202953896.png" alt=""></p>
<p>필터링된 인덱스의 사용 가능성은 모든 관계형 데이터베이스에서 보편적으로 지원되지는 않지만 일부 데이터베이스에서 지원된다. Microsoft SQL Server와 PostgreSQL은 필터링된 인덱스를 지원하는 데이터베이스의 예이다.</p>
<h2 id="Specialized-Indexes"><a href="#Specialized-Indexes" class="headerlink" title="Specialized Indexes"></a>Specialized Indexes</h2><p>이번에는 매우 특정한 상황에 맞게 조정된 몇 가지 특수 인덱스 유형에 대해 설명한다. 이러한 인덱스는 보편적으로 사용할 수 있는 것은 아니지만 특정 상황에서 필요할 때 유용하다. 위에서 언급한 인덱스와 달리, 이러한 특수 인덱스 중 상당수는 B+ 트리에 의해 지원되지 않는다.</p>
<h3 id="Bitmap-Index"><a href="#Bitmap-Index" class="headerlink" title="Bitmap Index"></a>Bitmap Index</h3><p>비트맵 인덱스는 비트맵을 사용하는 특수한 유형의 데이터베이스 인덱스다. 특히 고유 값의 수가 제한된 열, 즉 낮은 카디널리티 값이라고도 하는 열을 처리할 때 유용하다. 예를 들어 ‘결혼 여부’ 또는 ‘예 / 아니오’ 지표에 대한 열이 있다. 비트맵 인덱스에서 열의 각 고유 값은 고유한 비트맵을 가지며, 여기서 비트 수는 행 수에 해당한다. 행에 해당 값이 있으면서 비트가 1로 설정되고, 없으면 0으로 설정된다. 예를 들어 ‘예 / 아니오’ 열에서 ‘예’ 비트맵은 첫 번째 비트가 1로 설정되어 첫 번째 행이 ‘예’에 해당함을 나타내고 ‘아니오’ 비트맵은 첫 번째 비트가 0으로 설정되어 첫 번째 행이 ‘아니오’에 해당하지 않음을 나타낼 수 있다.</p>
<p>이 비트맵 표현은 열의 카디널리티가 낮을 때 스토리지 측면에서 매우 효율적이다. 비트맵 인덱스는 비트 단위 연산을 사용하여 여러 술어와 관련된 복잡한 쿼리를 효율적으로 처리할 수 있다. 이러한 연산에는 서로 다른 비트맵을 빠르게 결합하여 여러 조건에 따라 데이터를 필터링 할 수 있는 AND, OR, NOT 연산이 포함된다.</p>
<p>그러나 비트맵 인덱스는 읽기 작업에는 빠르지만, 값을 업데이트하려면 비트맵의 비트를 변경해야 하므로 쓰기 작업에는 느릴 수 있다. 이러한 수정은 잠재적으로 많은 비트에 영향을 미쳐 쓰기 비용이 많이 들 수 있다. 비트맵 인덱스는 자주 변경되지 않는 정적 또는 읽기 위주의 데이터에 가장 적합하다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230707230023958.png" alt=""></p>
<h3 id="Spatial-Index"><a href="#Spatial-Index" class="headerlink" title="Spatial Index"></a>Spatial Index</h3><p>공간 인덱스는 지리적 좌표, 다각형 또는 3차원 객체와 같은 다차원 객체를 인덱싱하는 데 사용되는 특수한 유형의 인덱스다. 이러한 인덱스는 가장 가까운 이웃 검색이나 범위 검색과 같은 공간 쿼리의 속도를 높이기 위해 설계되었다. 공간 데이터의 특성상 인덱스가 없으면 계산 비용이 많이 든다.</p>
<p>B-Tree와 같은 기존의 인덱싱 방법은 주로 1차원 데이터를 처리하도록 설계되었기 때문에 공간 데이터를 다룰 때 종종 부족하다. R-트리나 쿼드트리와 같은 공간 인덱스는 다차원 데이터를 효율적으로 저장하고 검색하는데 최적화 되어있다.</p>
<p>가장 일반적으로 사용되는 공간 인덱스 중 하나인 R-트리가 내부적으로 어떻게 작동하는지 살펴보자. R-트리에서 모든 노드는 자식 노드의 모든 개체(또는 다른 바운딩 박스)를 포함하는 바운딩 박스를 나타낸다. 형제 노드의 바운딩 박스는 겹칠 수 있다. 공간 쿼리가 수행될 때 R-트리는 바운딩 박스가 검색된 영역과 교차하지 않는지 판단하여 많은 잠재적 결과를 제외할 수 있다. 따라서 테이블의 모든 행을 스캔하는 것보다 훨씬 더 효율적으로 쿼리를 수행할 수 있다. 예를 들어, 특정 지점의 반경 내에 있는 모든 위치를 찾거나 특정 위치에서 가장 가까운 관심 지점을 찾는 것이 일반적인 작업일 수 있는 매핑 애플리케이션을 구동하는 데이터베이스에 R-트리 인덱스는 좋은 옵션이 될 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230707230410512.png" alt=""></p>
<h3 id="Full-text-Index"><a href="#Full-text-Index" class="headerlink" title="Full-text Index"></a>Full-text Index</h3><p>전문 인덱스는 텍스트 열에서 검색 문자열을 열 값 내 어디에서나 찾을 수 있는 검색을 효율적으로 처리하도록 설계되었다. 이러한 경우, 표준 인덱스는 텍스트 데이터의 부분 일치 보다는 정확히 일치하거나 범위 쿼리에 최적화되어 있기 때문에 종종 비효율적이다. 이 인덱스는 기사, 책 또는 수많은 단어가 포함된 기타 자유 형식 텍스트와 같은 대량의 텍스트를 처리하는데 특히 유용하다.</p>
<p>열의 전체 값을 색인하는 기존 인덱스와 달리, 전문 인덱스는 열의 텍스트를 개별 단어 또는 토큰으로 분할한 다음 이러한 토큰 위에 인덱스를 구축하는 방식으로 작동한다. 각 단어는 텍스트 문서에서 해당 위치에 대한 링크와 함께 색인에 저장된다.</p>
<p>전체 텍스트 인덱스에 사용되는 일반적인 기법 중 하나는 역 인덱스다. 역 인덱스는 단어나 숫자와 같은 콘텐츠에서 문서 또는 문서 집합 내 해당 위치로의 매핑을 저장하는 데이터 구조다. 페이지 중심 스키마(페이지 -&gt; 단어)를 키워드 중심 스키마(단어 -&gt; 페이지)로 반전시키기 때문에 역 인덱스라고 부른다.</p>
<p>이 기법은 여러 단어, 구문 또는 다양한 형태의 단어가 포함된 복잡한 검색 쿼리를 지원하는데 특히 효과적이다. 색인을 통해 데이터베이스는 쿼리에서 각 단어가 포함된 문서를 찾은 다음 이러한 문서 집합을 교차하여 모든 단어가 포함된 문서를 찾을 수 있다. 관계형 데이터베이스를 넘어 전체 텍스트 인덱싱은 Elasticsearch와 같은 전문 검색 및 분석 엔진의 핵심 기능이다. Elasticsearch는 강력한 전체 텍스트 검색 기능을 제공하고 실시간 애플리케이션 확장 및 관리를 위한 분산 시스템 기능으로 이러한 기능을 확장하는 소프트웨어 라이브러리인 루씬을 기반으로 구축되어있다.</p>
<p>전문 인덱스는 텍스트 검색 성능을 크게 향상시킬 수 있지만 상당한 저장 공간을 소비하고 삽입 및 업데이트 작업에 오버헤드를 추가할 수 있다는 점을 기억하는 것이 중요하다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230707230926544.png" alt=""></p>
<h3 id="Hash-Index"><a href="#Hash-Index" class="headerlink" title="Hash Index"></a>Hash Index</h3><p>해시 인덱스는 해시 함수를 사용해 키를 인덱스의 특정 위치에 매핑하는 데이터베이스 인덱스의 한 유형으로 데이터 검색을 매우 효율적으로 처리한다. 이런 유형의 색인은 검색 키가 색인된 키와 정확히 동일한 “=”와 같은 동일성 비교에 특히 적합하다. 해시 인덱싱의 원리는 간단하다. 해시 함수는 각각의 고유 키 값에 대해 고유한 해시 값, 즉 해시를 생성한다. 이런 해시 값은 데이터 레코드에 대한 포인터로 사용된다. 이 프로세스는 데이터베이스가 검색 키의 해시를 직접 계산하여 순차적인 스캔을 수행하거나 B-트리 경로를 따라갈 필요 없이 해당 레코드를 즉시 찾을 수 있으므로 검색 작업이 매우 빨라진다.</p>
<p>해시 인덱스의 한 가지 한계는 범위 기반 쿼리에는 적합하지 않다는 것이다. 해시 인덱스는 키를 정렬된 순서로 저장하지 않기 때문에 “&lt;” 또는 “&gt;”와 같이 키의 위치에 의존하는 연산은 효율적이지 않다. 해시 인덱스는 많은 데이터베이스 시스템에서 사용할 수 있지만, 그 사용과 구현은 다양할 수 있다. PostgreSQL은 해시 인덱스를 지원하며, 동일성 비교만 필요한 경우 B-트리 인덱스보다 효율적인 대안으로 해시 인덱스를 사용한다. 반면 MySQL은 JOIN 연산을 처리하기 위해 메모리에 해시 인덱스를 사용하지만 사용자가 만든 인덱스 유형으로는 지원하지 않는다.</p>
<p>이 논의에서 몇 가지 특수한 인덱스 유형을 살펴보았지만, 이 목록이 포괄적이지 않다는 점을 인식하는 것이 중요하다. 데이터베이스 인덱싱의 세계는 방대하고 끊임없이 변화하고 있으며, 특정 사용 사례에 맞춘 많은 고급 및 틈새 인덱스 유형이 있다.</p>
<p>한 가지 예로 벡터 데이터베이스에 사용되는 인덱스를 들 수 있다. 이 인덱스는 최근 AI 분야에서 상당한 관심을 불러일으키며 성장하고 있는 분야다. 이런 인덱스는 활발한 연구와 지속적인 개발을 통해 최첨단을 달리고 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230707231326643.png" alt=""></p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2023/07/07/System%20Design/ByteByteGo/private/database-indexing-strategies-1/">https://songhayoung.github.io/2023/07/07/System%20Design/ByteByteGo/private/database-indexing-strategies-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2024 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>