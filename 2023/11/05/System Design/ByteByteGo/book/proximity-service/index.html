<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[System Design] Proximity Service"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[System Design] Proximity Service | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Proximity-Service"><span class="toc-number">1.</span> <span class="toc-text">Proximity Service</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-1-Understand-the-Problem-and-Establish-Design-Scope"><span class="toc-number">2.</span> <span class="toc-text">Step 1 - Understand the Problem and Establish Design Scope</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Functional-requirements"><span class="toc-number">2.1.</span> <span class="toc-text">Functional requirements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Non-functional-requirements"><span class="toc-number">2.2.</span> <span class="toc-text">Non-functional requirements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Back-of-the-envelope-estimation"><span class="toc-number">2.3.</span> <span class="toc-text">Back-of-the-envelope estimation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-2-Propose-High-Level-Design-and-Get-Buy-In"><span class="toc-number">3.</span> <span class="toc-text">Step 2 - Propose High-Level Design and Get Buy-In</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API-Design"><span class="toc-number">3.1.</span> <span class="toc-text">API Design</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-model"><span class="toc-number">3.2.</span> <span class="toc-text">Data model</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Read-write-ratio"><span class="toc-number">3.2.1.</span> <span class="toc-text">Read&#x2F;write ratio</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Data-schema"><span class="toc-number">3.2.2.</span> <span class="toc-text">Data schema</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Business-table"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">Business table</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Geo-index-table"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">Geo index table</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#High-level-design"><span class="toc-number">3.3.</span> <span class="toc-text">High-level design</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Load-balancer"><span class="toc-number">3.3.1.</span> <span class="toc-text">Load balancer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Location-based-service-LBS"><span class="toc-number">3.3.2.</span> <span class="toc-text">Location-based service(LBS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Business-service"><span class="toc-number">3.3.3.</span> <span class="toc-text">Business service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Database-cluster"><span class="toc-number">3.3.4.</span> <span class="toc-text">Database cluster</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Scalability-of-business-service-and-LBS"><span class="toc-number">3.3.5.</span> <span class="toc-text">Scalability of business service and LBS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Algorithms-to-fetch-nearby-businesses"><span class="toc-number">3.4.</span> <span class="toc-text">Algorithms to fetch nearby businesses</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Option-1-Two-dimensional-search"><span class="toc-number">3.4.1.</span> <span class="toc-text">Option 1: Two-dimensional search</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Option-2-Evenly-divided-grid"><span class="toc-number">3.4.2.</span> <span class="toc-text">Option 2: Evenly divided grid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Option-3-Geohash"><span class="toc-number">3.4.3.</span> <span class="toc-text">Option 3: Geohash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Option-4-Quadtree"><span class="toc-number">3.4.4.</span> <span class="toc-text">Option 4: Quadtree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Option-5-Google-S2"><span class="toc-number">3.4.5.</span> <span class="toc-text">Option 5: Google S2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Recommendation"><span class="toc-number">3.4.6.</span> <span class="toc-text">Recommendation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Geohash-vs-quadtree"><span class="toc-number">3.4.7.</span> <span class="toc-text">Geohash vs quadtree</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Geohash"><span class="toc-number">3.4.7.1.</span> <span class="toc-text">Geohash</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Quadtree"><span class="toc-number">3.4.7.2.</span> <span class="toc-text">Quadtree</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-3-Design-Deep-Dive"><span class="toc-number">4.</span> <span class="toc-text">Step 3 - Design Deep Dive</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Scale-the-database"><span class="toc-number">4.1.</span> <span class="toc-text">Scale the database</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Business-table-1"><span class="toc-number">4.1.1.</span> <span class="toc-text">Business table</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Geospatial-index-table"><span class="toc-number">4.1.2.</span> <span class="toc-text">Geospatial index table</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Caching"><span class="toc-number">4.2.</span> <span class="toc-text">Caching</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cache-key"><span class="toc-number">4.2.1.</span> <span class="toc-text">Cache key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Types-of-data-to-cache"><span class="toc-number">4.2.2.</span> <span class="toc-text">Types of data to cache</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Region-and-availability-zones"><span class="toc-number">4.3.</span> <span class="toc-text">Region and availability zones</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Follow-up-question-filter-results-by-time-or-business-type"><span class="toc-number">4.4.</span> <span class="toc-text">Follow-up question: filter results by time or business type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Final-design-diagram"><span class="toc-number">4.5.</span> <span class="toc-text">Final design diagram</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Get-nearby-businesses"><span class="toc-number">4.5.1.</span> <span class="toc-text">Get nearby businesses</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#View-update-add-or-delete-a-business"><span class="toc-number">4.5.2.</span> <span class="toc-text">View, update, add or delete a business</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-4-Wrap-Up"><span class="toc-number">5.</span> <span class="toc-text">Step 4 - Wrap Up</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-Summary"><span class="toc-number">6.</span> <span class="toc-text">Chapter Summary</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/hayoung-song-9523b61bb/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">11101</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">196</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">62</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[System Design] Proximity Service</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-11-05</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/System-Design-Interview/">System Design Interview</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4.3k</span><span class="post-meta__separator">|</span><span>Reading time: 26 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Proximity-Service"><a href="#Proximity-Service" class="headerlink" title="Proximity Service"></a>Proximity Service</h2><span id="more"></span>
<p>이 포스트에서는 proximity service를 설계한다. 이 서비스는 레스토랑, 호텔, 극장, 박물관 등과 같은 주변 장소를 검색하는데 사용되며, Yelp에서 주변 최고의 레스토랑을 찾거나 구글 지도에서 가장 가까운 주유소를 찾는 등의 기능을 지원하는 핵심 구성 요소다. </p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105160600314.png" alt=""></p>
<h2 id="Step-1-Understand-the-Problem-and-Establish-Design-Scope"><a href="#Step-1-Understand-the-Problem-and-Establish-Design-Scope" class="headerlink" title="Step 1 - Understand the Problem and Establish Design Scope"></a>Step 1 - Understand the Problem and Establish Design Scope</h2><h3 id="Functional-requirements"><a href="#Functional-requirements" class="headerlink" title="Functional requirements"></a>Functional requirements</h3><ul>
<li>사용자의 위치(위 / 경도)와 반경을 기준으로 모든 비즈니스 반환</li>
<li>비즈니스 소유자는 비즈니스를 추가, 삭제 또는 업데이트할 수 있지만 이 정보가 실시간으로 반영될 필요는 없음</li>
<li>고객은 비즈니스에 대한 자세한 정보를 볼 수 있음</li>
</ul>
<h3 id="Non-functional-requirements"><a href="#Non-functional-requirements" class="headerlink" title="Non-functional requirements"></a>Non-functional requirements</h3><ul>
<li>Low latency. 사용자는 주변 비즈니스를 빠르게 볼 수 있어야 함</li>
<li>Data privacy. 위치 정보는 민감한 데이터다. 위치 기반 서비스(LBS)를 설계할 때는 항상 GDPR이나 CCPA와 같은 사용자 개인정보 보호를 고려해야 한다</li>
<li>High availability and scalability requirements. 인구 밀집 지역의 피크 시간대에 급증하는 트래픽을 처리할 수 있는 시스템이어야 함</li>
</ul>
<h3 id="Back-of-the-envelope-estimation"><a href="#Back-of-the-envelope-estimation" class="headerlink" title="Back-of-the-envelope estimation"></a>Back-of-the-envelope estimation</h3><ul>
<li>DAU가 100M이라고 가정</li>
<li>비즈니스가 200M이라고 가정</li>
<li>QPS<ul>
<li>1day as second = 24 <em> 60 </em> 60 = 86,400 ~= 10^5</li>
<li>5 query per day by user</li>
<li>Search QPS = 100M * 5 / 10^5 = 5000</li>
</ul>
</li>
</ul>
<h2 id="Step-2-Propose-High-Level-Design-and-Get-Buy-In"><a href="#Step-2-Propose-High-Level-Design-and-Get-Buy-In" class="headerlink" title="Step 2 - Propose High-Level Design and Get Buy-In"></a>Step 2 - Propose High-Level Design and Get Buy-In</h2><p>이 섹션에서는 아래와 같은 사항을 이야기한다.</p>
<ul>
<li>API design</li>
<li>High-level design</li>
<li>Algorithms to find nearby businesses</li>
<li>Data model</li>
</ul>
<h3 id="API-Design"><a href="#API-Design" class="headerlink" title="API Design"></a>API Design</h3><p>Restful API 규칙을 사용해 간소화된 버전의 API를 설계한다.</p>
<ul>
<li><strong>GET /v1/search/nearby</strong></li>
</ul>
<p>이 엔드포인트는 특정 검색 기준에 따라 비즈니스를 반환한다. 실제 애플리케이션에서 검색 결과는 일반적으로 페이지네이션된다. </p>
<p>Request parameters:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Field</strong></th>
<th style="text-align:left"><strong>Description</strong></th>
<th style="text-align:left"><strong>Type</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">latitude</td>
<td style="text-align:left">Latitude of a given location</td>
<td style="text-align:left">decimal</td>
</tr>
<tr>
<td style="text-align:left">longitude</td>
<td style="text-align:left">Longitude of a given location</td>
<td style="text-align:left">decimal</td>
</tr>
<tr>
<td style="text-align:left">radius</td>
<td style="text-align:left">Optional. Default is 5000 meters (about 3 miles)</td>
<td style="text-align:left">int</td>
</tr>
</tbody>
</table>
</div>
<p>Response Body:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;total&quot;: 10,</span><br><span class="line">  &quot;businesses&quot;:[&#123;business object&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>비즈니스 오브젝트는 검색 결과 페이지를 랜더링하는데 필요한 모든 것이 포함되어 있지만 비즈니스 상세 페이지를 렌더링하려면 사진, 리뷰, 별점 등의 추가 속성이 필요할 수 있다. 따라서 사용자가 비즈니스 상세 페이지를 클릭하면 일반적으로 비즈니스의 상세 정보를 가져오기 위한 새로운 엔드포인트 호출이 필요하다.</p>
<ul>
<li><strong>APIs for a business</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>API</strong></th>
<th style="text-align:left"><strong>Detail</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GET /v1/businesses/{:id}</td>
<td style="text-align:left">Return detailed information about a business</td>
</tr>
<tr>
<td style="text-align:left">POST /v1/businesses</td>
<td style="text-align:left">Add a business</td>
</tr>
<tr>
<td style="text-align:left">PUT /v1/businesses/{:id}</td>
<td style="text-align:left">Update details of a business</td>
</tr>
<tr>
<td style="text-align:left">DELETE /v1/businesses/{:id}</td>
<td style="text-align:left">Delete a business</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Data-model"><a href="#Data-model" class="headerlink" title="Data model"></a>Data model</h3><p>이 섹션에서는 읽기 / 쓰기 비율과 스키마 설계에 대해 설명한다. </p>
<h4 id="Read-write-ratio"><a href="#Read-write-ratio" class="headerlink" title="Read/write ratio"></a>Read/write ratio</h4><p>아래 두 가지 기능이 매우 일반적으로 사용되기 때문에 읽기 볼륨이 높다.</p>
<ul>
<li>주변 비즈니스 검색</li>
<li>비즈니스의 상세 정보 보기</li>
</ul>
<p>반면에 비즈니스 정보 추가, 제거, 편집은 빈번하지 않은 작업이기 때문에 쓰기 볼륨은 낮다. 읽기 작업이 많은 시스템에는 MySQL과 같은 관계형 데이터베이스가 적합할 수 있다. 스키마 설계에 대해 자세히 살펴보자.</p>
<h4 id="Data-schema"><a href="#Data-schema" class="headerlink" title="Data schema"></a>Data schema</h4><p>주요 데이터베이스 테이블은 비즈니스 테이블과 지리공간 인덱스 테이블이다.</p>
<h5 id="Business-table"><a href="#Business-table" class="headerlink" title="Business table"></a>Business table</h5><p>비즈니스 테이블에는 비즈니스에 대한 자세한 정보가 포함되어 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105165825040.png" alt=""></p>
<h5 id="Geo-index-table"><a href="#Geo-index-table" class="headerlink" title="Geo index table"></a>Geo index table</h5><p>지리적 인덱스 테이블은 공간 연산을 효율적으로 처리하기 위해 사용된다. 이 테이블에는 Geohash에 대한 약간의 지식이 필요하므로 추후에 자세히 설명한다.</p>
<h3 id="High-level-design"><a href="#High-level-design" class="headerlink" title="High-level design"></a>High-level design</h3><p>고수준의 설계 다이어그램은 아래 나와있다. 이 시스템은 LBS와 비즈니스 관련 서비스의 두 부분으로 구성된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105170037868.png" alt=""></p>
<h4 id="Load-balancer"><a href="#Load-balancer" class="headerlink" title="Load balancer"></a>Load balancer</h4><p>로드 밸런서는 들어오는 트래픽을 여러 서비스에 자동으로 분산한다. 일반적으로 기업은 단일 DNS 엔트리 포인트를 제공하고 내부적으로 URL 경로에 따라 API 호출을 적절한 서비스로 라우팅한다.</p>
<h4 id="Location-based-service-LBS"><a href="#Location-based-service-LBS" class="headerlink" title="Location-based service(LBS)"></a>Location-based service(LBS)</h4><p>LBS는 주어진 반경과 위치에서 주변 비즈니스를 찾는 시스템의 핵심 부분이다. LBS는 아래와 같은 특징이 있다.</p>
<ul>
<li>쓰기 요청이 없는 읽기 위주의 서비스</li>
<li>인구 밀집 지역의 피크 시간대 QPS가 높음</li>
<li>Stateless 애플리케이션이라 수평적으로 쉽게 확장 가능</li>
</ul>
<h4 id="Business-service"><a href="#Business-service" class="headerlink" title="Business service"></a>Business service</h4><p>비즈니스 서비스는 주로 두 가지 유형의 요청을 처리한다.</p>
<ul>
<li>비즈니스 소유자는 비즈니스를 생성, 업데이트 또는 삭제한다. 이런 요청은 주로 쓰기 작업이며 QPS가 높지 않다.</li>
<li>고객은 비즈니스에 대한 자세한 정보를 본다. 피크 시간대에는 QPS가 높다.</li>
</ul>
<h4 id="Database-cluster"><a href="#Database-cluster" class="headerlink" title="Database cluster"></a>Database cluster</h4><p>데이터베이스 클러스터는 primary-secondary setup을 사용할 수 있다. 이 설정은 기본 데이터베이스가 모든 쓰기 작업을 처리하고 읽기 작업에는 여러 복제본이 사용된다. 데이터는 먼저 기본 데이터베이스에 저장된 다음 복제본으로 복제된다. 복제 지연으로 인해 LBS에서 읽은 데이터와 기본 데이터베이스에 쓰여진 데이터 간에 약간의 불일치가 있을 수 있다. 비즈니스 정보를 실시간으로 업데이트할 필요가 없기 때문에 이런 불일치는 일반적으로 문제가 되지 않는다.</p>
<h4 id="Scalability-of-business-service-and-LBS"><a href="#Scalability-of-business-service-and-LBS" class="headerlink" title="Scalability of business service and LBS"></a>Scalability of business service and LBS</h4><p>비즈니스 서비스와 LBS는 모두 stateless 서비스이므로 트래픽이 몰리는 시간대에는 서비스를 자동으로 추가하고 사용량이 적은 시간대에는 서버를 제거하기가 쉽다. 시스템이 클라우드에서 작동하는 경우 다양한 지역과 가용성 영역을 설정해 가용성을 더욱 향상시킬 수 있다.</p>
<h3 id="Algorithms-to-fetch-nearby-businesses"><a href="#Algorithms-to-fetch-nearby-businesses" class="headerlink" title="Algorithms to fetch nearby businesses"></a>Algorithms to fetch nearby businesses</h3><p>실제 기업에서는 Redis의 Geohash 또는 PostGIS 확장 기능이 있는 Postgres와 같은 기존 지리공간 데이터베이스를 사용할 수 있다. 면접에서는 이런 지리 공간 데이터베이스 이름을 나열하는 것보다 지리공간 인덱스가 어떻게 작동하는지 설명해 문제 해결 능력과 기술 지식을 입증하는 것이 좋다.</p>
<p>다음 단계는 주변 비즈니스를 가져오는 다양한 옵션을 탐색하는 것이다. 몇가지 옵션을 나열하고, 사고 과정을 살펴보고, 장단점을 논의해보자.</p>
<h4 id="Option-1-Two-dimensional-search"><a href="#Option-1-Two-dimensional-search" class="headerlink" title="Option 1: Two-dimensional search"></a>Option 1: Two-dimensional search</h4><p>주변 비즈니스를 가져오는 가장 직관적이지만 순진한 방법은 아래와 같이 미리 정의된 반경을 원으로 그려 원 안의 모든 비즈니스를 찾는 것이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105170955692.png" alt=""></p>
<p>이 프로세스는 아래와 같은 의사 SQL 쿼리로 변환할 수 있다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT business_id, latitude, longitude,</span><br><span class="line">FROM business</span><br><span class="line">WHERE (latitude BETWEEN &#123;:my_lat&#125; - radius AND &#123;:my_lat&#125; + radius) AND</span><br><span class="line">      (longitude BETWEEN &#123;:my_long&#125; - radius AND &#123;:my_long&#125; + radius)</span><br></pre></td></tr></table></figure>
<p>이 쿼리는 full table scan이 필요하므로 효율적이지 않다. 경도와 위도 컬럼에 인덱스를 구축하더라도 성능 향상이 크지 않다. 문제는 2차원 데이터가 있고 각 차원에서 반환데는 데이터 집합이 여전히 방대하기 때문이다. 예를 들어 아래 표시된 것처럼 경도 및 위도 컬럼의 인덱스 덕분에 데이터 집합 1과 데이터 집합 2를 빠르게 검색할 수 있다. 하지만 반경 내에 있는 비즈니스를 가져오려면 두 데이터 집합에 대해 교차 연산을 수행해야 한다. 각 데이터 집합에 많은 데이터가 포함되어 있기 때문에 이 작업을 효율적이지 않다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105171230148.png" alt=""></p>
<p>이 접근 방식의 문제점은 데이터베이스 인덱스가 1차원에서만 검색 속도를 향상시킬 수 있다는 것이다. 따라서 당연히 후속 질문은 2차원 데이터를 1차원으로 매핑할 수 있는가에 대한 것이다. 자세한 방법을 알아보기 전에 다양한 유형의 인덱싱 방법에 대해 살펴보자. 넓은 의미에서 지리공간 인덱싱 접근 방식에는 아래와 같이 두 가지 유형이 있다.</p>
<ul>
<li>Hash : even grid, geohash, cartesian tiers, etc.</li>
<li>Tree : quadtree, Google S2, Rare, etc.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105171514309.png" alt=""></p>
<p>이런 접근 방식의 기본 구현 방식은 다르지만 지도를 더 작은 영역으로 나누고 빠른 검색을 위해 인덱스를 구축한다는 고수준 아이디어는 동일하다. 이 중 geohash, quadtree, Google S2가 실제 애플리케이션에서 가장 널리 사용되고 있다.</p>
<h4 id="Option-2-Evenly-divided-grid"><a href="#Option-2-Evenly-divided-grid" class="headerlink" title="Option 2: Evenly divided grid"></a>Option 2: Evenly divided grid</h4><p>한 가지 간단한 접근 방식은 세계를 작은 그리드로 균등하게 나누는 것이다. 이렇게 하면 하나의 그리드에 여러 비즈니스가 포함될 수 있고 맵의 각 비즈니스가 하나의 그리드에 속하게 된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105171817566.png" alt=""></p>
<p>이 접근 방식은 어느 정도 효과가 있지만, 비즈니스의 분포가 고르지 않다는 한 가지 큰 문제가 있다. 뉴욕 시내에는 많은 비즈니스가 있는 반면, 사막이나 바다에 있는 다른 그리드에는 비즈니스가 전혀 없을 수 있다. 전 세계를 균등하게 그리드로 나누면 데이터 분포가 매우 고르지 않게 된다. 이상적으로는 밀집된 지역에는 더 세분화된 그리드를, 드문드문한 지역에는 큰 그리드를 사용하는 것이 좋다. 또 다른 잠재적 과제는 고정된 그리드에서 인접한 그리드를 찾는 것이다.</p>
<h4 id="Option-3-Geohash"><a href="#Option-3-Geohash" class="headerlink" title="Option 3: Geohash"></a>Option 3: Geohash</h4><p>Geohash는 evenly divided grid보다 좋다. Geohash는 2차원의 경도 및 위도 데이터를 1차원의 문자와 숫자의 문자열로 줄이는 방식으로 동작한다. Geohash 알고리즘은 비트가 추가될 때마다 세계를 점점 더 작은 그리드로 재귀적으로 나누는 방식으로 작동한다. Geohash가 어떻게 작동하는지 자세히 살펴보자.</p>
<p>먼저, 지구를 4분면으로 나눈다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105172243399.png" alt=""></p>
<ul>
<li>위도 범위 [-90, 0]은 0으로 표시</li>
<li>위도 범위 [0,90]은 1로 표시</li>
<li>경도 범위 [-180,0]은 0으로 표시</li>
<li>경도 범위 [0,180]은 1로 표시</li>
</ul>
<p>둘째로 각 그리드를 4개의 작은 그리드로 나눈다. 각 그리드는 경도 비트와 위도 비트를 번갈아 가며 표시할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105172407321.png" alt=""></p>
<p>그리드 크기가 원하는 정밀도 이내가 될 때 까지 이 세분화를 반복한다. Geohash는 보통 base32표현을 사용한다.</p>
<ul>
<li><p>Geohash of the Google headquarter (length = 6):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1001 10110 01001 10000 11011 11010 (base32 in binary) → 9q9hvu (base32)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Geohash of the Facebook headquarter (length = 6):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1001 10110 01001 10001 10000 10111 (base32 in binary) → 9q9jhr (base32)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Geohash는 아래와 같이 12개의 정밀도를 가지고 있다. 정밀도 계수에 따라 그리드의 크기가 결정된다. 우리는 길이가 4에서 6 사이인 geohash에만 관심이 있다. 6보다 길면 그리드 크기가 너무 작고, 4보다 작으면 그리드 크기가 너무 크기 때문이다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Geohash length</strong></th>
<th style="text-align:left"><strong>Grid width x height</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">5,009.4km x 4,992.6km (the size of the planet)</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">1,252.3km x 624.1km</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">156.5km x 156km</td>
</tr>
<tr>
<td style="text-align:left"><strong>4</strong></td>
<td style="text-align:left"><strong>39.1km x 19.5km</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>5</strong></td>
<td style="text-align:left"><strong>4.9km x 4.9km</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>6</strong></td>
<td style="text-align:left"><strong>1.2km x 609.4m</strong></td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">152.9m x 152.4m</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">38.2m x 19m</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">4.8m x 4.8m</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">1.2m x 59.5cm</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">14.9cm x 14.9cm</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left">3.7cm x 1.9cm</td>
</tr>
</tbody>
</table>
</div>
<p>올바른 정밀도는 어떻게 선택해야 할까? 사용자가 정의한 반경으로 그려진 원 전체를 커버하는 최소 geohash의 길이를 찾고자 한다. 반경과 Geohash 길이 사이의 대응 관계는 아래 나와있다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Radius (Kilometers）</th>
<th style="text-align:left">Geohash length</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0.5 km (0.31 mile)</td>
<td style="text-align:left">6</td>
</tr>
<tr>
<td style="text-align:left">1 km (0.62 mile)</td>
<td style="text-align:left">5</td>
</tr>
<tr>
<td style="text-align:left">2 km (1.24 mile)</td>
<td style="text-align:left">5</td>
</tr>
<tr>
<td style="text-align:left">5 km (3.1 mile)</td>
<td style="text-align:left">4</td>
</tr>
<tr>
<td style="text-align:left">20 km (12.42 mile)</td>
<td style="text-align:left">4</td>
</tr>
</tbody>
</table>
</div>
<p>이 접근 방식은 대부분의 경우 훌륭하게 작동하지만, geohash 경계를 처리하는 방법에는 인터뷰 담당자와 논의해야 하는 몇 가지 예외적인 경우가 있다.</p>
<p><strong>Boundary issues</strong></p>
<p>Geohash는 두 해시값 사이에 공유 접두사가 길수록 두 그리드가 가깝다는 것을 보장한다. 아래에서 볼 수 있듯이 모든 그리드에는 공유 접두사 9q8zn이 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105173055065.png" alt=""></p>
<p><strong>Boundary issue 1</strong></p>
<p>그러나 반대의 경우도 있다. 두 위치가 매우 가깝지만 접두사가 전혀 공유되지 않을 수 있다. 적도 또는 본초 자오선의 양쪽에 있는 가까운 두 위치는 세계의 다른 반쪽에 속하기 때문이다. 예를 들어 프랑스의 La Roche-Chalais(geohash: u000)은 Pomerol(geohash: ezzz)와 30km차이지만 두 해시에는 공유 접두사가 전혀 없다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105173342843.png" alt=""></p>
<p>이 경계 문제로 인해 아래의 간단한 접두사 SQL 쿼리는 근처의 모든 비즈니스를 가져오는데 실패한다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM geohash_index WHERE geohash LIKE `9q8zn%`</span><br></pre></td></tr></table></figure>
<p><strong>Boundary issue 2</strong></p>
<p>다른 경계 문제는 아래와 같이 두 위치가 긴 공유 접두사를 가질 수 있지만 서로 다른 geohash에 속할 수 있다는 것이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105173455735.png" alt=""></p>
<p>일반적인 해결책은 현재 그리드 안쪽뿐만 아니라 이웃 그리드에서도 모든 비즈니스를 가져오는 것이다. 이웃의 geohash는 상수 시간으로 계산할 수 있다.</p>
<p><strong>Not enough businesses</strong></p>
<p>이제 다른 문제를 생각해보자. 현재 그리드에서 반환된 비즈니스와 모든 이웃을 합쳐도 반환된 비즈니스가 충분하지 않은 경우 어떻게 해야할까?</p>
<ul>
<li>Option 1 : 반경 내에 있는 비즈니스만 반환한다. 이 옵션은 구현하기 쉽지만 단점이 분명하다. 사용자의 요구를 만족시킬 만큼 충분한 결과를 반환하지 못한다.</li>
<li>Option 2 : 검색 반경을 늘린다. Geohash의 마지막 숫자를 제거하고 새 geohash를 사용해 주변 비즈니스를 가져올 수 있다. 비즈니스가 충분하지 않으면 다른 숫자를 제거해 범위를 계속 확장한다. 이런 방식으로 원하는 결과 수보다 많은 결과가 나올 때까지 그리드 크기를 점차적으로 확장한다. 아래는 확장 검색 프로세스의 개념도다.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105173836083.png" alt=""></p>
<h4 id="Option-4-Quadtree"><a href="#Option-4-Quadtree" class="headerlink" title="Option 4: Quadtree"></a>Option 4: Quadtree</h4><p>또 다른 인기있는 솔루션은 쿼드트리다. 쿼드트리는 2차원 공간을 4사분면으로 재귀적으로 분할해 그리드의 내용이 특정 기준을 충족할 때까지 분할하는데 일반적으로 사용되는 데이터구조다. 예를 들어 그리드의 비즈니스 수가 100개가 넘기 않을때까지 계속 세분화하는 것이 기준이 될 수 있다. 이 숫자는 비즈니스 요구에 따라 실제 숫자가 결정될 수 있으므로 임의적이다. 쿼드트리를 사용하면 쿼리에 응답하기 위해 인메모리 트리 구조를 구축한다. 쿼드트리는 인메모리 데이터 구조이며 데이터베이스 솔루션이 아니라는 점에 유의해야 한다. 쿼드트리는 각 LBS 서버에서 실행되며 서버 시작 시 데이터 구조가 구축된다. 아래는 세계를 쿼드 트리로 세분화하는 개념적 과정을 시각화한 것이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105174308563.png" alt=""></p>
<p>아래는 쿼드트리 구축 프로세스를 더 자세히 설명한다. 루트 노드는 전체 세계를 나타낸다. 루트 노드는 100개 이상의 비즈니스를 가진 노드가 남지 않을 때까지 재귀적으로 4개의 사분면으로 세분화된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105174352365.png" alt=""></p>
<p>쿼드트리는 구축하기 위한 의사 코드는 아래와 같다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void buildQuadtree(TreeNode node) &#123;</span><br><span class="line">    if (countNumberOfBusinessesInCurrentGrid(node) &gt; 100) &#123;</span><br><span class="line">        node.subdivide();</span><br><span class="line">        for (TreeNode child : node.getChildren()) &#123;</span><br><span class="line">            buildQuadtree(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>각각의 데이터 노드에 저장되는 데이터는 아래와 같다.</p>
<p><strong>Data on a leaf node</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Name</strong></th>
<th style="text-align:left"><strong>Size</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Top left coordinates and bottom-right coordinates to identify the grid</td>
<td style="text-align:left">32 bytes (8 bytes * 4)</td>
</tr>
<tr>
<td style="text-align:left">List of business IDs in the grid</td>
<td style="text-align:left">8 bytes per ID * 100 (maximal number of businesses allowed in one grid)</td>
</tr>
<tr>
<td style="text-align:left">Total</td>
<td style="text-align:left">832 bytes</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Data on internal node</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Name</strong></th>
<th style="text-align:left"><strong>Size</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Top left coordinates and bottom-right coordinates to identify the grid</td>
<td style="text-align:left">32 bytes (8 bytes * 4)</td>
</tr>
<tr>
<td style="text-align:left">Pointers to 4 children</td>
<td style="text-align:left">32 bytes (8 bytes * 4)</td>
</tr>
<tr>
<td style="text-align:left">Total</td>
<td style="text-align:left">64 bytes</td>
</tr>
</tbody>
</table>
</div>
<p>트리 구축 프로세스는 그리드 내의 비즈니스 수에 따라 달라지지만, 이 수는 데이터베이스의 레코드로부터 추론할 수 있으므로 쿼드트리 노드에 저장할 필요가 없다. 이제 각 노드의 데이터 구조를 알았으니 메모리 사용량을 살펴보자.</p>
<ul>
<li><p>각 그리드는 최대 100개의 비즈니스를 저장할 수 있다.</p>
</li>
<li><p>리프 노드 수 = ~200M / 100 = ~2M</p>
</li>
<li>내부 노드 수 = 2M * 1/3 = ~0.67M.</li>
<li>총 메모리 요구량 = 200M <em> 832byte + 0.67M </em> 64byte ~= 1.71GB. 트리를 구축하기 위해 약간의 오버헤드를 추가하더라도 트리를 구축하는데 필요한 메모리는 매우 적다.</li>
</ul>
<p>실제 인터뷰에서는 이렇게 세세한 계산은 필요하지 않지만, 쿼드 트리 인덱스가 너무 많은 메모리를 필요로 하지 않으며 하나의 서버에 쉽게 바인딩 시킬 수 있음을 알려주는 것이 중요하다. 또한 읽기 볼륨에 따라 쿼드 트리 서버를 쉽게 확장할 수 있어야 한다.</p>
<p><strong>How long does it take to build the whole quadtree?</strong></p>
<p>각 리프노드에는 약 100개의 비즈니스 ID가 포함된다. 트리를 구축하는데 걸리는 시간 복잡도는 <script type="math/tex">(N/100) * log(N/100)</script> 이며 여기서 N은 비즈니스의 총 개수다. 2억개의 비즈니스로 전체 쿼드트리를 구축하는데 몇 분 정도 걸릴 수 있다.</p>
<p><strong>How to get nearby businesses with quadtree?</strong></p>
<ol>
<li>쿼드 트리를 메모리에 구축한다.</li>
<li>쿼드 트리가 구축된 후 루트에서 검색을 시작해 검색 원점이 있는 리프 노드를 찾을 때까지 트리를 순회한다. 해당 리프노드에 100개의 비즈니스가 있으면 노드를 반환한다. 그렇지 않으면 충분한 비즈니스가 반환될 때까지 이웃 노드에서 비즈니스를 추가한다.</li>
</ol>
<p><strong>Operational considerations for quadtree</strong></p>
<p>위에서 언급했듯이 서버 시작 시간에 2억 개의 비즈니스가 있는 쿼드 트리를 구축하는데 몇 분 정도 걸릴 수 있다. 이렇게 긴 서버 시작 시간이 운영상 어떤 영향을 미치는지 고려하는 것이 중요하다. 쿼드 트리가 구축되는 동안 서버는 트래픽을 처리할 수 없다. 따라서 서버의 새 릴리즈를 한 번에 작언 서버 하위 집합에 점진적으로 롤아웃 해야한다. 이렇게 하면 서버 클러스터의 많은 부분을 오프라인으로 전환해 서비스 중단이 발생하는 것을 방지할 수 있다. 블루/그린 배포도 사용할 수 있지만, 데이터베이스 서비스에서 2억 개의 비즈니스를 동시에 가져오는 새 서버의 전체 클러스터는 시스템에 많은 부담을 줄 수 있다. 이 작업을 수행할 수 있지만 설계가 복잡해질 수 있으므로 인터뷰시 이 점을 언급해야 한다.</p>
<p>또 다른 운영 고려 사항은 시간이 지남에 따라 비즈니스가 추가 및 제거될 때 쿼드 트리를 업데이트하는 방법이다. 가장 쉬운 방법은 전체 클러스터에 걸쳐 한 번에 서버의 작은 하위 집합인 쿼드 트리를 점진적으로 재구축 하는 것이다. 하지만 이렇게 하면 일부 서버가 짧은 기간 동안 오래된 데이터를 반환하게 된다. 그러나 이는 일반적으로 요구 사항에 따라 허용 가능한 타협점이다. 새로 추가 / 업데이트된 비즈니스는 다음 날에만 유효하도록 비즈니스 계약을 설정하면 이런 문제를 더욱 완화할 수 있다. 즉, 트래픽이 적은 시간에 작업을 해 캐시를 업데이트할 수 있다. 이 방법의 한 가지 잠재적인 문제점은 수많은 키가 동시에 무효화되어 캐시 서버에 과부하가 걸린다는 것이다.</p>
<p>또한 비즈니스가 추가되거나 제거될 때 쿼드 트리를 즉시 업데이트 할 수 있다. 특히 쿼드트리 데이터 구조가 여러 스레드에서 액세스할 수 있는 경우 설계가 복잡해진다. 이를 위해서는 잠금 메커니즘이 필요하므로 쿼드트리 구현이 크게 복잡해질 수 있다.</p>
<p><strong>Real-world quadtree example</strong></p>
<p>Yext는 덴버 근처에 구축된 쿼드트리를 보여주는 이미지를 제공했다. 밀집된 지역에는 더 작고 세분화된 격자를, 드문드문한 지역에는 더 큰 격자를 사용해야 한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105180559207.png" alt=""></p>
<h4 id="Option-5-Google-S2"><a href="#Option-5-Google-S2" class="headerlink" title="Option 5: Google S2"></a>Option 5: Google S2</h4><p>Google S2 geometry 라이브러리도 이 분야에서 큰 역할을 하고 있다. 쿼드트리와 마찬가지로 인메모리 솔루션이다. 이 라이브러리는 hillbert curve(space-filling curve)를 기반으로 구를 1D 인덱스에 매핑한다. 힐버트 곡선에는 매우 중요한 특성이 있다. gㅣㄹ버트 곡선에서 서로 가까운 두 점은 1D 공간에서 가깝다는 것이다. 1D 공간에서의 검색은 2D 보다 훨씬 더 효율적이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105180820133.png" alt=""></p>
<p>S2는 복잡한 라이브러리이므로 인터뷰 중에 내부를 설명할 필요는 없다. 하지만 구글, 틴더 등의 회사에서 널리 사용하고 있으므로 장점을 간략히 알아보자.</p>
<ul>
<li>S2는 다양한 레벨로 임의의 영역을 커버할 수 있기 때문에 geofencing에 적합하다. <code>A geofence is a virtual perimeter for a real-world geographic area. A geo-fence could be dynamically generated—as in a radius around a point location, or a geo-fence can be a predefined set of boundaries (such as school zones or neighborhood boundaries)</code> from Wikipedia.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105181044720.png" alt=""></p>
<p>Geofencing을 사용하면 관심 지역을 둘러싸는 경계를 정의하고 해당 지역을 벗어난 사용자에게 알림을 보낼 수 있다. 이는 단순히 주변 업체를 반환하는 것보다 더 풍부한 기능을 제공할 수 있다.</p>
<ul>
<li>S2의 또 다른 장접은 Region Cover algorithm이다. Geohash처럼 고정된 밀도를 갖는 대신, S2에서는 최소 레벨, 최대 레벨, 최대 셀을 지정할 수 있다. 셀 크기가 유연하기 때문에 S2가 반환하는 결과는 더 세분화된다.</li>
</ul>
<h4 id="Recommendation"><a href="#Recommendation" class="headerlink" title="Recommendation"></a>Recommendation</h4><p>주변 비즈니스를 효율적으로 찾기 위해 Geohash, QuadTree, S2 등 몇 가지 옵션에 대해 논의했다. 아래서 볼 수 있듯이 회사가 니술마다 다른 옵션을 채택하고 있다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Geo Index</strong></th>
<th style="text-align:left"><strong>Companies</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Geohash</td>
<td style="text-align:left">Bing map, Redis, MongoDB, Lyft</td>
</tr>
<tr>
<td style="text-align:left">Quadtree</td>
<td style="text-align:left">Yext</td>
</tr>
<tr>
<td style="text-align:left">Both Geohash and Quadtree</td>
<td style="text-align:left">Elasticsearch</td>
</tr>
<tr>
<td style="text-align:left">S2</td>
<td style="text-align:left">Google Maps, Tinder</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Geohash-vs-quadtree"><a href="#Geohash-vs-quadtree" class="headerlink" title="Geohash vs quadtree"></a>Geohash vs quadtree</h4><p>이 섹션을 마무리하기 전에 둘에 대해 간단히 비교해보자.</p>
<h5 id="Geohash"><a href="#Geohash" class="headerlink" title="Geohash"></a>Geohash</h5><ul>
<li>사용과 구현이 쉽다. 트리를 만들 필요가 없다.</li>
<li>지정된 반경 내의 비즈니스 반환을 지원한다.</li>
<li>Geohash의 정밀도가 고정되어 있으면 그리드의 크기도 고정된다. 인구 밀도에 따라 그리드 크기를 동적으로 조정할 수 없다. 이를 지원하려면 더 복잡한 로직이 필요하다.</li>
<li>인덱스를 업데이트하는 것은 쉽다. 예를 들어, 인덱스에서 비즈니스를 제거하려 하면 동일한 geohash와 business_id를 가진 해당 행에서 비즈니스를 제거하기만 하면 된다.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105181702802.png" alt=""></p>
<h5 id="Quadtree"><a href="#Quadtree" class="headerlink" title="Quadtree"></a>Quadtree</h5><ul>
<li>트리를 구축해야 하므로 구현하기가 약간 더 어렵다</li>
<li>최인접 비즈니스 가져오기를 지원한다. 특정 반경 내에 비즈니스가 있는지 여부는 신경 쓰지 않고 가장 가까운 k-비즈니스만 반환하고 싶을 때가 있다. 예를 들어, 여행 중에 차에 기름이 부족할 때 가장 가까운 k개의 주유소를 찾고 싶을 수 있다. 이런 주유소가 사용자 근처에 없을 수도 있지만 앱은 가장 가까운 k개의 결과를 반환해야 한다. 이런 유형의 쿼리에는 쿼드트리가 적합하며, 쿼드트리의 세분화 프로세스는 숫자 k를 기반으로 하고 쿼리 결과를 반환할 때까지 쿼리 범위를 자동으로 조정할 수 있기 때문이다.</li>
<li>인구 밀도에 따라 그리드 크기를 동적으로 조정할 수 있다.</li>
<li>인덱스를 업데이트하는 것은 geohash 보다 더 복잡하다. 쿼드트리는 트리 구조다. 비즈니스를 제거하려면 루트에서 리프 노드까지 순회하여 비즈니스를 제거해야 한다. 예를 들어, ID가 2인 비즈니스를 제거하려면 아래와 같이 루트에서 리프노드까지 이동해야 한다. 인덱스를 업데이트하는 데는 O(logn) 시간이 걸리지만, 다중 스레드 프로그램에서 데이터 구조에 액세스하는 경우 잠금이 필요하므로 구현이 복잡해진다. 또한 트리의 리밸런싱도 복잡할 수 있다. 예를 들어 리프 노드에 새로운 노드를 추가할 공간이 없는 경우 리밸런싱이 필요하다. 가능한 해결 방법은 범위를 과도하게 할당하는 것이다.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105182110124.png" alt=""></p>
<h2 id="Step-3-Design-Deep-Dive"><a href="#Step-3-Design-Deep-Dive" class="headerlink" title="Step 3 - Design Deep Dive"></a>Step 3 - Design Deep Dive</h2><p>이제 세부 사항에 대해 저 사헤이 살펴보자.</p>
<ul>
<li>Scale the database</li>
<li>Caching</li>
<li>Region and availability zones</li>
<li>Filter results by time or business type</li>
<li>Final architecture diagram</li>
</ul>
<h3 id="Scale-the-database"><a href="#Scale-the-database" class="headerlink" title="Scale the database"></a>Scale the database</h3><p>가장 중요한 두 가지 테이블인 비즈니스 테이블과 지리공간 인덱스 테이블의 크기를 조정하는 방법에 대해 알아보자.</p>
<h4 id="Business-table-1"><a href="#Business-table-1" class="headerlink" title="Business table"></a>Business table</h4><p>비즈니스 테이블의 데이터는 하나의 서버에 모두 들어가지 않을 수 있으므로 샤당에 적합한 후보다. 가장 쉬운 접근 방식은 비즈니스 ID별로 모든 것을 샤딩하는 것이다. 이 샤딩 방식은 모든 샤드에 부하가 고르게 분산되도록 보장하며, 운영적으로도 유지 관리가 쉽다.</p>
<h4 id="Geospatial-index-table"><a href="#Geospatial-index-table" class="headerlink" title="Geospatial index table"></a>Geospatial index table</h4><p>Geohash와 QuadTree가 모두 널리 사용된다. Geohash가 더 단순하기 때문에 여기서는 geohash를 예로 사용한다. 테이블을 구성하는 방법에는 두 가지가 있다.</p>
<ul>
<li>Option 1 : 각 geohash 키에 단일 행의 비즈니스 ID의 JSON 배열이 있다. 즉, geohash 내의 모든 비즈니스 ID가 한 행에 저장된다.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105183408290.png" alt=""></p>
<ul>
<li>Option 2 : 동일한 geohash에 여러 비즈니스가 있는 경우, 각 비즈니스에 대해 하나씩 여러 행이 있다. 즉, geohash 내의 서로 다른 비즈니스 ID가 서로 다른 행에 저장된다.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105183446500.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>geohash</strong></th>
<th style="text-align:left"><strong>business_id</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">32feac</td>
<td style="text-align:left">343</td>
</tr>
<tr>
<td style="text-align:left">32feac</td>
<td style="text-align:left">347</td>
</tr>
<tr>
<td style="text-align:left">f3lcad</td>
<td style="text-align:left">112</td>
</tr>
<tr>
<td style="text-align:left">f3lcad</td>
<td style="text-align:left">113</td>
</tr>
</tbody>
</table>
</div>
<p>아래와 같은 이유로 2번째 옵션을 권장한다.</p>
<p>옵션 1의 경우 비즈니스를 업데이트하려면 business_ids 배열을 가져와 전체 배열을 스캔해 업데이트할 비즈니스를 찾아야 한다. 새 비즈니스를 삽입할 때는 전체 배열을 스캔해 중복이 없는지 확인해야 한다. 또한 동시 업데이트를 방지하기 위해 행을 잠가야 한다. 처리해야 할 엣지 케이스가 많이 있다.</p>
<p>옵션 2의 경우 복합 키가 (geohash, business_id)인 두 개의 열이 있는 경우, 비즈니스를 추가하고 제거하는 것은 매우 간단하다. 아무것도 잠글 필요가 없다.</p>
<p><strong>Scale the geospatial index</strong></p>
<p>위치 기반 정보 인덱스 확장에 대한 일반적인 실수 중 하나는 테이블의 실제 데이터 크기를 고려하지 않고 샤딩 체계로 빠르게 이동하는 것이다. 우리의 경우 위치 기반 정보 인덱스 테이블의 전체 데이터 집합은 크지 않다. 전체 위치 기반 정보 인덱스는 최신 데이터베이스 서버의 워크로드에 적합하다. 그러나 읽기 볼륨에 따라 단일 데이터베이스 서버에 모든 읽기 요청을 처리하기엔 충분한 CPU 또는 네트워크 대역폭이 없을 수 있다. 이 경우 여러 데이터베이스 서버에 읽기 부하를 분산시켜야 한다.</p>
<p>관계형 데이터베이스 서버의 부하를 분산하는 일반적인 접근 방식에는 두 가지가 있다. 읽기 복제본을 추가하거나 데이터베이스를 샤드할 수 있다.</p>
<p>많은 엔지니어들이 인터뷰 중에 샤딩에 대해 이야기하는 것을 좋아한다. 하지만 샤딩은 복잡하기 때문에 Geohash 테이블에는 적합하지 않을 수 있다. 예를 들어, 샤딩 로직을 애플리케이션 계층에 추가해야 한다. 때로는 샤딩이 유일한 옵션인 경우도 있다. 하지만 이 경우에는 데이터베이스 서버의 워크로드에 모든 것이 들어맞을 수 있으므로 여러 서버 간에 데이터를 샤딩할 강력한 기술적 이유가 없다.</p>
<p>이 경우 더 나은 접근 방식은 분산 읽기를 지원하는 일련의 읽기 복제본을 만드는 것이다. 이 방법은 개발 및 유지 관리가 훨씬 간단하다. 따라서 복제본을 통해 위치 기반 정보 인덱스 테이블을 확장하는 것이 좋다.</p>
<h3 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h3><p>캐시 레이어를 도입하기 전에 캐시 레이어가 정말 필요한지 생각해봐야 한다. 캐싱이 확실한 이득이라고 단언할 수 있는 것은 아니다.</p>
<ul>
<li>워크로드는 읽기 위주이고 데이터 집합은 상대적으로 작다. 데이터는 모든 최신 데이터베이스 서버의 작업 직합에 들어갈 수 있다. 따라서 쿼리는 I/O에 구속되지 않으며 인메모리 캐시만큼 빠르게 실행되어야 한다.</li>
<li>읽기 성능이 병목 현상인 경우 데이터베이스 읽기 복제본을 추가해 읽기 처리량을 개선할 수 있다.</li>
</ul>
<p>캐싱에 대해 면접관과 논의할 때는 신중한 벤치마킹과 비용 분석이 필요하므로 주의해야 한다. 캐싱이 비즈니스 요구 사항에 적합하다고 판단되면 캐싱 전략에 대한 논의를 진행할 수 있다.</p>
<h4 id="Cache-key"><a href="#Cache-key" class="headerlink" title="Cache key"></a>Cache key</h4><p>간단한 캐시 키 선택은 사용자의 위치 좌표(위 / 경도)다. 그러나 이 선택에는 몇 가지 문제가 있다.</p>
<ul>
<li>휴대폰에서 반환되는 위치 좌표는 최선의 추정치일 뿐이므로 정확하지 않다. 사용자가 이동하지 않더라도 휴대폰에서 좌표를 가져올 때마다 결과가 조금씩 달라질 수 있다.</li>
<li>사용자가 한 위치에서 다른 위치로 이동하면 위치 좌표가 약간 변경될 수 있다. 대부분의 애플리케이션에서 이런 변화는 큰 의미가 없다.</li>
</ul>
<p>따라서 위치 좌표는 좋은 캐시 키가 아니다. 이상적으로는 위치의 작은 변화에도 동일한 캐시 키에 매핑되어야 한다. 앞서 언급한 Geohash / QuadTree 솔루션은 그리드 내의 모든 비즈니스를 동일한 지오해시에 매핑하기 때문에 이 문제를 잘 처리할 수 있다.</p>
<h4 id="Types-of-data-to-cache"><a href="#Types-of-data-to-cache" class="headerlink" title="Types of data to cache"></a>Types of data to cache</h4><p>아래서 볼 수 있듯이 시스템의 전반적인 성능을 개선하기 위해 캐시할 수 있는 데이터에는 두 가지 유형이 있다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Key</strong></th>
<th style="text-align:left"><strong>Value</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">geohash</td>
<td style="text-align:left">List of business IDs in the grid</td>
</tr>
<tr>
<td style="text-align:left">business_id</td>
<td style="text-align:left">Business object</td>
</tr>
</tbody>
</table>
</div>
<p><strong>List of business IDs in a grid</strong></p>
<p>비즈니스 데이터는 비교적 안정적이므로, 주어진 geohash에 대한 비즈니스 ID 목록을 미리 계산해 Redis와 같은 KV Store에 저장한다. 캐싱이 활성화된 주변 비즈니스를 가져오는 구체적인 예를 살펴보자.</p>
<ol>
<li><p>주어진 Geohash에 대한 비즈니스 ID 목록을 가져온다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT business_id FROM geohash_index WHERE geohash LIKE `&#123;:geohash&#125;%`</span><br></pre></td></tr></table></figure>
</li>
<li><p>캐시에 누락된 경우 결과를 Redis 캐시에 저장한다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; getNearbyBusinessIds(String geohash) &#123;</span><br><span class="line">    String cacheKey = hash(geohash);</span><br><span class="line">    List&lt;string&gt; listOfBusinessIds = Redis.get(cacheKey);</span><br><span class="line">    if (listOfBusinessIDs  == null) &#123;</span><br><span class="line">        listOfBusinessIds = Run the select SQL query above;</span><br><span class="line">        Cache.set(cacheKey, listOfBusinessIds, &quot;1d&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return listOfBusinessIds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>새 비즈니스가 추가, 편집 또는 삭제되면 데이터베이스가 업데이트되고 캐시가 무효화된다. 이런 작업의 양이 상대적으로 적고 geohash 접근 방식에는 잠금 메커니즘이 필요하지 않으므로 업데이트 작업을 쉽게 처리할 수 있다.</p>
<p>요구 사항에 따라 사용자는 클라이언트에서 500m, 1km, 2km, 5km의 4가지 반경을 선택할 수 있다. 이런 반경은 각각 4, 5, 5, 5, 6의 geohash 길이에 맵핑된다. 반경이 다른 주변 비즈니스를 빠르게 가져올 수 있도록 세 가지 정밀도(geohash_4, geohash_5, geohash_6) 모두에 대해 데이터를 redis에 캐시한다.</p>
<p>앞서 언급했듯이 2억 개의 비즈니스가 있고 각 비즈니스는 주어진 정밀도로 1개의 그리드에 속한다. 따라서 필요한 총 메모리는 아래와 같다.</p>
<ul>
<li>Storage for Redis values : 8byte <em> 2M </em> 3 precisions = ~5GB</li>
<li>Storage for Redis keys : negligible</li>
<li>Total memory required : ~5 GB</li>
</ul>
<p>메모리 사용량 관점에서는 최신 Redis 서버 한대로도 충분하지만 고가용성을 보장하고 대륙 간 지연 시간을 줄이기 위해 전 세계에 걸쳐 Redis 클러스터를 배포한다. 예상 데이터 크기를 감안할 때, 전 세계에 동일한 캐시 데이터 복사본을 배포할 수 있다. 최종 아키텍처 다이어그램에서는 이 Redis 캐시를 “geohash”라 부른다.</p>
<p><strong>Business data needed to render pages on the client</strong></p>
<p>이런 유형의 데이터는 캐싱하기가 매우 간단하다. 키는 business_id이고 값은 비즈니스 이름, 주소, 이미지 URL 등이 포함된 비즈니스 객체다. 최종 아키텍처 다이어그램에서는 이 Redis 캐시를 “Business info”라 부른다.</p>
<h3 id="Region-and-availability-zones"><a href="#Region-and-availability-zones" class="headerlink" title="Region and availability zones"></a>Region and availability zones</h3><p>아래와 같이 여러 지역 및 가용성 영역에 위치 기반 서비스를 배포한다. 여기에는 몇 가지 장점이 있다.</p>
<ul>
<li>사용자를 시스템에 물리적으로 “더 가깝게” 연결한다. 미국 서부의 사용자는 해당 지역의 데이터 센터에 연결되고, 유럽의 사용자는 유럽의 데이터 센터에 연결된다.</li>
<li>트래픽을 인구 전체에 고르게 분산할 수 있는 유연성을 제공한다. 일본이나 한국과 같은 일부 지역은 인구 밀도가 높다. 따라서 별도의 지역에 배치하거나 여러 가용 영역에 위치 기반 서비스를 배포해 부하를 분산하는 것이 현명할 수 있다.</li>
<li>개인정보 보호법. 일부 국가에서는 사용자 데이터를 로컬에서 사용하고 저장하도록 요구할 수 있다. 이 경우 해당 국가에 리전을 설정하고 DNS 라우팅을 사용해 해당 국가로부터의 모든 요청을 해당 리전으로만 제한할 수 있다.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105185830323.png" alt=""></p>
<h3 id="Follow-up-question-filter-results-by-time-or-business-type"><a href="#Follow-up-question-filter-results-by-time-or-business-type" class="headerlink" title="Follow-up question: filter results by time or business type"></a>Follow-up question: filter results by time or business type</h3><p>이런 후속 질문을 생각해볼 수 있다. 현재 영업중인 비즈니스도 반환할 수 있는지, 아니면 특정 카테고리(e.g. 식당)의 비즈니스만 반환할 수 있는지</p>
<ul>
<li>Geohash 또는 QuadTree를 사용해 전 세계를 작은 격자로 나누면 검색 결과에서 반환되는 비즈니스의 수가 상대적으로 적다. 따라서 비즈니스 ID를 먼저 반환하고 비즈니스 오브젝트를 hydrate한 다음 영업시간이나 비즈니스 유형이 따라 필터링하는 것이 허용된다. 이 솔루션에는 영업 시간과 업종이 비즈니스 테이블에 저장되어 있다고 가정한다.</li>
</ul>
<h3 id="Final-design-diagram"><a href="#Final-design-diagram" class="headerlink" title="Final design diagram"></a>Final design diagram</h3><p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105190248108.png" alt=""></p>
<h4 id="Get-nearby-businesses"><a href="#Get-nearby-businesses" class="headerlink" title="Get nearby businesses"></a>Get nearby businesses</h4><ol>
<li>Yelp에서 500미터 이내에 있는 레스토랑을 찾으려 한다. 클라이언트가 사용자 위치(위도 = 37.776720, 경도 = -122.416730)와 반경(500m)을 로드 밸런서에 전송한다.</li>
<li>로드밸런서는 요청을 LBS로 전달한다.</li>
<li>LBS는 사용자 위치 및 반경 정보를 기반으로 검색과 일치하는 geohash 길이를 찾는다. </li>
<li>LBS는 인접한 geohash를 계산해 목록에 추가한다. 결과는 다음와 같다. <code>list_of_geohashes = [my_geohash, neighbor1_geohash, neighbor2_geohash, …, neighbor8_geohash]</code>.</li>
<li><code>list_of_geohashes</code>의 각 geohash에 대해 LBS는 “Geohash Redis” 서버를 호출해 해당 비즈니스 ID를 가져온다. 지연 시간을 줄이기 위해 각 geohash에 대한 비즈니스 ID를 가져오는 호출을 병렬로 수행할 수 있다.</li>
<li>반환된 비즈니스 ID 목록을 기반으로 LBS는 “Business info Redis” 서버에서 완전히 hydrate된 비즈니스 정보를 가져온 다음, 사용자와 비즈니스 간의 거리를 계산하고 순위를 매긴 후 결과를 클라이언트에 반환한다.</li>
</ol>
<h4 id="View-update-add-or-delete-a-business"><a href="#View-update-add-or-delete-a-business" class="headerlink" title="View, update, add or delete a business"></a>View, update, add or delete a business</h4><p>모든 비즈니스 관련 API는 LBS에서 분리되어 있다. 비즈니스에 대한 상세 정보를 보기 위해 비즈니스 서비스는 먼저 데이터가 “Business info Redis” 캐시에 저장되어 있는지 확인한다. 저장되어 있으면 캐시된 데이터가 클라이언트에 반환된다. 그렇지 않은 경우, 데이터베이스 클러스터에서 데이터를 가져온 다음 Redis 캐시에 저장해 후속 요청에서 캐시에서 직접 결과를 가져올 수 있도록 한다.</p>
<p>새로 추가 / 업데이트된 비즈니스는 다음 날 부터 효력이 발생한다는 사전 비즈니스 계약이 있기 때문에 캐시된 비즈니스 데이터는 야간 작업을 통해 업데이트 된다.</p>
<h2 id="Step-4-Wrap-Up"><a href="#Step-4-Wrap-Up" class="headerlink" title="Step 4 - Wrap Up"></a>Step 4 - Wrap Up</h2><p>이 포스트에서는 proximity service를 위한 설계를 알아봤다. 이 시스템은 지리 공간 인덱싱을 활용하는 전형적인 LBS다. 몇 가지 인덱싱 옵션에 대해서도 알아봤다.</p>
<ul>
<li>Two-dimensional search</li>
<li>Evenly divided grid</li>
<li>Geohash</li>
<li>Quadtree</li>
<li>Google S2</li>
</ul>
<p>Geohash, QuadTree, S2에 대해서 살펴보았고, 심층 분석에서는 캐싱이 지연 시간을 줄이는데 효과적인 이유, 캐싱을 해야하는 항목, 캐시를 사용하여 주변 비즈니스를 빠르게 검색하는 방법에 대해 논의했다. 또한 복제 및 샤딩을 통해 데이터베이스를 확장하는 방법에 대해서도 논의했다.</p>
<p>그런 다음 가용성을 개선하고 사용자가 서버에 물리적으로 더 가까이 접근할 수 있도록 하며, 현지 개인정보 보호법을 더 잘 준수하기 위해 다양한 지역과 가용성 영역에 LBS를 배포하는 방안을 검토했다.</p>
<h2 id="Chapter-Summary"><a href="#Chapter-Summary" class="headerlink" title="Chapter Summary"></a>Chapter Summary</h2><p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231105191238316.png" alt=""></p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2023/11/05/System%20Design/ByteByteGo/book/proximity-service/">https://songhayoung.github.io/2023/11/05/System%20Design/ByteByteGo/book/proximity-service/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2024 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>