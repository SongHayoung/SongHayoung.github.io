<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[ByteByteGo] Good Code vs. Bad Code"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[ByteByteGo] Good Code vs. Bad Code | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Good-Code-vs-Bad-Code"><span class="toc-number">1.</span> <span class="toc-text">Good Code vs. Bad Code</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-Good-Code-Matters"><span class="toc-number">2.</span> <span class="toc-text">Why Good Code Matters?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Importance-of-Good-Names"><span class="toc-number">3.</span> <span class="toc-text">The Importance of Good Names</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Perils-of-Copying-Code"><span class="toc-number">4.</span> <span class="toc-text">The Perils of Copying Code</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Too-Many-Parameters"><span class="toc-number">5.</span> <span class="toc-text">Too Many Parameters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Avoiding-Nested-Conditional-Logic"><span class="toc-number">6.</span> <span class="toc-text">Avoiding Nested Conditional Logic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Benefits-of-Immutable-Data"><span class="toc-number">7.</span> <span class="toc-text">The Benefits of Immutable Data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Managing-Technical-Debt"><span class="toc-number">8.</span> <span class="toc-text">Managing Technical Debt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Summary"><span class="toc-number">9.</span> <span class="toc-text">Summary</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/hayoung-song-9523b61bb/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">10973</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">195</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">62</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[ByteByteGo] Good Code vs. Bad Code</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-02-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/Byte-Byte-Go/">Byte Byte Go</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1.5k</span><span class="post-meta__separator">|</span><span>Reading time: 9 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Good-Code-vs-Bad-Code"><a href="#Good-Code-vs-Bad-Code" class="headerlink" title="Good Code vs. Bad Code"></a>Good Code vs. Bad Code</h2><span id="more"></span>
<h2 id="Why-Good-Code-Matters"><a href="#Why-Good-Code-Matters" class="headerlink" title="Why Good Code Matters?"></a>Why Good Code Matters?</h2><p>좋은 코드에 관심을 가져야 하는 이유는 무엇일까? 소프트웨어의 기초라고 생각하면 된다. 좋은 코드는 단순히 작동하게 만드는 것이 아니라 효율적이고 지속 가능하게 만드는 것이다. 이는 원활하고 효율적인 개발 환경과 답답하고 시간이 많이 소요되는 개발 환경의 차이다.</p>
<p>좋은 코드는 프로젝트가 복잡해지더라도 안정성과 예측 가능성을 유지한다. 이는 작업이 아무리 힘들어지더라도 계속 작동하는 신뢰할 수 있는 도구를 사용하는 것과 같다. 확장에 있어서도 좋은 코드는 필수적이다. 근시안적인 접근 방식에서 오는 병목 현상과 골칫거리 없이 확장할 수 있다.</p>
<p>물론 좋은 코드를 만들려면 처음에 더 많은 생각과 노력이 필요하다. 하지만 이런 투자는 장기적으로 비용을 절감함으로써 보상을 받을 수 있다. 반면에 잘못된 코드는 시한폭탄과 같아서 업데이트가 어렵고 비용이 많이 드는 재작성으로 이어질 수 있다.</p>
<p>팀워크와 연속성이라는 측면도 있다. 일반적으로 잘 문서화되어 있고 표준을 준수하는 고품질 코드는 팀이 더 쉽게 협업할 수 있게 해준다. 온보딩 프로세스가 간소화되고, 출시가 빨라지며, 팀 확장이 용이해진다. </p>
<p>Hypothetical knob-turning 메커니즘의 두 가지 디자인을 비교해 보자. “좋은 코드”는 유연하고 조정하기 쉬운 벨트 메커니즘을 사용한다. 그러나 “나쁜 코드” 버전은 딱딱한 막대를 사용하는데, 이는 변경이 필요할 때 더 제한적이고 복잡해지기 쉽다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240202175139453.png" alt=""></p>
<p>요구사항이 변경되어 knob를 재배치해야할 경우 벨트 메커니즘이 있는 “좋은 코드”는 간단한 확장으로 이를 쉽게 수용할 수 있다. 단단한 막대가 있는 “나쁜 코드”는 완전히 새로운 구성이 필요하므로 시간이나 비용 면에서 효율적이지 않다. 또 다른 불가피한 수정 사항으로 인식이 회전하는 속도를 변경해야 한다. “좋은 코드”는 다른 크기의 기어로 간단히 전환하면 된다. 그러나 “나쁜 코드” 설정은 추가 부품이 필요하고 시스템이 더 복잡해지고 파손되기 쉬우므로 점점 더 복잡해진다.</p>
<p>특히 리소스가 제한되어 있고 미래가 불확실한 스타트업의 경우, 처음부터 오버엔지니어링을 옹호하는 것은 아니다. 핵심은 코딩 선택의 장기적인 영향을 이해하는 것이다. 지나치게 복잡한 시스템을 조기에 구축하는 것은 빠른 해결책을 반복적으로 선택하는 것 만큼이나 비생산적일 수 있다. 적절한 균형을 맞추는 것은 경험과 사려 깊은 고려를 통해 얻을 수 있는 감각과 기술이다.</p>
<h2 id="The-Importance-of-Good-Names"><a href="#The-Importance-of-Good-Names" class="headerlink" title="The Importance of Good Names"></a>The Importance of Good Names</h2><p>코딩 표준은 클래스, 함수, 변수 등에 대한 명명 규칙에서 시작하는 경우가 많다. 이는 간단해 보이지만 사려 깊은 설계가 필요하다. 아래와 같은 서비스 클래스 이름을 보자.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OrderManagementService</span><br><span class="line">PaymentManagementService</span><br><span class="line">DatabaseManagementService</span><br></pre></td></tr></table></figure>
<p>모든 이름에 “ManagementService”라는 접미사를 붙이면 이름이 불필요하게 길고 반복적이 된다. 다음으로 이 함수를 살펴보자.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean processPayment(PaymentInstruction paymentInstruction) &#123;   </span><br><span class="line">Channel preferredChannel = paymentInstruction.getChannel();     channelFactory.getChannel(preferredChannel)</span><br><span class="line">                .send(paymentInstruction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>명명 규칙을 따르고 있음에도 불구하고 “processPayment”는 정확히 어떤 일이 일어나는지 전달하지 못한다. “처리”라는 단어가 너무 일반적이다. 결제의 현재 상태와 이를 통해 무엇을 할 것인지 알려주지 않는다.</p>
<p>코드를 읽어보면 결제 명령을 처리하기 위해 외부 채널로 전송한다는 것을 알 수 있다. “sendPaymentToExternalChannel()”이라고 이름을 지을 수 있지만 너무 많은 세부 정보가 노출된다. 내부 세부 정보를 노출하지 않고 결제 흐름을 시작하는 것을 나타내므로 “startPayment()”가 좋은 선택이 될 수 있다.</p>
<p>이와 같은 좋은 이름은 협업 시 과도한 코멘트의 필요성을 줄인다. 다른 예를 살펴보자.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String userId = paymentInstruction.getUserId();</span><br></pre></td></tr></table></figure>
<p>“userId”를 “payerId”와 같은 도메인 관련성이 높은 이름으로 바꾸면 좋다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String payerId = paymentInstruction.getPayerId();</span><br></pre></td></tr></table></figure>
<p>결론적으로 효과적인 이름은 다음과 같아야 한다.</p>
<ul>
<li>목적을 간결하고 정확히 설명</li>
<li>비즈니스 도메인 용어 사용</li>
<li>구현 세부 사항 미노출</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240202175105404.png" alt=""></p>
<h2 id="The-Perils-of-Copying-Code"><a href="#The-Perils-of-Copying-Code" class="headerlink" title="The Perils of Copying Code"></a>The Perils of Copying Code</h2><p>때로는 긴급한 비즈니스 요구사항이 발생하지만 기존 코드를 수정하는 것은 테스트가 거의 없이 캡슐화되어 있기 때문에 너무 위험하다. 이런 상황에서는 지름길로 코드의 일부를 새 구성 요소에 복사한 다음 새로운 요구 사항에 맞게 수정을 시작하고 싶은 유혹에 빠지기 쉽다.</p>
<p>규정을 준수해야하는 Know Your Client (KYC) 서비스를 구축할 때 이런 상황에 직면한 적이 있다. 이 서비스에는 다른 곳에서 사용되는 긴밀히 결합된 UserService 모듈에 이미 존재하는 사용자 관리 기능이 필요했다. UserService를 모듈화할 시간이 부족했기 때문에 관련 부분을 새로운 KYC 서비스에 복사해 커스터마이징 했다.</p>
<p>그래서 사용자 서비스 로직의 중복된 두 가지 버전이 오랫동안 유지되었다. 사용자 관련 기능을 업데이트해야 할 때마다 원래 UserService와 KYC 서비스에 복사된 코드, 두 곳을 모두 수정해야 했다. 개발자는 이 사실을 잊어버리는 경우가 많았고 이로 인해 일관성 없는 동작과 중단이 발생했다. 동일한 로직의 중복 복사본을 동기화 상태로 유지하면 오류가 발생하기 쉬웠다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240202175050986.png" alt=""></p>
<p>이 문제는  소프트웨어 개발 핵심인 “Don’t Repeat Yourself(DRY)” 원칙에 위배된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240202175038724.png" alt=""></p>
<p>정적 분석기는 코드 중복 문제를 식별하는데 도움이 되지만 개발자가 처음부터 잘 추상화된 컴포넌트를 선제적으로 설계해 기술 부채를 만들지 않도록 하는 것이 중요하다. 미리 시간을 할애해 UserService와 같은 모듈을 확장 지점이 있는 재사용 가능한 핵심 라이브러리로 리팩토링하는 것이 도움이 될 수 있다.</p>
<p>우리 모두는 마감 기한에 쫓겨 어설픈 지름길을 택해야 한다는 극심한 압박에 직면한 적이 있다. 하지만 늦게 해결하든 일찍 해결하든 기술 부채는 시간이 지남에 따라 이자를 발생시킨다. 우리는 우리가 가진 모든 영향력을 활용해 이해관계자들이 작은 단계라도 보다 지속 가능한 사고로 나아가도록 부드럽게 안내해야 한다.</p>
<h2 id="Too-Many-Parameters"><a href="#Too-Many-Parameters" class="headerlink" title="Too Many Parameters"></a>Too Many Parameters</h2><p>이런 코드를 본 적이 있을 것이다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PaymentInstruction createPaymentInstruction(String payerId,</span><br><span class="line">                                            String receiverId,</span><br><span class="line">                                            String orderId,</span><br><span class="line">                                           Channel preferredChannel, </span><br><span class="line">                                           String callbackUrl,</span><br><span class="line">                                           Currency currency,</span><br><span class="line">                                           Amount amount) &#123;</span><br><span class="line">   // create payment instruction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>매개변수가 7개이면 시간이 지날수록 관리가 어려워진다. 매개변수를 하나의 객체로 캡슐화할 수 있다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class PaymentInstructionParameters &#123;</span><br><span class="line">    private String payerId;</span><br><span class="line">    private String receiverId;</span><br><span class="line">    private String orderId;</span><br><span class="line">    private Channel preferredChannel;</span><br><span class="line">    private String callbackUrl;</span><br><span class="line">    private Currency currency;</span><br><span class="line">    private Amount amount; </span><br><span class="line">&#125;</span><br><span class="line">PaymentInstruction createPaymentInstruction(</span><br><span class="line">    final PaymentInstructionParameters params) &#123;</span><br><span class="line">    // create payment instruction</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>이 방식이 더 낫지만 문자열 매개변수는 오류가 발생하기 쉽다. 실수로 ID를 바꿀 수 있다. 빌더 패턴을 사용하면 이 문제가 개선된다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class PaymentInstructionParameters &#123;</span><br><span class="line">  private String payerId;</span><br><span class="line">  private String receiverId;</span><br><span class="line">  private String orderId;</span><br><span class="line">  private Channel preferredChannel;</span><br><span class="line">  private String callbackUrl;</span><br><span class="line">  private Currency currency;</span><br><span class="line">  private Amount amount; </span><br><span class="line"></span><br><span class="line">  public PaymentInstruction newPaymentInstruction() &#123;</span><br><span class="line">    return PaymentInstruction.builder()</span><br><span class="line">                             .payerId(payerId)</span><br><span class="line">                             .receiverId(receiverId)</span><br><span class="line">                             .orderId(orderId)</span><br><span class="line">                             .preferredChannel(preferredChannel)</span><br><span class="line">                             .callbackUrl(callbackUrl)</span><br><span class="line">                             .currency(currency)</span><br><span class="line">                             .amount(amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 각 매개변수는 독립된 빌더 클래스에서 명시적으로 설정된다. 따라서 소비자의 복잡성과 실수가 줄어든다. 복잡한 매개변수를 대상 팩토리 / 빌더가 있는 잘 정의된 객체로 캡슐화하면 이해도와 안정성이 향상된다.</p>
<h2 id="Avoiding-Nested-Conditional-Logic"><a href="#Avoiding-Nested-Conditional-Logic" class="headerlink" title="Avoiding Nested Conditional Logic"></a>Avoiding Nested Conditional Logic</h2><p>중첩된 “if-else” 문이 너무 많으면 코딩의 악취로 간주된다. 아래 다이어그램은 그 예를 보여준다. 논리는 단순하게 시작될 수 있지만, 시간이 지남에 따라 개발자는 새로운 조건문을 계속 추가하게 된다. 얼마 지나지 않아 다음과 같이 된다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(condition)  &#123;</span><br><span class="line">   //Nested if else inside the body of “if”</span><br><span class="line">   if(condition2)  &#123;</span><br><span class="line">       //Statements inside the body of nested “if”</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      //Statement inside the body of nested “else”</span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line">else  &#123;</span><br><span class="line">   //Statement inside the body of “else” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이런 조건부 논리의 가독성을 높이기 위한 가이드라인이 있다.</p>
<ol>
<li>조건이 실패하면 중첩하지 않고 함수에서 일찍 반환한다.</li>
<li>복잡한 조건 검사는 description function이나 메서드로 캡슐화 한다. 예를 들어 Google Guava는 Preconditions 유틸리티 클래스를 제공한다.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static double sqrt(double value) &#123;</span><br><span class="line">     Preconditions.checkArgument(value &gt;= 0.0, &quot;negative value: %s&quot;, value);</span><br><span class="line">     // calculate the square root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>목표는 검사를 분산하고 블록을 명확한 책임이 있는 응집력 있는 단위로 추출해 중첩된 로직을 평평하게 만드는 것이다. 이렇게 하면 시간이 지나면서 새로운 요구사항이 발생해도 가독성과 유지보수성이 향상된다.</p>
<h2 id="The-Benefits-of-Immutable-Data"><a href="#The-Benefits-of-Immutable-Data" class="headerlink" title="The Benefits of Immutable Data"></a>The Benefits of Immutable Data</h2><p>최신 IDE를 사용하면 기본적으로 클래스에 대한 getter와 setter가 생성된다. 편리하긴 하지만 원활 때마다 데이터를 수정할 수 있기 때문에 사소한 변경으로 인해 버그가 발생할 수 있다. 마틴 파울러는 리팩토링의 코드 냄새 중 하나로 가변 데이터를 포함한다.</p>
<p>함수형 프로그래밍에서 객체의 상태는 생성 후에는 변경할 수 없다. 값을 업데이트하려면 값을 새 객체에 복사(deep copy)한다. 불변 데이터 구조는 여러 프로세스가 충돌의 위험 없이 데이터에 액세스하고 조작할 수 있게 함으로써 병렬 처리를 가능하게 한다.</p>
<p>객체 지향 코드에는 우발적인 데이터 변경을 방지하는 요령이 있다.</p>
<ol>
<li>setter 제거. 예를 들어 외부 결제 채널에서 콜백을 수신할 때 값을 직접 수정하는 대신 API를 통해 상태를 업데이트해라.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class PaymentInstruction &#123;</span><br><span class="line">    PaymentInstruction complete(CallBackResult result) &#123;</span><br><span class="line">        return new PaymentInstruction(..., result.getCode(), ...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>이벤트 소싱 사용. 이 프로그래밍 패러다임에서 이벤트는 변경할 수 없으며 append-only 이벤트 스토어에 저장할 수 있다. 이벤트는 1등 시민이다. 객체의 상태를 변경하려면 변경 불가능한 이벤트를 새로 생성한다.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class EventHandler &#123;</span><br><span class="line">    void onNewEvent(NewPaymentEvent newPaymentEvent) &#123;</span><br><span class="line">        createPayment(newPaymentEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    void onUpdateEvent(UpdatePaymentEvent updatePaymentEvent) &#123;</span><br><span class="line">        payment.apply(newPaymentEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>불변 데이터를 수용하면 보다 강력하고 유지 관리가 용이하며 병렬화 가능한 코드를 만들 수 있다. 설정자를 제거하고 이벤트 소싱을 사용하는 등의 전략을 통합함으로써 객체 지향 프로그래밍도 불변성의 이점을 누릴 수 있다. 기존의 변경 가능한 관행에서 사고 방식의 전환이 필요할 수 있지만, 그 결과 코드 품질과 시스템 안정성이 향상되므로 노력할 만한 가치가 있다.</p>
<h2 id="Managing-Technical-Debt"><a href="#Managing-Technical-Debt" class="headerlink" title="Managing Technical Debt"></a>Managing Technical Debt</h2><p>나쁜 코드 냄새는 시간이 지남에 따라 기술 부채로 누적될 수 있다. 금융 부채와 마찬가지로 기술 부채도 단기적으로는 이익을 얻을 수 있지만 궁극적으로는 상환이 필요하다. 기술 부채를 효과적으로 관리하는 것은 필수적이다. 소프트웨어 프로젝트에서 부채를 완전히 없앨 수는 없다. 부채를 받아들이고 적절히 관리해야 한다.</p>
<ol>
<li>Quantify debt : SonarQube와 같은 도구는 해결을 위한 노력 측면에서 기술 부채를 강조하는 지표를 통합한다. 부채를 추적하면 코드에 통제되지 않은 부채가 쌓이는 것을 방지할 수 있다.</li>
<li>Strategically leverage debt when urgency demands it : “빠르고 더러운” 솔루션은 비즈니스 기회를 포착하기 위해 빠르게 움직일 수 있게 해준다. 기술 부채는 초기에 시장 지배력을 빠르게 확보하는데 레버리지를 제공할 수 있다.</li>
<li>Allocate resources to pay down debt : 매 스프린트마다 리팩토링 작업 일정을 잡거나 몇 달에 한 번씩 “기술 부채 주간”을 개최해라. 이렇게 하면 부채가 너무 오래 지속되는 것을 방지할 수 있다.</li>
<li>Convey the urgency to management : 재난이 닥치기 전에 “화창한 날에 지붕을 수리하는” 마음으로 경영진의 동참을 이끌어내라. 아래 다이어그램은 주요 이해관계자가 너무 늦게까지 부채를 관리하지 않는 최악의 시나리오를 보여준다.</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240202175018112.png" alt=""></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>몇 가지 일반적인 코드 냄새와 권장되는 리팩토링 솔루션에 대해 논의했다. 장기적으로 고품질 코드는 유지보수 비용을 절감하고 시스템 안정성과 유지보수성을 향상시킨다.</p>
<p>또한 빠른 개발 지름길을 통해 기술 부채가 쌓이는 현실에 대해서도 논의했다. 금융 부채와 마찬가지로 기술 부채를 관리하면 전략적으로 단기 납기를 앞당길 수 있다. 하지만 너무 늦기 전에 부채를 상환할 수 있는 시간을 할당해야 한다.</p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2024/02/02/System%20Design/ByteByteGo/private/good-code-vs-bad-code/">https://songhayoung.github.io/2024/02/02/System%20Design/ByteByteGo/private/good-code-vs-bad-code/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2024 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>