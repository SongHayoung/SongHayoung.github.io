<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[ByteByteGo] A Crash Course on Relational Database Design"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[ByteByteGo] A Crash Course on Relational Database Design | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-Crash-Course-on-Relational-Database-Design"><span class="toc-number">1.</span> <span class="toc-text">A Crash Course on Relational Database Design</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#What-is-a-Relational-Database"><span class="toc-number">2.</span> <span class="toc-text">What is a Relational Database?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-The-Language-of-Relational-Databases"><span class="toc-number">3.</span> <span class="toc-text">SQL: The Language of Relational Databases</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fundamental-RDBMS-Concepts"><span class="toc-number">4.</span> <span class="toc-text">Fundamental RDBMS Concepts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Keys-in-Relational-Databases"><span class="toc-number">5.</span> <span class="toc-text">Keys in Relational Databases</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Primary-Key-and-Indexing"><span class="toc-number">5.1.</span> <span class="toc-text">Primary Key and Indexing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Surrogate-Key-and-Natural-Key"><span class="toc-number">5.2.</span> <span class="toc-text">Surrogate Key and Natural Key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Foreign-Key"><span class="toc-number">5.3.</span> <span class="toc-text">Foreign Key</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Relationship-Types-in-Relational-Databases"><span class="toc-number">6.</span> <span class="toc-text">Relationship Types in Relational Databases</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#One-to-One-Relationship"><span class="toc-number">6.1.</span> <span class="toc-text">One-to-One Relationship</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#One-to-Many-Relationship"><span class="toc-number">6.2.</span> <span class="toc-text">One-to-Many Relationship</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Many-to-Many-Relationship"><span class="toc-number">6.3.</span> <span class="toc-text">Many-to-Many Relationship</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Database-Normalization"><span class="toc-number">7.</span> <span class="toc-text">Database Normalization</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1NF-First-Normal-Form-of-Database-Normalization"><span class="toc-number">7.1.</span> <span class="toc-text">1NF (First Normal Form of Database Normalization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2NF-Second-Normal-Form-of-Database-Normalization"><span class="toc-number">7.2.</span> <span class="toc-text">2NF (Second Normal Form of Database Normalization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3NF-Third-Normal-Form-of-Database-Normalization"><span class="toc-number">7.3.</span> <span class="toc-text">3NF (Third Normal Form of Database Normalization)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Joins-in-Relational-Databases"><span class="toc-number">8.</span> <span class="toc-text">Joins in Relational Databases</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Inner-Join"><span class="toc-number">8.1.</span> <span class="toc-text">Inner Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Right-Outer-Join"><span class="toc-number">8.2.</span> <span class="toc-text">Right Outer Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Left-Outer-Join"><span class="toc-number">8.3.</span> <span class="toc-text">Left Outer Join</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/hayoung-song-9523b61bb/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">11377</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">198</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">62</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[ByteByteGo] A Crash Course on Relational Database Design</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-07-19</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/Byte-Byte-Go/">Byte Byte Go</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2.5k</span><span class="post-meta__separator">|</span><span>Reading time: 15 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="A-Crash-Course-on-Relational-Database-Design"><a href="#A-Crash-Course-on-Relational-Database-Design" class="headerlink" title="A Crash Course on Relational Database Design"></a>A Crash Course on Relational Database Design</h2><span id="more"></span>
<p>관계형 데이터베이스는 엔티티 간의 잘 절ㅇ의된 관계를 기반으로 데이터를 저장하고 검색할 수 있는 강력한 프레임워크를 제공한다. 관계형 데이터베이스는 데이터 관리에 대한 구조화된 접근 방식을 제공해 사용자가 다음 작업을 수행할 수 있도록 돕는다.</p>
<ul>
<li>테이블 정의</li>
<li>관계 설정</li>
<li>복잡한 쿼리를 수행해 저장된 정보에서 의미있는 인사이트 추출</li>
</ul>
<p>효과적인 데이터베이스 설계는 성능을 최적화하고, 데이터 무결성을 보장하며, 효율적인 데이터 검색을 촉직하는데 매우 중요하다. 정규화, 인덱싱, 조인, 관계와 같은 데이터베이스 설계의 원칙은 잘 구조화되고 성능이 우수한 데이터베이스를 만드는데 중요한 역할을 한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240719090700838.png" alt=""></p>
<h2 id="What-is-a-Relational-Database"><a href="#What-is-a-Relational-Database" class="headerlink" title="What is a Relational Database?"></a>What is a Relational Database?</h2><p>관계형 데이터베이스는 데이터를 구조화된 테이블로 구성하는 데이터베이스의 한 유형이다. 이런 테이블은 rows(records)와 columns(fields)로 구성되며 효율적인 데이터 저장 및 검색을 가능하게 하는 표 형식의 구조를 형성한다. 관계형 데이터베이스의 강점은 여러 테이블 간에 관계를 설정하는 기능에 있다. 관련 테이블 간의 연결을 정의하면 정보를 연결하고 결합할 수 있다. 이를 통해 여러 테이블에 걸친 복잡한 쿼리와 데이터 검색 작업을 수행할 수 있으므로 다양한 방식으로 데이터에 액세스하고 분석할 수 있다.</p>
<p>관계형 데이터베이스를 효과적으로 사용하려면 관계형 데이터베이스 관리 시스템(RDBMS)이 필요하다. RDBMS는 관계형 데이터베이스를 만들고, 관리하고, 상호 작용하도록 설계된 소프트웨어 애플리케이션이다. RDBMS가 제공하는 몇 가지 주요 기능은 다음과 같다.</p>
<ul>
<li>데이터 정의 : 테이블, 열, 데이터 유형, 제약 조건 등 데이터베이스의 구조를 정의한다.</li>
<li>데이터 조작 : 데이터베이스에 저장된 데이터에 대해 다양한 작업을 수행한다. 여기에는 새 레코드 삽입, 기존 레코드 업데이트, 레코드 삭제 등이 포함된다.</li>
<li>데이터 무결성 : RDBMS는 데이터의 정확성과 일관성을 유지하기 위해 데이터 무결성 규칙을 적용한다.</li>
<li>데이터 보안 : RDBMS는 사용자 역할, 권한, 인증 수단을 정의해 데이터베이스에 대한 액세스를 제어하는 메커니즘도 제공한다.</li>
<li>쿼리 최적화 : RDBMS는 복잡한 쿼리 실행을 최적화해 데이터를 효율적으로 검색한다. 인덱싱 및 쿼리 최적화 알고리즘과 같은 다양한 기술을 사용한다.</li>
</ul>
<p>시중에는 각기 다른 특징과 기능을 갖춘 여러 RDBMS가 나와있다.</p>
<ul>
<li>MySQL : 단순성, 안정성 및 광범위한 채택으로 잘 알려진 오픈소스 RDBMS</li>
<li>PostgreSQL : 고급 기능과 강력한 데이터 무결성 지원 기능을 갖춘 오픈소스 RDBMS</li>
<li>Oracle Database : 엔터프라이즈 환경에서 일반적으로 사용되는 포괄적이고 풍부한 기능을 갖춘 RDBMS</li>
</ul>
<h2 id="SQL-The-Language-of-Relational-Databases"><a href="#SQL-The-Language-of-Relational-Databases" class="headerlink" title="SQL: The Language of Relational Databases"></a>SQL: The Language of Relational Databases</h2><p>SQL은 관계형 데이터베이스와 상호작용하는데 사용되는 표준 프로그래밍 언어다. 이 언어의 주요 장점 중 하나는 범용성이다. MySQL, PostgreSQL, Oracle 등에서 작업할 때 구문은 거의 동일하게 유지된다. 이런 이식성 덕분에 개발자는 최소한의 학습 곡선으로 다른 RDBMS로 전환할 수 있다.</p>
<p>SQL은 개발자와 데이터베이스 관리자가 데이터베이스에 저장된 데이터에 대해 다양한 작업을 수행할 수 있는 포괄적인 명령어와 구문 세트를 제공한다. SQL은 데이터 조작을 위한 네 가지 기본 작업을 지원하며, 일반적으로 CRUD로 알려져있다. 추가적으로 SQL은 데이터베이스 구조를 정의하고 수정하기 위한 명령도 제공한다.</p>
<h2 id="Fundamental-RDBMS-Concepts"><a href="#Fundamental-RDBMS-Concepts" class="headerlink" title="Fundamental RDBMS Concepts"></a>Fundamental RDBMS Concepts</h2><ul>
<li><strong>Table:</strong> 행과 열로 구성된 데이터의 구조화된 모음이다. 각 테이블은 고객, 주문 또는 제품과 같은 특정 엔티티 또는 개념을 나타낸다.</li>
<li><strong>Row:</strong> 레코드 또는 튜플이라고도 하는 행은 테이블의 단일 인스턴스 또는 항목을 나타낸다.</li>
<li><strong>Column:</strong> 필드 또는 속성이라고도 하는 열은 특정 레코드의 특정 특성이나 속성을 나타낸다.</li>
<li><strong>Primary Key:</strong> 기본 키는 테이블의 각 레코드에 대해 고유 식별자 역할을 하는 열 또는 열의 조합이다. 기본 키 열에서 중복 또는 null 값을 방지해 데이터의 고유성과 무결성을 보장한다.</li>
<li><strong>Foreign Key:</strong> 외래 키는 다른 테이블의 기본 키를 참조하는 한 테이블의 열 또는 열의 조합이다. 두 테이블 간의 관계를 설정하고 참조 무결성 및 데이터 일관성을 강화하는데 도움이 된다.</li>
<li><strong>Join:</strong> 조인은 관련 열을 기준으로 두 개 이상의 테이블에서 행을 결합하는 작업이다. 테이블을 결합할 조건을 지정해 여러 테이블에서 데이터를 검색할 수 있다.</li>
<li><strong>Index:</strong> 인덱스는 데이터베이스에서 데이터 검색 작업의 성능을 향상시키는 데이터 구조다. 인덱스는 하나 이상의 열을 기반으로 테이블에 있는 데이터를 정렬된 형태로 표시한다.</li>
<li><strong>View:</strong> 뷰는 하나 이상의 기본 테이블에서 동적으로 생성되는 가상 테이블이다. 뷰는 데이터를 사용자 지정하고 단순화한 표현을 제공한다. 뷰는 보안, 단순화 또는 데이터 추상화 목적으로 사용할 수 있다.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240719091835419.png" alt=""></p>
<h2 id="Keys-in-Relational-Databases"><a href="#Keys-in-Relational-Databases" class="headerlink" title="Keys in Relational Databases"></a>Keys in Relational Databases</h2><p>키는 관계형 데이터베이스 설계의 기본 구성 요소이며 데이터 무결성과 테이블 간의 관계 설정에 중요한 역할을 한다. 키는 레코드의 고유 식별자 역할을 해 데이터 검색과 조작을 보다 효율적으로 만들어 준다. 관계형 데이터베이스 설계에서 키의 다양한 유형과 그 중요성에 대해 살펴보자.</p>
<h3 id="Primary-Key-and-Indexing"><a href="#Primary-Key-and-Indexing" class="headerlink" title="Primary Key and Indexing"></a>Primary Key and Indexing</h3><p>기본 키는 테이블의 각 레코드를 고유하게 식별하는 열 또는 열의 조합이다. 기본 키는 각 레코드가 고유하고 테이블 내에서 쉽게 찾을 수 있도록 보장한다. 기본 키 제약 조건은 기본 키 열의 고유성과 무효화 불가능성을 강제한다. 아래는 테이블의 열을 기본 키로 정의하는 방법을 보여준다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> books (</span><br><span class="line">    book_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    title <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    author <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    isbn <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">    publication_year <span class="type">INT</span>,</span><br><span class="line">    genre <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>book_id INT PRIMARY KEY</code>를 지정하면 <code>books</code> 테이블의 기본 키로 book_id 열을 선언하는 것이다. 즉 book_id 열의 각 값은 고유해야 하며 null이 될 수 없다. 쿼리 성능을 향상시키기 위해 데이터베이스는 기본 키 열에 인덱스를 자동으로 생성한다. 앞서 설명한 대로 인덱스는 인덱싱된 열을 기반으로 데이터를 더 빠르게 검색하는데 도움이 되는 별도의 데이터 구조다. 기본 키에 인덱스를 생성하면 데이터베이스는 전체 테이블을 스캔하지 않고도 특정 레코드를 빠르게 찾아서 액세스할 수 있다.</p>
<h3 id="Surrogate-Key-and-Natural-Key"><a href="#Surrogate-Key-and-Natural-Key" class="headerlink" title="Surrogate Key and Natural Key"></a>Surrogate Key and Natural Key</h3><p>키는 대리 키와 자연 키의 두 가지 방식으로 분류할 수도 있다. 대리 키는 데이터베이스 시스템에서 생성된 인공 키다. 데이터와 고유한 의미나 관계가 없는 일련 번호 또는 GUID(Globally unique identifier)인 경우가 많다. 대리 키는 고유성을 보장하고 테이블 간의 관계 관리를 단순화하기 때문에 일반적으로 기본 키로 사용된다. 아래 예는 <code>customer_id</code>를 대리 키로 사용하는 “customers”라는 테이블을 보여준다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers (</span><br><span class="line">    customer_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    first_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    last_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>이와 대조적으로 자연 키는 데이터 자체에서 파생된 키다. 데이터의 고유한 특성에 따라 각 레코드를 고유하게 식별하는 열 또는 열의 조합이다. 자연 키의 예로는 직원 ID, 제품 코드, 이메일 주소 또는 사람의 이름과 성 같은 열의 조합 등이 있다. 아래 예는 <code>product_code</code>가 자연 키인 “products” 테이블을 보여준다. 이 키는 제품 데이터의 고유한 특성이다. 제조업체에서 할당된 코드이거나 표준 식별자일 수 있다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (</span><br><span class="line">    product_code <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    product_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    category <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="Foreign-Key"><a href="#Foreign-Key" class="headerlink" title="Foreign Key"></a>Foreign Key</h3><p>외래 키는 다른 테이블의 기본 키를 참조하는 한 테이블의 열 또는 열의 조합이다. 외래 키는 두 테이블 간의 링크 또는 관계를 설정한다. 아래 예는 “customers” 테이블과 “orders” 테이블을 보여준다. “orders” 테이블에는 “customers” 테이블의 customer_id를 참조하는 외래 키가 있다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers (</span><br><span class="line">    customer_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    first_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    last_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders (</span><br><span class="line">    order_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    customer_id <span class="type">INT</span>,</span><br><span class="line">    order_date <span class="type">DATE</span>,</span><br><span class="line">    total_amount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (customer_id) <span class="keyword">REFERENCES</span> customers(customer_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>외래 키의 목적은 참조 무결성을 적용하는 것이다. 참조 무결성은 자식 테이블(외래 키가 있는 테이블)의 데이터가 부모 테이블(기본 키가 있는 테이블)의 데이터와 일치하도록 보장한다. 부모 테이블에 해당 레코드가 없는 고아 레코드가 자식 테이블에 생성되는 것을 방지한다.</p>
<p>참조 무결성은 제약 조건을 사용하여 강화된다. 제약 조건은 상위 테이블의 참조 레코드가 업데이트되거나 삭제될 때 취해야 할 규칙과 작업을 정의하여 테이블 간의 관계가 일관되고 유효하게 유지되도록 한다. 다음은 몇 가지 일반적인 제약 조건이다.</p>
<ul>
<li><strong>CASCADE:</strong> 상위 테이블의 레코드가 업데이트되거나 삭제되면 CASCADE 작업은 자동으로 하위 테이블에 변경 사항을 전파한다. 예를 들어 상위 테이블의 레코드가 삭제되면 하위 테이블의 해당 레코드도 삭제된다.</li>
<li><strong>SET NULL:</strong> 상위 테이블의 레코드가 업데이트되거나 삭제되면 SET NULL 작업은 하위 테이블의 해당 외래 키 값을 NULL로 설정한다.</li>
<li><strong>NO ACTION:</strong> 이 작업은 부모 행이 자식 테이블에서 참조되는 경우 부모 행이 삭제되지 않도록 한다.</li>
</ul>
<p>아래 예는 외래 키 제약 조건을 정의하는 방법을 보여준다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders (</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (CustomerID) <span class="keyword">REFERENCES</span> Customers(CustomerID) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="Relationship-Types-in-Relational-Databases"><a href="#Relationship-Types-in-Relational-Databases" class="headerlink" title="Relationship Types in Relational Databases"></a>Relationship Types in Relational Databases</h2><p>관계형 데이터베이스에서 테이블 간의 관계는 데이터 연결 방식을 정의하는데 중요한 역할을 한다. 이런 관계는 데이터베이스의 구조와 무결성을 결정한다. 일대일, 일대다, 다대다의 세 가지 주요 관계 유형에 대해 살펴보자.</p>
<h3 id="One-to-One-Relationship"><a href="#One-to-One-Relationship" class="headerlink" title="One-to-One Relationship"></a>One-to-One Relationship</h3><p>일대일 관계는 한 테이블의 각 레코드가 다른 테이블의 정확히 하나의 레코드와 연결되고 그 반대의 경우도 마찬가지인 관계 유형이다.</p>
<p>즉, 테이블 A의 모든 레코드에 대해 테이블 B에 해당하는 고유 레코드가 있고 테이블 B의 다른 레코드가 테이블 A의 해당 레코드와 연결되어 있지 않다는 의미다. 일대일 관계는 두 테이블을 하나의 테이블로 결합할 수 있음을 나타내므로 실제로는 비교적 드물게 발생한다. 그러나 보안 또는 성능상의 이유로 특정 속성을 별도의 테이블로 분리하려는 경우와 같이 일대일 관계가 유용한 시나리오가 있다. 아래 예는 “Users” 테이블과 “UserProfiles” 테이블 간의 일대일 관계를 보여준다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240719093558328.png" alt=""></p>
<p>또한 아래 SQL은 이 관계를 생성하는 방법을 보여준다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Create the Users table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Users (</span><br><span class="line">    UserID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    Username <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    Email <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create the UserProfiles table</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> UserProfiles (</span><br><span class="line">    ProfileID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    UserID <span class="type">INT</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    FirstName <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    LastName <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    Bio <span class="type">VARCHAR</span>(<span class="number">500</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (UserID) <span class="keyword">REFERENCES</span> Users(UserID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="One-to-Many-Relationship"><a href="#One-to-Many-Relationship" class="headerlink" title="One-to-Many Relationship"></a>One-to-Many Relationship</h3><p>일대다 관계는 관계형 데이터베이스에서 가장 일반적인 유형의 관계다. 이 관계에서 한 테이블(one)의 각 레코드는 다른 테이블(many)의 여러 레코드와 연결될 수 있지만 “many” 테이블의 각 레코드는 “one” 테이블의 레코드 하나에만 연결된다.</p>
<p>일대다 관계는 일반적으로 “one” 테이블의 기본 키를 참조하는 “many” 테이블의 외래 키를 사용하여 구현된다. 이 외래 키는 참조 무결성을 보장하고 두 테이블 간의 관계를 유지한다. 아래 다이어그램은 두 테이블 간의 일대다 관계를 보여준다. 각 고객은 여러 주문을 가질 수 있지만 각 주문은 한 고객에게만 속한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240719093855493.png" alt=""></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Create the Customers table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Customers (</span><br><span class="line">    CustomerID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    FirstName <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    LastName <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    Email <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create the Orders table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders (</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    TotalAmount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (CustomerID) <span class="keyword">REFERENCES</span> Customers(CustomerID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="Many-to-Many-Relationship"><a href="#Many-to-Many-Relationship" class="headerlink" title="Many-to-Many Relationship"></a>Many-to-Many Relationship</h3><p>다대다 관계는 한 테이블의 각 레코드가 다른 테이블의 여러 레코드와 연결될 수 있고 그 반대의 경우도 마찬가지인 관계 유형이다. 즉, 두 테이블의 레코드가 다른 테이블에 여러 개의 대응하는 레코드를 가질 수 있다. 다대다 관계는 일반적으로 junction table(bridge table, associative table 이라고도 함)을 사용하여 구현된다.</p>
<p>Junction table에는 관계에 관련된 두 테이블의 기본 키를 참조하는 외래 키가 포함되어 있다. Junction table의 각 레코드는 두 테이블의 레코드 간의 연결을 나타낸다. 아래 다이어그램은 “products” 테이블과 “categories” 테이블 간의 다대다 관계를 보여준다. Junction table인 “ProductsCategories”는 이 관계를 알려준다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240719094132073.png" alt=""></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Create the Products table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Products (</span><br><span class="line">    ProductID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    ProductName <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    Description <span class="type">VARCHAR</span>(<span class="number">500</span>),</span><br><span class="line">    Price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create the Categories table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Categories (</span><br><span class="line">    CategoryID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CategoryName <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    Description <span class="type">VARCHAR</span>(<span class="number">500</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create the ProductCategories table (junction table)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ProductCategories (</span><br><span class="line">    ProductCategoryID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    CategoryID <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (ProductID) <span class="keyword">REFERENCES</span> Products(ProductID),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (CategoryID) <span class="keyword">REFERENCES</span> Categories(CategoryID)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="Database-Normalization"><a href="#Database-Normalization" class="headerlink" title="Database Normalization"></a>Database Normalization</h2><p>데이터베이스 정규화는 관계형 데이터베이스의 구조를 최적화하기 위해 데이터베이스 설계에 사용되는 유용한 기술이다. 여기에는 데이터를 더 작고 관리하기 쉬운 테이블로 구성하고 정규화로 알려진 잘 정의된 규칙에 따라 테이블 간의 관계를 설정하는 것이 포함된다. 데이터베이스 정규화의 주요 목표는 데이터 중복을 줄이고 데이터 이상을 최소화하는 것이다. </p>
<ul>
<li>데이터 중복은 동일한 정보가 데이터베이스 내의 여러 위치에 저장되어 있을 때 발생한다. 이는 불일치를 초래하고 데이터 유지보수를 더욱 어렵게 만들 수 있다.</li>
<li>데이터 이상은 세 가지 유형이 있다.<ul>
<li>삽입 이상 : 다른 데이터 없이 특정 데이터를 데이터베이스에 삽입할 수 없을 때 발생한다. 예를 들어 고객 세부 정보와 제품 세부 정보가 같은 테이블에 저장되어 있는 경우 고객과 연결하지 않으면 새 제품을 만들 수 없다.</li>
<li>업데이트 이상 : 한 곳에서 데이터를 업데이트할 때 다른 여러 곳에서도 동일한 데이터를 업데이트해야 할 때 발생한다.</li>
<li>삭제 이상 : 한 테이블에서 데이터를 삭제하면 다른 관련 데이터가 제거될 때 삭제 이상 현상이 발생한다. 예를 들어 학생 및 코스 정보가 동일한 테이블에 저장되어 있는 경우 학생 기록을 삭제하면 코스 정보도 삭제될 수 있다.</li>
</ul>
</li>
</ul>
<p>가장 일반적으로 사용되는 정규화 양식은 다음과 같다.</p>
<ul>
<li>제 1정규화 (First Normal Form, 1NF)</li>
<li>제 2정규화 (Second Normal Form, 2NF)</li>
<li>제 3정규화 (Third Normal Form, 3NF)</li>
</ul>
<h3 id="1NF-First-Normal-Form-of-Database-Normalization"><a href="#1NF-First-Normal-Form-of-Database-Normalization" class="headerlink" title="1NF (First Normal Form of Database Normalization)"></a>1NF (First Normal Form of Database Normalization)</h3><p>1NF의 핵심 원칙은 테이블의 각 속성(열)이 원자 값을 포함해야 한다는 것이다. 여기서 원자성이란 테이블의 각 셀이 분할할수 없는 단일 값을 보유해야 함을 의미한다. 즉, 단일 열 내에 반복되는 그룹이나 데이터 배열이 포함되어 있지 않으면 테이블은 1NF로 간주된다. 이런 요구 사항을 준수함으로써 1NF는 단일 셀에 여러 값을 저장할 필요가 없으며 반복되는 데이터 그룹이 생성되는 것을 방지한다. 예를 들어, 다음은 1 정규화를 위반하는 테이블 정의다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Students (</span><br><span class="line">    StudentID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    Name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    Courses <span class="type">VARCHAR</span>(<span class="number">200</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Students (StudentID, Name, Courses)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;Math, Science, History&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>이 테이블에서 학생 테이블의 코스 열에는 각 학생이 등록한 코스의 쉼표로 구분된 목록이 포함되어 있다. 이는 코스 열에 단일 셀에 여러 값이 포함되어 있으므로 1 정규화를 위반한다. 이 문제를 해결하는 한 가지 방법은 아래와 같이 테이블을 정의하는 것이다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Create the Courses table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Courses (</span><br><span class="line">    CourseID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CourseName <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create the StudentCourses table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> StudentCourses (</span><br><span class="line">    StudentID <span class="type">INT</span>,</span><br><span class="line">    CourseID <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (StudentID, CourseID),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (StudentID) <span class="keyword">REFERENCES</span> Students(StudentID),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (CourseID) <span class="keyword">REFERENCES</span> Courses(CourseID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="2NF-Second-Normal-Form-of-Database-Normalization"><a href="#2NF-Second-Normal-Form-of-Database-Normalization" class="headerlink" title="2NF (Second Normal Form of Database Normalization)"></a>2NF (Second Normal Form of Database Normalization)</h3><p>테이블 내에서 부분적인 종속성을 제거하여 모든 non-key 속성이 전체 기본 키에 완전히 종속되도록 하는데 중점을 둔다. 2NF를 이해하기 위해 먼저 기능적 종속성의 개념을 정의해 보자. 기능적 종속성은 한 속성의 값이 다른 속성의 값을 결정할 때 존재한다. 2NF의 맥락에서 우리는 non-key 속성과 기본 키 사이의 기능적 종속성을 염두에 두고 있다. 테이블이 다음 조건을 충족하는 경우 2NF로 간주된다.</p>
<ul>
<li>테이블이 1NF다.</li>
<li>모든 non-key 컬럼들은 전체 기본 키에 완전히 종속된다.</li>
</ul>
<p>이를 이해하기 위해 아래 예시를 살펴보자.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders (</span><br><span class="line">    OrderID <span class="type">INT</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    CustomerName <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (OrderID, ProductID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>이 테이블에서 기본 키는 OrderID와 ProductID로 구성된 복합 키다. 그러나 CustomerName 컬럼은 기본 키의 일부가 아닌 CustomerID에만 종속된다. 이는 두 번째 정규화를 위반한다. 이 테이블을 2NF를 준수하도록 만드려면 두 개의 테이블로 분할해야 한다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Create the Customers table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Customers (</span><br><span class="line">    CustomerID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerName <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create the Orders table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders (</span><br><span class="line">    OrderID <span class="type">INT</span>,</span><br><span class="line">    ProductID <span class="type">INT</span>,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (OrderID, ProductID),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (CustomerID) <span class="keyword">REFERENCES</span> Customers(CustomerID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="3NF-Third-Normal-Form-of-Database-Normalization"><a href="#3NF-Third-Normal-Form-of-Database-Normalization" class="headerlink" title="3NF (Third Normal Form of Database Normalization)"></a>3NF (Third Normal Form of Database Normalization)</h3><p>테이블 내에서 전이적 종속성을 제거해 모든 non-key 속성이 다른 non-key 속성이 아닌 기본 키에만 종속되도록 하는 데 중점을 둔다. 3NF를 이해하기 위해 먼저 전이적 종속성의 개념을 이해해보자. 전이적 종속성은 키가 아닌 속성이 다른 키가 아닌 속성에 종속되고, 이 속성이 다시 기본 키에 종속될 때 발생한다. 테이블이 다음 조건을 만족하면 3NF로 간주한다.</p>
<ul>
<li>테이블이 2NF다.</li>
<li>전이 종속성이 없다.</li>
</ul>
<p>다음 예제를 살펴보자.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Create the Employee Table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee (</span><br><span class="line">    EmployeeID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    Name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    DepartmentID <span class="type">INT</span>,</span><br><span class="line">    DepartmentName <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    DepartmentLocation <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>이 테이블은 전이적 종속성을 포함하므로 3 정규화를 위반한다. 부서 이름 및 부서 위치 컬럼은 부서 ID에 종속되며 이는 다시 EmployeeID에 종속된다. 테이블을 3NF로 만들려면 아래 sql을 참조하라.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Create the Department table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Department (</span><br><span class="line">    DepartmentID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    DepartmentName <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    DepartmentLocation <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create the Employee table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee (</span><br><span class="line">    EmployeeID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    Name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    DepartmentID <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (DepartmentID) <span class="keyword">REFERENCES</span> Department(DepartmentID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="Joins-in-Relational-Databases"><a href="#Joins-in-Relational-Databases" class="headerlink" title="Joins in Relational Databases"></a>Joins in Relational Databases</h2><p>조인은 여러 테이블에서 관련 데이터를 결합하고 검색할 수 있는 관계형 데이터베이스의 강력하고 필수적인 개념이다. 조인은 관계에 따라 서로 다른 테이블을 연결해 데이터를 효율적으로 쿼리하고 조작할 수 있게 해주는 다리 역할을 한다. 조인은 여러 테이블에 걸쳐 있는 데이터를 검색해야할 때 유용하다.</p>
<p>예를 들어 고객 정보를 저장하는 “Customers” 테이블과 주문 세부 정보를 저장하는 “Orders” 테이블이 있을 수 있다. 이런 테이블은 서로 분리되어 있지만 고객 ID와 같은 공통 열을 통해 연관되어 있는 경우가 많다. 조인에는 3가지 유형이 있다.</p>
<h3 id="Inner-Join"><a href="#Inner-Join" class="headerlink" title="Inner Join"></a>Inner Join</h3><p>Inner 조인은 두 테이블 간의 관련 열을 기반으로 두 개 이상의 테이블에서 행을 결합하는 조인 작업 유형이다. 조인되는 두 테이블에서 일치하는 행만 반환한다.</p>
<h3 id="Right-Outer-Join"><a href="#Right-Outer-Join" class="headerlink" title="Right Outer Join"></a>Right Outer Join</h3><p>Right 조인은 오른쪽 테이블(join 절에서 언급된 2번째 테이블)의 모든 행과 왼쪽 테이블의 일치하는 행을 반환하는 조인 작업 유형이다.</p>
<h3 id="Left-Outer-Join"><a href="#Left-Outer-Join" class="headerlink" title="Left Outer Join"></a>Left Outer Join</h3><p>Left 조인은 왼쪽 테이블(join 절에서 언급된 1번째 테이블)의 모든 행과 오른쪽 테이블의 일치하는 행을 반환하는 조인 작업 유형이다.</p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2024/07/19/System%20Design/ByteByteGo/private/a-crash-course-on-relational-database-design/">https://songhayoung.github.io/2024/07/19/System%20Design/ByteByteGo/private/a-crash-course-on-relational-database-design/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2025 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>