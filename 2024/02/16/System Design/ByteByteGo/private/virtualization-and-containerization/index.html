<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[ByteByteGo] Virtualization and Containerization: Which one to pick?"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[ByteByteGo] Virtualization and Containerization: Which one to pick? | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Virtualization-and-Containerization-Which-one-to-pick"><span class="toc-number">1.</span> <span class="toc-text">Virtualization and Containerization: Which one to pick?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Players-in-the-Space"><span class="toc-number">2.</span> <span class="toc-text">Players in the Space</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Virtualization"><span class="toc-number">3.</span> <span class="toc-text">Virtualization</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#How-virtualization-works"><span class="toc-number">3.1.</span> <span class="toc-text">How virtualization works</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hypervisor"><span class="toc-number">3.1.1.</span> <span class="toc-text">Hypervisor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Virtual-machines-VMs"><span class="toc-number">3.1.2.</span> <span class="toc-text">Virtual machines (VMs)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Host-machine"><span class="toc-number">3.1.3.</span> <span class="toc-text">Host machine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Guest-operating-systems"><span class="toc-number">3.1.4.</span> <span class="toc-text">Guest operating systems</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Containerization"><span class="toc-number">4.</span> <span class="toc-text">Containerization</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Understanding-containerization-through-an-example"><span class="toc-number">4.1.</span> <span class="toc-text">Understanding containerization through an example</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Container-runtimes-and-orchestration"><span class="toc-number">4.2.</span> <span class="toc-text">Container runtimes and orchestration</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Container-runtimes"><span class="toc-number">4.2.1.</span> <span class="toc-text">Container runtimes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Container-orchestration"><span class="toc-number">4.2.2.</span> <span class="toc-text">Container orchestration</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Comparative-Analysis"><span class="toc-number">5.</span> <span class="toc-text">Comparative Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Startup-time"><span class="toc-number">5.1.</span> <span class="toc-text">Startup time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Disk-space"><span class="toc-number">5.2.</span> <span class="toc-text">Disk space</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Portability"><span class="toc-number">5.3.</span> <span class="toc-text">Portability</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Efficiency"><span class="toc-number">5.4.</span> <span class="toc-text">Efficiency</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Operating-system-kernel"><span class="toc-number">5.5.</span> <span class="toc-text">Operating system&#x2F;kernel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Choosing-the-Right-Technology"><span class="toc-number">6.</span> <span class="toc-text">Choosing the Right Technology</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#When-to-choose-virtualization"><span class="toc-number">6.1.</span> <span class="toc-text">When to choose virtualization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#When-to-choose-containerization"><span class="toc-number">6.2.</span> <span class="toc-text">When to choose containerization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#When-to-choose-a-hybrid-approach-virtualization-containerization"><span class="toc-number">6.3.</span> <span class="toc-text">When to choose a hybrid approach (virtualization+containerization)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wrap-Up"><span class="toc-number">7.</span> <span class="toc-text">Wrap Up</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/hayoung-song-9523b61bb/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">11270</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">196</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">62</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[ByteByteGo] Virtualization and Containerization: Which one to pick?</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-02-16</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/Byte-Byte-Go/">Byte Byte Go</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1.7k</span><span class="post-meta__separator">|</span><span>Reading time: 10 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Virtualization-and-Containerization-Which-one-to-pick"><a href="#Virtualization-and-Containerization-Which-one-to-pick" class="headerlink" title="Virtualization and Containerization: Which one to pick?"></a>Virtualization and Containerization: Which one to pick?</h2><span id="more"></span>
<h2 id="Players-in-the-Space"><a href="#Players-in-the-Space" class="headerlink" title="Players in the Space"></a>Players in the Space</h2><p>가상화와 컨테이너화는 많은 제품이 있기에 혼란스러울 수 있다. 가상화 측면에서는 Xen 및 KVM과 같은 오픈 소스 플랫폼이나 VMware vSphere, Microsoft Hyper V, Oracle’s Virtual Box와 같은 제품이 있다.</p>
<p>컨테이너의 경우 현재 가장 인기있는 Docker 외에도 rkt, Podman, Containerd와 같은 제품이 있다. 컨테이너 오케스트레이션에는 Kubernetes, Docker Swarm, Nomad 등이 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240216171752472.png" alt=""></p>
<p>어떤 것을 선택할지 알아보기 전에 가상화와 컨테이너가 무엇인지 알아보자.</p>
<h2 id="Virtualization"><a href="#Virtualization" class="headerlink" title="Virtualization"></a>Virtualization</h2><p>가상화는 오래 전부터 지금까지도 클라우드 컴퓨팅에서 핵심 역할을 하고 있다. 가상화 기술을 사용하면 하나의 물리적 서버가 여러 대의 컴퓨터 처럼 작동한다. 가상화 기술은 CPU, 메모리, 네트워크, 스토리지와 같은 컴퓨팅 리소스의 가상 또는 시뮬레이션 버전을 생성한다. 이런 가상 리소스는 모두 동일한 물리적 컴퓨터에서 호스팅되지만 각각 다른 애플리케이션과 운영 체제를 독립적으로 실행할 수 있다.</p>
<p>간단한 예를 들어보자. 각각 특정 용도로 지정된 물리 서버 3대가 있고 각각 35%의 로드로만 애플리케이션을 실행해 리소스를 온전히 활용하지 못한다고 가정해보자. 많은 기존 환경에서는 안정성과 신뢰성을 극대화하기 위해 중요한 애플리케이션을 각각 전용 서버에서 실행했다. 하지만 이는 비효율을 뜻하기도 한다. 이런 문제를 가상화가 해결한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240216172125206.png" alt=""></p>
<p>이를 통해 이메일 서버를 서로 다른 작업을 처리할 수 있는 두 개의 독립된 개체로 분할해 레거시 애플리케이션을 마이그레이션할 수 있는 공간을 확보할 수 있다. 운영상의 요구 사항을 충족하면서 하드웨어 효율성을 개선할 수 있다.</p>
<p>사용하지 않는 용량을 확보하면 여분의 서버를 다른 용도로 변경하거나 제거할 수 있어 운영 및 유지보수 비용을 절감할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240216172651294.png" alt=""></p>
<h3 id="How-virtualization-works"><a href="#How-virtualization-works" class="headerlink" title="How virtualization works"></a>How virtualization works</h3><p>가상화는 단일 물리적 머신에서 가상화된 환경을 생성하고 관리하는 방식으로 작동한다. 주요 구성 요소는 다음과 같다.</p>
<ul>
<li>Hypervisors</li>
<li>Virtual machines</li>
<li>Host machines</li>
<li>Guest operating systems</li>
</ul>
<h4 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h4><p>하이버파이저는 물리적 서버 또는 호스트 위에서 실행되는 소프트웨어다. 호스트의 리소스를 폴링해 가상 머신에 할당한다.</p>
<p>하이퍼바이저에는 크게 두 가지 유형이 있다.</p>
<p><strong><em>Type 1 Hypervisor:</em></strong> 가장 일반적이며 물리적 서버에 직접 설치되며 베어메탈 하이퍼바이저라고도 한다. 더 나은 보안과 짧은 지연 시간을 제공한다.</p>
<ul>
<li>VMware ESXi</li>
<li>Microsoft Hyper-V</li>
<li>Open source KVM</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240216172851544.png" alt=""></p>
<p><strong><em>Type 2 Hypervisor:</em></strong> 물리적 서버에 설치된 호스트 운영체제 위에서 실행되어 호스트형 하이퍼바이저라고도 한다. 주로 최종 사용자가 가상화용으로 사용하므로 사용 빈도가 낮다. Type 1 Hypervisor보다 지연 시간이 더 길다.</p>
<ul>
<li>Oracle VirtualBox</li>
<li>VMware Workstation</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240216173039709.png" alt=""></p>
<h4 id="Virtual-machines-VMs"><a href="#Virtual-machines-VMs" class="headerlink" title="Virtual machines (VMs)"></a>Virtual machines (VMs)</h4><p>가상 머신은 독립적인 인스턴스로 실행되는 시뮬레이션 컴퓨터 시스템이다. 각 VM에는 자체 운영 체제와 애플리케이션이 있다. 하이퍼바이저는 VM을 서로 격리하는 동시에 기본 물리적 서버의 리소스를 효율적으로 공유할 수 있도록 한다.</p>
<p>하이퍼바이저가 설치되면 가상 환경으로 여러 VM을 생성할 수 있다. 그런 다음 하이퍼바이저는 물리적 서버의 리소스가 각 VM에 할당되는 방식을 관리한다.</p>
<h4 id="Host-machine"><a href="#Host-machine" class="headerlink" title="Host machine"></a>Host machine</h4><p>호스트 머신은 하이퍼바이저가 설치된 물리 서버다. 호스트 머신은 가상 머신 간에 공유되는 CPU, 메모리, 스토리지 및 기타 리소스를 제공한다.</p>
<h4 id="Guest-operating-systems"><a href="#Guest-operating-systems" class="headerlink" title="Guest operating systems"></a>Guest operating systems</h4><p>각 가상 머신은 자체 게스트 운영체제를 실행한다. 이런 운영체제는 물리적 하드웨어를 완전히 제어할 수 있다고 생각해 독립적으로 작동하지만 실제로는 다른 가상 머신과 리소스를 공유한다.</p>
<p>본질적으로 가상화는 하나의 물리적 서버에 여러 개의 격리된 가상 환경을 공존시킬 수 있다. 이를 통해 리소스 활용도 향상, 유연성 및 비용 절감과 같은 이점을 제공한다. 가상화는 애플리케이션과 운영 체제의 격리를 가능하게 해 인프라 관리, 배포 및 확장을 용이하게 함으로써 데이터 센터, 서버 통합 및 클라우드 컴퓨팅에서 널리 채택되는데 기여하고 있다.</p>
<h2 id="Containerization"><a href="#Containerization" class="headerlink" title="Containerization"></a>Containerization</h2><p>2008년 Linux 커널은 control groups(cgroup)을 도입해 최신 컨테이너 기술의 기반을 마련했다. Docker는 컨테이너를 생성, 배포 및 관리하는 프로세스를 간소화 했다. 컨테이너 이미지 사용을 대중화하고 이를 공유하기 위한 레지스트리를 도입했다.</p>
<p>컨테이너는 물리적 서버와 호스트 OS 위에 위치하며, 가상 머신처럼 기본 하드웨어가 아닌 OS만 가상화한다. 여전히 하드웨어와 일종의 호스트 운영 체제가 있다. 이 컨테이너 엔진은 호스트 운영체제의 일부를 컨테이너에 노출한다. 컨테이너 자체에는 전체 OS가 아닌 필요한 바이너리, 라이브러리, 애플리케이션만 포함되어 있다. 컨테이너는 기본 호스트 OS의 커널을 공유할 수 있으므로 자체적인 전체 OS가 필요하지 않다. 이런 방식으로 일부 리소스를 공유하면 VM의 완전한 분리와 독립성을 잃게 되지만 좋은 효율성을 얻는다. 이런식으로 최적화된 공유는 컨테이너를 강력하게 만드는 요소다.</p>
<h3 id="Understanding-containerization-through-an-example"><a href="#Understanding-containerization-through-an-example" class="headerlink" title="Understanding containerization through an example"></a>Understanding containerization through an example</h3><p>프로덕션 환경으로 푸시는 Node.js 애플리케이션 예제를 통해 컨테이너화의 개념을 이해해보자. 컨테이너 관련 작업을 할 때는 3단계 프로세스가 있다.</p>
<ol>
<li>컨테이너를 설명하는 manifest를 생성한다. Docker의 경우 Dockerfile, Cloud Foundry의 경우 YAML manifest다.</li>
<li>실제 컨테이너 이미지를 빌드한다. Docker의 경우 Docker image, Rocker의 경우 Application Container image(ACI) 다. 이 단계는 사용된 컨테이너화 기술에 관계없이 동일하다.</li>
<li>애플리케이션을 실행하는데 필요한 모든 런타임, 라이브러리, 바이너리가 포함된 컨테이너 자체를 스핀업한다. 애플리케이션은 가상 머신과 매우 유사한 설정에서 실행되지만 하이퍼바이저 대신 컨테이너를 실행하기 위해 Docker 엔진과 같은 엔진이 사용된다. 기술마다 컨테이너 실행을 처리하는 엔진은 다를 수 있다.</li>
</ol>
<p>컨테이너의 가장 큰 장점은 VM에 비해 가볍다는 것이다. 따라서 여러 개의 컨테이너를 배포해 애플리케이션을 훨씬 쉽게 확장할 수 있다. VM을 사용하면 매번 전체 게스트 운영 체제를 복제해야 하므로 더 많은 리소스를 사용하게 된다. 하지만 컨테이너 에서는 운영 체제를 복제하지 않는다. 주로 필요한 애플리케이션 코드와 라이브러리만 복제한다. 즉, 전체적으로 더 적은 리소스를 사용한다.</p>
<p>이제 Node.js 애플리케이션이 결제 처리를 위해 서드 파티 결제 API를 활용하고 싶다고 가정해보자. Python 애플리케이션을 사용해 해당 서드 파티 서비스에 액세스하려 한다. 컨테이너 기반 접근 방식을 사용하면 다른 경량 컨테이너를 생성해 해당 Python 애플리케이션의 사본 하나를 배포하기만 하면 된다. 이렇게 최적화된 리소스 공유를 통해 컨테이너는 동일한 인프라에서 여러 언어로 서비스를 실행하는 클라우드 네이티브 애플리케이션 아키텍처를 구현할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240216174928116.png" alt=""></p>
<h3 id="Container-runtimes-and-orchestration"><a href="#Container-runtimes-and-orchestration" class="headerlink" title="Container runtimes and orchestration"></a>Container runtimes and orchestration</h3><p>컨테이너 런타임과 오케스트레이션 플랫폼은 컨테이너화된 애플리케이션을 배포, 관리 및 확장하기 위한 핵심 구성요소다.</p>
<h4 id="Container-runtimes"><a href="#Container-runtimes" class="headerlink" title="Container runtimes"></a>Container runtimes</h4><p>컨테이너 런타임은 호스트에서 컨테이너를 실행하고 관리한다. 호스트 OS 커널과 직접 상호 작용해 컨테이너를 생성하고 실행한다. </p>
<ul>
<li>Docker</li>
<li>containerd</li>
</ul>
<h4 id="Container-orchestration"><a href="#Container-orchestration" class="headerlink" title="Container orchestration"></a>Container orchestration</h4><p>컨테이너 오케스트레이션은 여러 머신에 걸쳐 컨테이너화된 애플리케이션을 배포, 확장, 운영하는 작업을 처리한다. 로드 밸런싱, 서비스 디스커버리, 장애 복구 등을 자동화한다. </p>
<ul>
<li>Kubernetes</li>
<li>Docker Swarm</li>
<li>Amazon ECS (Elastic Container Service)</li>
<li>OpenShift</li>
</ul>
<p>컨테이너 런타임은 컨테이너 실행에 중점을 두는 반면, 컨테이너 오케스트레이션은 클러스터 전반의 컨테이너 관리를 자동화한다. 컨테이너 런타임과 오케스트레이션 플랫폼 중 어떤 것을 선택할지는 애플리케이션의 구체적 요구와 목표에 따라 달라진다.</p>
<h2 id="Comparative-Analysis"><a href="#Comparative-Analysis" class="headerlink" title="Comparative Analysis"></a>Comparative Analysis</h2><p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240216175417879.png" alt=""></p>
<h3 id="Startup-time"><a href="#Startup-time" class="headerlink" title="Startup time"></a>Startup time</h3><p>가상 머신은 전체 운영체제를 부팅하는데 1~2분이 걸린다. 이 과정에는 운영체제를 시작하고 커스터마이징 하는 작업이 포함된다. 이는 장기간 실행되는 워크로드에 적합하다. 클라우드 프로바이더는 서버 가상화를 위해 persistent VM에 크게 의존한다.</p>
<p>컨테이너는 이미 실행중인 커널을 통해 애플리케이션 코드만 패키징하므로 몇 초 만에 시작할 수 있다. 이런 빠른 시작 덕분에 컨테이너는 자동 확장형 클라우드 배포에 이상적이다.</p>
<h3 id="Disk-space"><a href="#Disk-space" class="headerlink" title="Disk space"></a>Disk space</h3><p>가상 머신은 전체 운영 체제를 복제해 상당한 디스크 공간을 소비한다. VM을 더 많이 추가하면 중복된 OS 복사본이 더 많아져 스토리지가 추가로 필요하다.</p>
<p>컨테이너는 계층화된 컨테이너 이미지를 통해 스토리지 효율성을 달성한다. 컨테이너 이미지를 VM처럼 전체 OS 설치를 복제하는 대신 증분 레이어에서 구축된다. 이런 레이어에는 특정 애플리케이션 바이너리 또는 종속성 등 특정 컨테이너에 필요한 파일의 차이점만 포함된다. 기본 OS 파일은 최하위 레이어에 있는 컨테이너간 읽기 전용으로 공유된다. 이 계층화된 접근 방식은 컨테이너 간에 운영 체제 파일의 중복 복사본을 방지한다. 새 파일과 Diff만 이미지에 추가되므로 저장 공간을 적게 차지한다.</p>
<h3 id="Portability"><a href="#Portability" class="headerlink" title="Portability"></a>Portability</h3><p>대상 환경이 소스 VM 이미지와 동일한 하이퍼바이저 및 호환가능한 설정을 실행한다는 가정 하게가상 머신은 하드웨어간 이동이 가능하다. 마이그레이션에는 전체 스택에 걸친 호환성이 필요하다.</p>
<p>컨테이너는 Docker 컨테이너와 같은 표준화된 형식 덕분에 여러 환경에 걸쳐 훨씬 쉽고 이동성이 뛰어난 배포를 제공한다. 로컬부터 여러 클라우드 환경까지 동일한 컨테이너를 변경 없이 실행 가능하다. 형식 일관성을 통해 현재 가상 머신에 없는 “한번 작성하는 어디서나 실행”하는 단순성을 구현할 수 있다.</p>
<h3 id="Efficiency"><a href="#Efficiency" class="headerlink" title="Efficiency"></a>Efficiency</h3><p>가상 머신은 전체 운영 체제를 복제해 인스턴스당 더 많은 RAM, CPU 및 디스크 공간을 소비한다.</p>
<p>컨테이너는 인스턴스 간에 OS 수준에서 리소스를 공유하므로 훨씬 더 효율적이다. 따라서 일부 고립을 감수하고 효율성을 높일 수 있다.</p>
<h3 id="Operating-system-kernel"><a href="#Operating-system-kernel" class="headerlink" title="Operating system/kernel"></a>Operating system/kernel</h3><p>가상 머신에는 인스턴스당 전용 OS와 커널이 있어 하나의 가상 머신이 다운되더라도 다른 가상머신에는 영향을 주지 않는다.</p>
<p>컨테이너는 호스트 OS 커널을 공유한다. 따라서 더 효율적이지만 커널 충돌은 모든 컨테이너에 영향을 미친다. 다행히 컨테이너는 크기가 작고 이동성이 뛰어나서 다른 곳에 빠르게 다시 로드할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240216180344966.png" alt=""></p>
<h2 id="Choosing-the-Right-Technology"><a href="#Choosing-the-Right-Technology" class="headerlink" title="Choosing the Right Technology"></a>Choosing the Right Technology</h2><h3 id="When-to-choose-virtualization"><a href="#When-to-choose-virtualization" class="headerlink" title="When to choose virtualization"></a>When to choose virtualization</h3><p><strong><em>Isolation is critical:</em></strong> 워크로드 간의 강력한 격리가 우선순위인 경우 가상화가 더 나은 선택이다. 가상 머신은 애플리케이션 격리를 극대화하기 위해 완전하고 독립적인 운영체제를 제공한다.</p>
<p><strong><em>Diverse operating systems are required:</em></strong> Windows, Linux 또는 기타 OS를 혼합해야 하는 경우 가상화를 사용하면 이런 다양성을 더 쉽게 지원할 수 있다.</p>
<p><strong><em>Resource-intensive applications:</em></strong> 상당한 컴퓨팅 리소스를 필요로 하는 애플리케이션은 가상화의 강력한 격리 및 리소스 할당 기능의 이점을 누릴 수 있다. 예를 들어 집중적인 워크로드 처리를 위해 상당한 CPU, 메모리 또는 GPU 액세스가 필요한 애플리케이션은 전용 가상 머신에 적합하다. 각 가상 머신은 전체 물리적 리소스의 일부를 애플리케이션에 할당할 수 있으므로 운영 체제 수준에서 리소스를 두고 경쟁할 경우 쉽게 달성할 수 없는 성능을 보장한다.</p>
<p><strong><em>Legacy applications:</em></strong> 가상화는 컨테이너화 하기 어려운 레거시 애플리케이션을 실행하기 위한 일반적 선택이다. 예를 들어, 특정 운영체제 버전에서 실행되어야 하거나 하는 경우다. 런타임 요구사항이 까다로운 애플리케이션을 컨테이너화 하려하면 문제가 발생할 수 있다. 이런 애플리케이션을 전용 가상 머신에서 호스팅하면 대규모 리패키징 작업 없이도 요구 사항에 가장 적합한 격리된 게스트 OS를 활용할 수 있다.</p>
<h3 id="When-to-choose-containerization"><a href="#When-to-choose-containerization" class="headerlink" title="When to choose containerization"></a>When to choose containerization</h3><p><strong><em>Lightweight and fast deployment:</em></strong> 신속한 배포와 확장이 중요한 경우 컨테이너화가 선호된다. 컨테이너는 가상 머신보다 시작 시간이 빠르고 오버헤드가 적다. 따라서 컨테이너는 빠르게 변화하는 동적 워크로드에 이상적이다. 시작 속도가 빠르고 리소스 사용이 작기 때문에 실시간 수요나 부하 변동에 따라 빠르게 확장 및 축소가 가능하다.</p>
<p><strong><em>Microservices architecture:</em></strong> 마이크로서비스는 모놀리식 애플리케이션을 독립적으로 배포 가능한 작은 모듈로 분해한다. 이는 마이크로서비스의 모듈식 특징과 잘 맞다.</p>
<p><strong><em>Consistent environments:</em></strong> 컨테이너화는 개발, 테스트 및 프로덕션 환경 전반에서 일관성을 보장한다. 컨테이너는 VM 기반 배포를 괴롭히는 “내 컴퓨터에서만 작동” 문제를 방지한다. 애플리케이션과 모든 종속성을 표준 컨테이너에 패키징하면 동일한 이미지를 여러 대상 환경에 안정적으로 배포할 수 있다. 이런 이식성은 스테이징에서 검증된 애플리케이션이 프로덕션 환경에서도 동일한 방식으로 실행되게 보장한다.</p>
<p><strong><em>Cloud-Native and DevOps practices:</em></strong> 컨테이너는 CI/CD 파이프라인에 잘 맞는다. 이동성이 뛰어나 환경 간 이동을 표준화하며 설치 공간이 작아 배포 주기를 단축할 수 있다. 둘 다 더 빠르고 자동화된 애플리케이션 개발 및 배포 프로세스를 촉진한다.</p>
<h3 id="When-to-choose-a-hybrid-approach-virtualization-containerization"><a href="#When-to-choose-a-hybrid-approach-virtualization-containerization" class="headerlink" title="When to choose a hybrid approach (virtualization+containerization)"></a>When to choose a hybrid approach (virtualization+containerization)</h3><p>많은 조직이 특정 사용 사례와 애플리케이션 요구 사항에 따라 가상화와 컨테이너화 모두를 사용하는 하이브리드 접근 방식을 취한다. 이를 통해 워크로드에 가장 적합한 각 기술 이점을 활용한다.</p>
<p><strong><em>Mixed workload environments:</em></strong> 기존 모놀리식 애플리케이션에는 가상화를, 새로운 마이크로 서비스에는 컨테이너화를 적용해 각 워크로드 유형에 대한 호환성과 최적의 성능을 보장한다.</p>
<p><strong><em>Transitioning legacy applications:</em></strong> 기존 가상화 환경에서 컨테이너화 방식으로 마이그레이션 할 때는 단계적 접근이 바람직하다. 레거시 애플리케이션을 리팩토링하거나 교체할 수 있을 때 까지 기존 가상화된 인프라를 유지하면서 새로운 애플리케이션 또는 구성 요소를 컨테이너화 하는 것으로 시작할 수 있다.</p>
<p><strong><em>Multi-Tenancy Requirements:</em></strong> 여러 팀이나 프로젝트에서 격리, 보안 및 리소스 할당에 대한 다양한 요구 사항이 있는 환경에서는 하이브리드 접근 방식을 통해 가상화를 사용한 강력한 격리를 얻고 컨테이너를 사용한 가벼운 공유 워크로드를 구현할 수 있다. 이는 각 테넌트 특정 요구 사항을 충족한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240216181648982.png" alt=""></p>
<h2 id="Wrap-Up"><a href="#Wrap-Up" class="headerlink" title="Wrap Up"></a>Wrap Up</h2><p>가상화는 하드웨어 수준의 프로세스 격리와 VM당 완전한 OS 독립성을 제공한다. 강력한 격리, 다양한 OS, 리소스 집약적 앱, 레거시 시스템과 같은 요구 사항에 적합하다.</p>
<p>컨테이너화는 가볍고 빠른 배포를 통해 OS 수준에서 작동한다. 빠른 확장성, 일관된 개발-프로덕션 환경, 마이크로 서비스 아키텍처, 클라우드 네이티브 및 DevOps 관행과의 연계가 필요한 환경에 이상적이다.</p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2024/02/16/System%20Design/ByteByteGo/private/virtualization-and-containerization/">https://songhayoung.github.io/2024/02/16/System%20Design/ByteByteGo/private/virtualization-and-containerization/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2025 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>