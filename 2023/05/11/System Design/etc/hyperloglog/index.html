<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[System Design] HyperLogLog in Presto: A significantly faster way to handle cardinality estimation"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[System Design] HyperLogLog in Presto: A significantly faster way to handle cardinality estimation | SUMFIのBlog</title><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#HyperLogLog-in-Presto-A-significantly-faster-way-to-handle-cardinality-estimation"><span class="toc-number">1.</span> <span class="toc-text">HyperLogLog in Presto: A significantly faster way to handle cardinality estimation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#What-led-to-HyperLogLog"><span class="toc-number">2.</span> <span class="toc-text">What led to HyperLogLog?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-simple-estimator"><span class="toc-number">2.1.</span> <span class="toc-text">A simple estimator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Probabilistic-counting"><span class="toc-number">2.2.</span> <span class="toc-text">Probabilistic counting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Improving-accuracy-LogLog"><span class="toc-number">2.3.</span> <span class="toc-text">Improving accuracy: LogLog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HLL-Improving-accuracy-even-further"><span class="toc-number">2.4.</span> <span class="toc-text">HLL: Improving accuracy even further</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HLL-%EC%A7%91%ED%95%A9%EC%97%90-%EB%8C%80%ED%95%9C-%EC%97%B0%EC%82%B0"><span class="toc-number">2.4.1.</span> <span class="toc-text">HLL 집합에 대한 연산</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/hayoung-song-9523b61bb/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">9944</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">191</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">59</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[System Design] HyperLogLog in Presto: A significantly faster way to handle cardinality estimation</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-05-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/Etc/">Etc</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">949</span><span class="post-meta__separator">|</span><span>Reading time: 5 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="HyperLogLog-in-Presto-A-significantly-faster-way-to-handle-cardinality-estimation"><a href="#HyperLogLog-in-Presto-A-significantly-faster-way-to-handle-cardinality-estimation" class="headerlink" title="HyperLogLog in Presto: A significantly faster way to handle cardinality estimation"></a>HyperLogLog in Presto: A significantly faster way to handle cardinality estimation</h2><span id="more"></span>
<p>대규모 데이터 집합에서 고유 요소의 수를 계산하는 작업은 필요하지만, 계산 집약적이다. 예를 들어 한 주 동안 Facebook을 방문한 고유 사용자 수를 확인해야 한다 할 때, 기존 SQL 쿼리로 이 작업을 수행하려면 며칠의 시간과 테라바이트의 메모리가 소요된다. HyperLogLog(HLL)은 APPROX_DISTINCT라는 함수를 사용해 고유 요소의 대략적 추정 개수를 제공하는 방식으로 동작한다. HLL을 사용하면 1MB 미만의 메모리로 12시간 안에 동일한 계산을 수행할 수 있다.</p>
<h2 id="What-led-to-HyperLogLog"><a href="#What-led-to-HyperLogLog" class="headerlink" title="What led to HyperLogLog?"></a>What led to HyperLogLog?</h2><p>중복 항목이 포함된 카디널리티 n 인 대규모 데이터 집합이 있고 여기서 고유 요소 수를 구하려고 가정하자. 요소를 정렬하거나 단순한 고유 요소 집합을 유지하는 일반적 접근 방식은 계산 집약적이거나, 너무 많은 메모리를 요구하기 때문에 비실용적이다. 복잡성이 증가하는 순서대로 알고리즘을 살펴보고 HLL의 동작 방식을 이해해보자.</p>
<h3 id="A-simple-estimator"><a href="#A-simple-estimator" class="headerlink" title="A simple estimator"></a>A simple estimator</h3><p>답을 찾기 위해서는 추정치를 출력하는 알고리즘이 필요하다. 이 추정치는 오차가 있을 수 있지만 합리적인 오차 범위 내에 존재해야 한다. 먼저 아래와 같이 반복되는 가상의 데이터 집합을 생성한다.</p>
<ol>
<li>0와 1 사이에 균등 분포를 이루는 n개의 숫자를 생성한다.</li>
<li>숫자 중 일부를 임의의 횟수 만큼 임의로 복제한다.</li>
<li>위의 데이터 집합을 임의의 방식으로 섞는다.</li>
</ol>
<p>항목이 균등하게 분포되어 있으므로 집합의 최소값 (<script type="math/tex">x_{min}</script>)을 구하고 고유 항목의 수를 <script type="math/tex">1 / x_{min}</script>으로 추정할 수 있다. 그러나 항목을 균등하게 분산하기 위해 해시 함수를 사용하고 항목 자체 대신 해시된 값으로 카디널리티를 추정할 수 있다. 아래는 해시 값이 정규화되어 0과 1 사이에 균일하게 분포된 간단한 예이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230511012509543.png" alt=""></p>
<p>이 절차는 간단하지만 최소 해시값에 의존하기 때문에 편차가 크고, 이 값이 너무 작을 경우 추정치가 부풀려질 수 있다.</p>
<h3 id="Probabilistic-counting"><a href="#Probabilistic-counting" class="headerlink" title="Probabilistic counting"></a>Probabilistic counting</h3><p>이전 방법의 높은 변동성을 줄이기 위해 해시값의 시작 부분에서 0비트 수를 세는 개선된 패턴을 사용할 수 있다. 이 패턴은 주어진 해시(x)가 최소 i개의 0으로 끝날 확률이 <script type="math/tex">1/2^{i}</script> 이기 때문에 작동한다. 아래 그림은 세 개의 연속된 0이 관촬될 확률을 보여주는 예이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230511012716381.png" alt=""></p>
<p>평균적으로 k개의 연속 0 시퀀스가 2^k개의 고유 항목 마다 한 번씩 발생한다. 이 패턴을 사용하여 고유한 요소의 수를 추정하려면 가장 긴 연속 0 시퀀스의 길이를 기록하기만 하면 된다. 수학적으로 <script type="math/tex">p(x_i)</script>를 <script type="math/tex">hash(x_i)</script>의 연속 0의 수로 나타낸다면 카디널리티 집합 <script type="math/tex">{x_1, x_2, ... , x_m}</script>은 <script type="math/tex">2^R</script>이며 R은 <script type="math/tex">max((p(x_1), p(x_2), ... , p(x_m)))</script>이 된다. 이 방법은 두 가지 단점이 있다.</p>
<ol>
<li><script type="math/tex">2^R</script>의 식 때문에 카디널리티는 2의 계수 만큼의 추정치밖에 제공하지 못한다.</li>
<li>추정치의 변동성은 여전히 높다. 최대 <script type="math/tex">p(x_i)</script>를 기록하기 때문에 해시 값이 너무 많은 연속적인 0을 가진 항목 하나만 있으면 카디널리티에 대한 매우 부정확한(과대한) 추정치를 생성할 수 도 있다.</li>
</ol>
<p>장점은 추정기의 메모리 사용량이 매우 적다는 점이다. 보이는 연속된 0의 최대 개수만 기록하기 때문에 32비트까지의 선행 0의 시퀀스를 기록하려면 추정기는 5비트의 메모리만 있으면 된다.</p>
<h3 id="Improving-accuracy-LogLog"><a href="#Improving-accuracy-LogLog" class="headerlink" title="Improving accuracy: LogLog"></a>Improving accuracy: LogLog</h3><p>추정치를 개선하기 위해 하나 대신 여러 개의 추정치를 저장하고 결과를 평균화할 수 있다. 단일 추정기의 분산은 여러 개의 독립 추정기를 사용하고 결과를 평균화함으로써 감소한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230511013838795.png" alt=""></p>
<p>m개의 독립 함수 <script type="math/tex">{h_1(x), h_2(x), ... , h_m(x)}</script>를 사용해 이를 달성할 수 있다. 각각의 최대 연속 0 수를 얻으면 (<script type="math/tex">R_1, R_2, ... , R_m</script>) 추정치 <script type="math/tex">2^R</script>은 <script type="math/tex">2^{1/m * (R_1 + ... + Rm)}</script>이 된다. 그러나 이를 위해 각 입력 <script type="math/tex">x_i</script>가 여러 독립 해시 함수를 통과해야 하므로 계산 비용이 크다.  <a target="_blank" rel="noopener" href="https://www.ic.unicamp.br/~celio/peer2peer/math/bitmap-algorithms/durand03loglog.pdf">Durand와 Flajolet</a>이 제안한 해결 방법은 단일 해시 함수를 사용하지만 출력의 일부를 사용해 값을 여러 버킷 중 하나로 분할하는 방법이다. 입력 항목을 m 버킷으로 나누기 위해 해시 값의 처음 몇 k 비트를 버킷에 인덱스로 사용하고 남은 부분에서 가장 긴 연속 0 시퀀스를 계산하는 방법을 제안한다.</p>
<p>예를 들어 <code>hash(input)=101101101101100000</code>일때 가장 왼쪽 4개(k = 4)의 비트를 사용해 버킷 인덱스를 찾는다. 그리고 나머지 오른쪽 비트에서 연속 0의 개수를 얻을 수 있다. 따라서 이 예에서는 버킷 11에 값을 5로 업데이트 할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230511014519623.png" alt=""></p>
<p>버킷이 여러개 라는 것은 기본적으로 서로 다른 해시 함수가 있는 상황을 시뮬레이션 하는 것이다. 이렇게 하면 정확도 측면에서는 비용이 들지 않으며 많은 독립적인 해시 함수를 계산할 필요도 없어진다. 이 절차를 확률적 평균화라 한다. 마지막으로 아래 수식을 사용해 m개의 버킷 값<script type="math/tex">R_1, R_2, ... , R_m</script>을 사용해 고유 값의 개수를 추정한다.</p>
<script type="math/tex; mode=display">CARDINALITY_{LogLog} = constant * m * 2 ^ {1/m * \Sigma_{j=1}^n {R_j}}</script><p>통계 분석에 따르면 위 추정치는 더 큰 추정치에 대한 예측 가능한 편향이 있는 것으로 나타났다. Durand-Flajolet는 이 편향을 보정하기 위해 상수 <code>0.79402</code>를 도출했다.(LogLog 알고리즘) 버킷 수가 m인 경우 추정기의 표준 오차는 <script type="math/tex">1.3 / \sqrt{m}</script>으로 줄어든다. 따라서 각 버킷이 5비트인 2048개의 버킷을 사용하면 평균 오차는 약 2.8%이며 버킷당 5비트는 원본 논문에 따라 <script type="math/tex">2^{27}</script>의 카디널리티를 추정하기에 충분하고 2048 * 5 = 1.2KB의 메모리만 필요로 한다. 이는 기본적으로 1KB의 메모리로 꽤 좋은 결과이다.</p>
<h3 id="HLL-Improving-accuracy-even-further"><a href="#HLL-Improving-accuracy-even-further" class="headerlink" title="HLL: Improving accuracy even further"></a>HLL: Improving accuracy even further</h3><p>두 가지를 추가로 개선하면 더 나은 결과를 얻을 수 있다.</p>
<ol>
<li><p>Durand-Flajolet은 특이값이 이 추정기의 정확도를 크게 떨어트린다는 점을 발견했다. 따라서 평균을 내기 전에 가장 큰 값을 버리면 정확도를 향상시킬 수 있다. 구체적으로, 최종 추정치를 생성하기 위해 버킷 값을 수집할 때 가장 작은 70%의 값만 유지하고 나머지는 평균을 내기 위해 버리면 정확도를 <script type="math/tex">1.3 / \sqrt{m}</script>에서 <script type="math/tex">1.05 / \sqrt{m}</script>로 개선할 수 있다.(SuperLogLog 알고리즘)</p>
</li>
<li><p>HLL은 평가 함수에서 다른 유형의 평균을 사용한다. LogLog에서 사용되는 기하 평균 대신 조화 평균을 사용해 필요한 저장공간을 늘리지 않고도 오차를 <script type="math/tex">1.04 / \sqrt{m}</script> 미만으로 약간 낮출 것을 제안했다. 이 모든 것을 종합하면 고유값의 개수에 대한 HLL 추정치를 구할 수 있다.</p>
</li>
</ol>
<script type="math/tex; mode=display">CARDINALITY_{HLL} = constant * m * m / {\Sigma_{j=1}^n {2^{R_j}}}</script><h4 id="HLL-집합에-대한-연산"><a href="#HLL-집합에-대한-연산" class="headerlink" title="HLL 집합에 대한 연산"></a>HLL 집합에 대한 연산</h4><p>집합 병합 연산은 HLL에서 간단하게 계산할 수 있으며 무손실이다. 두 개의 HLL 데이터 구조를 결합하려면 두 데이터 구조의 해당 버킷 값의 최대값을 취한 다음 이를 결합된 HLL의 해당 버킷에 할당하기만 하면 된다. 이는 두 데이터 집합을 처음부터 하나의 HLL에 제공한것과 똑같다. 이런 간단한 집합 병합 연산을 통해 동일한 해시 함수와 동일한 수의 버킷을 사용해 여러 머신에서 독립적으로 작업을 쉽게 병렬화할 수 있다.</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2023/05/11/System%20Design/etc/hyperloglog/">https://songhayoung.github.io/2023/05/11/System%20Design/etc/hyperloglog/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/05/11/PS/Codeforces/avito-cool-challenge-2018-d/"><i class="fa fa-chevron-left">  </i><span>[Codeforces] Avito Cool Challenge 2018 D. Maximum Distance</span></a></div><div class="next-post pull-right"><a href="/2023/05/10/PS/HackerRank/powers-game-1/"><span>[Hacker Rank] Powers Game</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2024 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>