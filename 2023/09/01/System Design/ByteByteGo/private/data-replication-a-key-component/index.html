<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[ByteByteGo] Data Replication: A Key Component for Building Large-Scale Distributed Systems"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[ByteByteGo] Data Replication: A Key Component for Building Large-Scale Distributed Systems | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Data-Replication-A-Key-Component-for-Building-Large-Scale-Distributed-Systems"><span class="toc-number">1.</span> <span class="toc-text">Data Replication: A Key Component for Building Large-Scale Distributed Systems</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-Primer-on-Replication"><span class="toc-number">2.</span> <span class="toc-text">A Primer on Replication</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Improving-Durability"><span class="toc-number">2.1.</span> <span class="toc-text">Improving Durability</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Improving-Availability"><span class="toc-number">2.2.</span> <span class="toc-text">Improving Availability</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Increasing-Throughput"><span class="toc-number">2.3.</span> <span class="toc-text">Increasing Throughput</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reducing-Latency"><span class="toc-number">2.4.</span> <span class="toc-text">Reducing Latency</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Replication-Protocols"><span class="toc-number">2.5.</span> <span class="toc-text">Replication Protocols</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Leader-follower-replication"><span class="toc-number">3.</span> <span class="toc-text">Leader-follower replication</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronous-Replication"><span class="toc-number">3.1.</span> <span class="toc-text">Synchronous Replication</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Asynchronous-Replication"><span class="toc-number">3.2.</span> <span class="toc-text">Asynchronous Replication</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Consistency-Models"><span class="toc-number">3.3.</span> <span class="toc-text">Consistency Models</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Consistency-Issues"><span class="toc-number">3.4.</span> <span class="toc-text">Consistency Issues</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tunable-Consistency"><span class="toc-number">3.5.</span> <span class="toc-text">Tunable Consistency</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handling-Failures"><span class="toc-number">3.6.</span> <span class="toc-text">Handling Failures</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Follower-Failures"><span class="toc-number">3.6.1.</span> <span class="toc-text">Follower Failures</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Leader-Failures"><span class="toc-number">3.6.2.</span> <span class="toc-text">Leader Failures</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/hayoung-song-9523b61bb/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">10949</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">195</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">62</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[ByteByteGo] Data Replication: A Key Component for Building Large-Scale Distributed Systems</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-09-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/Byte-Byte-Go/">Byte Byte Go</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1.7k</span><span class="post-meta__separator">|</span><span>Reading time: 10 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Data-Replication-A-Key-Component-for-Building-Large-Scale-Distributed-Systems"><a href="#Data-Replication-A-Key-Component-for-Building-Large-Scale-Distributed-Systems" class="headerlink" title="Data Replication: A Key Component for Building Large-Scale Distributed Systems"></a>Data Replication: A Key Component for Building Large-Scale Distributed Systems</h2><span id="more"></span>
<p>데이터 복제는 안정적인 대규모 분산 시스템을 구축하는데 매우 중요하다. 이 포스트에서는 일반적인 복제 전략과 적합한 전략을 선택하기 위한 핵심 요소에 대해 알아본다. 이 포스트에서는 데이터베이스를 예로 들어 설명한다. 복제가 유용할 수 있는 데이터 소스는 데이터베이스 뿐이 아니라는 점에 유의해야 한다. 복제는 Redis와 같은 캐시 서버와 중요한 인메모리 데이터 구조를 위한 애플리케이션 서버에도 적용될 수 있다.</p>
<p>그렇다면 복제는 무엇일까? 복제는 한 장소에서 다른 장소로 데이터를 복사하는 방법이다. 필요할 때 언제 어디서나 데이터를 사용할 수 있도록 하기 위해 사용한다. 이를 통해 데이터의 내구성과 가용성을 개선하고 지연 시간을 줄이며 대역폭과 처리량을 늘릴 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230901020726529.png" alt=""></p>
<p>하지만 복제 전략을 선택하는 것이 항상 간단한 것은 아니다. 각 전략에는 고유한 장단점이 있는 다양한 전략이 있다. 어떤 전략은 특정 사용 사례에 더 적합할 수 있고, 어떤 전략은 다른 상황에 더 적합할 수 있다.</p>
<p>이번 포스트에서는 Leader-Follower, Multi-Leader, Leaderless라는 세 가지 주요 복제 전략을 살펴본다. 각 전략이 무엇인지, 어떻게 작동하는지, 어디에 가장 효과적으로 사용하는지 자세히 살펴본다. 또한 각 전략의 장단점에 대해 논의하여 시스템에 가장 적합한 전략에 대해 정보에 입각한 결정을 내릴 수 있도록 한다. </p>
<h2 id="A-Primer-on-Replication"><a href="#A-Primer-on-Replication" class="headerlink" title="A Primer on Replication"></a>A Primer on Replication</h2><p>복제가 필요한 이유를 개략적으로 살펴보자. 앞서 언급했듯이 여기서는 데이터베이스를 예로 사용하지만 다른 유형의 데이터 소스에도 적용된다.</p>
<h3 id="Improving-Durability"><a href="#Improving-Durability" class="headerlink" title="Improving Durability"></a>Improving Durability</h3><p>내구성 향상은 데이터 복제의 가장 중요한 이유일 것이다. 단일 데이터베이스 서버에 장애가 발생하면 치명적인 데이터 손실과 다운타임으로 이어질 수 있다. 데이터가 다른 데이터베이스 서버에 복제되어 있으면 한 서버가 다운되더라도 데이터는 보존된다. 비동기 복제와 같은 일부 복제 전략은 여전히 소량의 데이터 손실을 초래할 수 있지만 전반적인 내구성은 크게 향상된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230901021108937.png" alt=""></p>
<p>정기적인 데이터 백어으로 내구성이 충분하지 않은가에 대해서도 궁금할 수 있을 것이다. 백업은 하드웨어 장애와 같은 재해 발생 후 데이터를 복구할 수 있다. 하지만 백업만으로는 내구성에 한계가 있다. 백업은 주기적으로 이루어지므로 백업 주기 사이에 일부 데이터가 손실될 수 있다. 또한 백업에서 복원하는 속도도 느리고 다운타임이 발생한다. 대기 서버로의 복제는 데이터 손실 기간을 없애거나 크게 줄임으로써 추가적인 내구성을 제공하고 장애 조치를 더 빠르게 수행할 수 있도록 한다. 백업과 복제를 함께 사용하면 데이터 복구와 다운타임 최소화를 모두 달성할 수 있다.</p>
<h3 id="Improving-Availability"><a href="#Improving-Availability" class="headerlink" title="Improving Availability"></a>Improving Availability</h3><p>데이터를 복제해야 하는 또 다른 중요한 이유는 전반적인 시스템 가용성과 복원력을 개선하기 위해서다. 하나의 데이터베이스 서버가 오프라인 상태가 되거나 과부하가 걸리면 애플리케이션을 원활하게 실행하는 것이 어려울 수 있다.</p>
<p>단순히 트래픽을 새 서버로 리디렉션하는 것은 간단한 일이 아니다. 새 노드가 빠르게 인계받으려면 이미 거의 동일한 데이터 사본이 있어야 한다. 또한 애플리케이션과 사용자의 가동 시간을 지속적으로 유지하면서 데이터베이스를 백그라운드에서 전환하려면 신중한 페일오버 오케스트레이션이 필요하다. 복제는 대기 서버를 최신 데이터 복사본으로 준비 상태로 유지하여 원활한 페일오버를 가능하게 한다. 애플리케이션은 다운타임을 최소화하면서 문제 발생시 트래픽을 복제본으로 리디렉션할 수 있다. 잘 설계된 시스템은 모니터링, 로드 밸런싱, 복제 구성을 통해 리디렉션 및 장애 복구를 자동으로 처리한다.</p>
<p>물론 복제에는 자체 오버헤드 비용과 복잡성이 있다. 하지만 복제가 없다면 단 한번의 서버 중단으로 인해 다운타임이 장기화될 수 있다. 복제는 중단에도 불구하고 가용성을 유지한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230901021533534.png" alt=""></p>
<h3 id="Increasing-Throughput"><a href="#Increasing-Throughput" class="headerlink" title="Increasing Throughput"></a>Increasing Throughput</h3><p>여러 데이터베이스 인스턴스에 걸쳐 데이터를 복제하면 노드 간에 부하가 분산되어 전체 시스템 처리량과 확장성이 향상된다. 단일 데이터베이스 서버를 사용하면 성능이 저하되기전에 처리할 수 있는 동시 읽기 및 쓰기의 최대 임계값이 있다. 여러 서버로 복제하면 애플리케이션 요청을 복제본 간에 분산할 수 있다. 복제본이 많을수록 부하를 병렬로 처리할 수 있는 용량이 커진다.</p>
<p>이러한 요청의 샤딩은 워크로드를 분산시킨다. 따라서 전체 시스템에서 단일 서버에 비해 훨씬 더 높은 처리량을 유지할 수 있다. 필요에 따라 복제본을 추가하여 용량을 더욱 확장할 수 있다.</p>
<p>복제 자체에는 제대로 관리하지 않으면 병목 현상이 발생할 수 있는 관련 오버헤드가 있다. 노드 간 네트워크 대역폭, 복제 지연, 쓰기 조정과 같은 요인을 모니터링 해야한다. 하지만 적절한 복제 구성을 통해 읽기 및 쓰기 용량을 수평적으로 확장할 수 있다. 이를 통해 단일 서버의 한계를 훨씬 뛰어넘는 대규모 통합 처리량과 워크로드 확장성을 구현할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230901021818083.png" alt=""></p>
<h3 id="Reducing-Latency"><a href="#Reducing-Latency" class="headerlink" title="Reducing Latency"></a>Reducing Latency</h3><p>또한 데이터 복제는 데이터를 사용자에게 더 가까운 곳에 위치시켜 지연 시간을 개선할 수 있다. 예를 들어, 데이터베이스를 여러 지역에 복제하면 데이터 복사본이 로컬 사용자에게 더 가깝게 배치된다. 이렇게 하면 중앙 집중식 단일 데이터베이스 위치에 비해 데이터가 이동해야 하는 물리적 네트워크 거리가 줄어든다.</p>
<p>네트워크 거리가 짧아지면 전송 지연 시간도 줄어든다. 따라서 사용자의 읽기 및 쓰기 요청이 멀리 떨어진 인스턴스보다 가까운 복제 인스턴스로 라우팅될 때 응답 시간이 더 빨라진다. 다중 지역 복제를 사용하면 국가 간 또는 대륙 간 네트워크 경로의 긴 지연 시간을 피할 수 있는 지역화된 처리가 가능하다.</p>
<p>여러 지역에 복제본을 배포하면 복제본 동기화, 일관성, 동시 다중 사이트 업데이트에 따른 충돌 해결과 같은 복잡한 문제가 발생한다는 점에 유의해야 한다. 일광성 모델, 충돌 해결 로직, 복제 프로토콜과 같은 솔루션은 이러한 복잡성을 관리하는데 도움이 된다.</p>
<p>해당되는 경우, 다중 지역 복제는 처리를 지역화하여 지리적으로 분산된 사용자 및 워크로드의 지연 시간을 크게 개선한다. 지연 시간이 짧아지면 사용자 경험과 생산성도 향상된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230901022112242.png" alt=""></p>
<h3 id="Replication-Protocols"><a href="#Replication-Protocols" class="headerlink" title="Replication Protocols"></a>Replication Protocols</h3><p>특정 복제 전략은 노드 간의 조율과 합의에 도달하기 위해 Paxos나 Raft와 같은 프로토콜에 의존한다. </p>
<p>Paxos는 분산 시스템의 노드들이 데이터 값이나 시스템 상태에 대해 합의에 도달할 수 있도록 하는 프로토콜이다. 복잡한 장애 시나리오에서도 모든 노드가 업데이트에 동의하도록 보장한다. Paxos는 합의를 조율할 리더 노드를 선출한다. 리더는 제안된 업데이트를 복제본에게 보내고, 복제본은 이를 승인하거나 거부한다. Paxos는 CockroachDBd와 같은 시스템에서 활용된다.</p>
<p>Raft는 리더 선출을 위해 사용하는 또 다른 합의 프로토콜이다. Paxos보다 더 간단한 것으로 간주된다. 리더는 리더십을 유지하기 위해 하트비트로 메세지를 보낸다. 팔로워들이 충분한 하트비트를 놓치면 새로운 리더가 선출된다. Raft는 일반적으로 etcd와 같은 시스템에서 리더 선출에 사용된다.</p>
<p>이런 프로토콜은 노드 간의 합의 메커니즘을 제공하여 리더-팔로워와 같은 복제 전략을 용이하게 한다. 이런 프로토콜이 어떻게 조정과 합의를 가능하게 하는지 이해하면 다양한 복제 모델의 내부 작동 방식을 파악하는데 도움이 된다.</p>
<p>이제 복제의 주요 동기를 살펴보았으니 몇 가지 일반적인 복제 전략과 이러한 전략이 내구성, 가용성, 확장성, 지연 시간 요구 사항을 해결하는데 어떻게 도움이 되는지 살펴본다.</p>
<h2 id="Leader-follower-replication"><a href="#Leader-follower-replication" class="headerlink" title="Leader-follower replication"></a>Leader-follower replication</h2><p>리더-팔로워 모델은 데이터 복제에서 중요한 역할을 한다. 노드 간 로드 밸런스를 맞추려고 할 때 자주 사용하는 모델이다. 이 모델에서는 리더 노드가 모든 쓰기를 처리하고 읽기는 팔로워를 포함한 모든 노드로 이동할 수 있다. 이를 통해 노드 간 읽기 및 쓰기를 병렬화하여 시스템이 더 많은 요청을 처리할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230901155855714.png" alt=""></p>
<p>리더-팔로워 복제에는 크게 동기식 복제와 비동기식 복제의 두 가지 유형이 있다.</p>
<h3 id="Synchronous-Replication"><a href="#Synchronous-Replication" class="headerlink" title="Synchronous Replication"></a>Synchronous Replication</h3><p>동기식 복제를 사용하면 리더에 대한 각 쓰기가 완료되기 전에 팔로워에게 데이터가 복제되었다는 확인을 기다린다. 팔로워는 다음 쓰기가 발생하기 전에 최신 쓰기가 보장되므로 강력한 데이터 일관성을 보장한다.</p>
<p>하지만 이러한 안전성에는 대가가 따른다. 복제 확인을 위한 추가 네트워크 왕복으로 인해 쓰기에 지연 시간이 추가된다. 특히 쓰기량이 많거나 노드가 지리적으로 분산되어 있는 경우 성능이 저하될 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230901160023728.png" alt=""></p>
<h3 id="Asynchronous-Replication"><a href="#Asynchronous-Replication" class="headerlink" title="Asynchronous Replication"></a>Asynchronous Replication</h3><p>비동기 복제는 리더가 복제 확인을 기다릴 필요 없이 쓰기를 완료할 수 있도록 하여 성능을 개선한다. 따라서 쓰기 지연 시간이 크게 줄어든다. 팔로워 장애도 쓰기 가용성에 영향을 미치지 않는다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230901160105981.png" alt=""></p>
<p>하지만 여기에는 위험이 있다. 팔로워 노드가 데이터를 충분히 빠르게 복제하지 못하고 리더 노드 장애가 발생하면 일부 데이터가 손실될 수 있다. 또 다른 단점은 리더 노드와 팔로워 노드 간의 데이터가 일치하지 않은 작은 창이 있다는 것이다. 데이터가 리더에서 팔로워로 복제되는데 걸리는 시간을 복제 지연이라고 한다. 이 복제 지연으로 인해 사용자는 최근 쓰기의 다른 결과를 얻을 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230901160205876.png" alt=""></p>
<p>일관성과 가용성 / 성능 간의 절충점을 신중하게 고려해야 한다. 동기식 복제는 더 강력한 일관성을 제공한다. 비동기 복제는 더 높은 가용성과 성능을 제공한다.</p>
<p>실제로는 성능이 중요하기 때문에 비동기 복제가 일반적이다. 그러나 복제 지연은 일관성 문제를 완화하기 위한 추가적인 전략이 필요하다.</p>
<h3 id="Consistency-Models"><a href="#Consistency-Models" class="headerlink" title="Consistency Models"></a>Consistency Models</h3><p>지금까지는 강력하고 궁극적인 일관성 모델에 중점을 두었다. 그러나 다른 일관성 모델도 다양한 보장 기능을 제공하며 복제 전략에 영향을 미친다.</p>
<p>선형성은 매우 강력한 순서 보장을 제공하여 읽기가 최신 쓰기를 즉시 반영하도록 보장한다. 이를 위해서는 복제본을 동기화하기 위해 동기 복제가 필요하다.</p>
<p>순차적 일관성은 노드 간 쓰기 순서를 보장하지만 읽기 전에 쓰기를 전파하는데 약간의 지연이 발생할 수 있다(업데이트가 모든 노드의 데이터 뷰에 즉시 반영될 필요가 없음). 이를 통해 비동기 복제의 유연성을 확보할 수 있다.</p>
<p>인과적 일관성은 인과성이 있는 쓰기 간에만 순서를 적용한다. 인과성이 없는 쓰기는 순서 없이 표시될 수 있다. 따라서 비동기 복제에 대한 동시성 요구 사항이 더욱 완화된다.</p>
<p>이런 강력한 모델은 비동기 복제를 사용할 수 있는 방법을 제한하는 순서 제약 조건을 추가한다. 일관성 모델이 약할수록 유연성은 높아지지만 오래된 읽기의 위험이 높아진다. 이런 장단점을 이해하면 복제 전략을 선택하는데 도움이 된다.</p>
<p>비동기 복제의 유연성에는 리더와 팔로워 간의 복제 지연이라는 대가가 따른다. 이러한 지연으로 인해 고려해야 할 여러가지 일관성 문제가 발생할 수 있다.</p>
<h3 id="Consistency-Issues"><a href="#Consistency-Issues" class="headerlink" title="Consistency Issues"></a>Consistency Issues</h3><p>첫 번째는 “read-your-own-write” 불일치다. 사용자가 방금 새 프로필 사진을 업로드한 후 즉시 프로필을 확인해도 복제 지연으로 인해 이전 사진이 계속 표시될 수 있다고 가정하자. 이 지연은 새 사진(write)이 팔로워 노드(일반적 읽기 쿼리가 가는 곳)에 복제되는 데 걸리는 시간으로 인해 발생한다. 이러한 불일치로 인해 사용자는 혼란을 겪을 수 있으며 업로드가 성공했는지 의문을 품을 수도 있다. 원활한 사용자 경험을 위해서는 읽기-쓰기 일관성을 유지하는 것이 중요하다. 이를 처리하는 한 가지 방법은 복제 지연 문제를 피하기 위해 리더 노드에 쓰기 후 읽기를 직접 처리하는 것이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230901161253552.png" alt=""></p>
<p>또 다른 잠재적 문제는 서로 다른 복제본에서 일관되지 않은 읽기가 발생하는 것이다. 읽기 복제본 앞에 로드 밸런서를 배치하여 라운드 로빈 방식으로 부하를 분산하는 로드 밸런서가 있는 경우 이러한 문제는 드물지 않다. 이러한 불일치는 일부 애플리케이션에서는 허용될 수 있지만 다른 애플리케이션에서는 허용되지 않을 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230901161351532.png" alt=""></p>
<h3 id="Tunable-Consistency"><a href="#Tunable-Consistency" class="headerlink" title="Tunable Consistency"></a>Tunable Consistency</h3><p>많은 최신 시스템에서는 작업별로 일관성 수준을 조정할 수 있다. 이를 통해 애플리케이션은 필요에 따라 강력한 일관성과 고가용성 및 성능 간의 균형을 맞출 수 있다.</p>
<p>예를 들어, 애플리케이션은 정확한 계정 잔액을 보장하기 위해 금융 거래에 강력한 일관성을 사용할 수 있다. 하지만 분석 쿼리의 경우, 성능과 가용성을 개선하기 위해 이벤트 일관성이 허용될 수 있다.</p>
<p>마찬가지로, 읽기-쓰기 일관성을 보장하기 위해 사용자의 초기 로그인에 동기식 복제를 사용할 수 있다. 그러나 비동기 복제는 덜 중요한 백엔드 업데이트를 처리하여 처리량을 최대화할 수 있다.</p>
<p>일관성 수준을 조정할 수 있는 기능은 복제 전략 간의 균형을 맞추는데 유연성을 더한다. 최적의 균형은 특정 애플리케이션의 기능적 요구 사항, 성능 요구 사항, 불일치에 대한 허용 오차에 따라 달라진다.</p>
<h3 id="Handling-Failures"><a href="#Handling-Failures" class="headerlink" title="Handling Failures"></a>Handling Failures</h3><p>리더-팔로워 복제를 통해 노드 장애를 처리하는 전략을 살펴보자.</p>
<h4 id="Follower-Failures"><a href="#Follower-Failures" class="headerlink" title="Follower Failures"></a>Follower Failures</h4><p>주기적인 상태 확인을 통해 팔로워의 장애 여부를 감지할 수 있다. 장애가 발생한 노드를 감지하면 즉각적인 조취를 취하고 장애가 발생한 팔로워로 향하던 트래픽을 정상 노드로 리디렉션 한다. 동시에 장애가 발생한 팔로워를 교체하거나 재시작하여 다시 온라인 상태가 되도록 노력한다.</p>
<p>그러나 트래픽을 용량에 가까운 복제본으로 리디렉션 하면 전체 클러스터에 과부하가 걸리고 충돌이 발생할 위험이 있다. 트래픽을 이동하기 전에 사용 가능한 용량을 신중하게 고려해야 한다.</p>
<h4 id="Leader-Failures"><a href="#Leader-Failures" class="headerlink" title="Leader Failures"></a>Leader Failures</h4><p>리더 노드에 장애가 발생하면 상황은 더욱 복잡해진다. 쓰기는 리더에서만 발생할 수 있기 때문에 단순히 트래픽을 리디렉션할 수 없다.</p>
<p>하트비트 검사는 실패한 리더를 감지하는데 도움이 된다. 리더가 실패하면 수동으로 팔로워를 새로운 리더로 승격시키거나 Raft와 같은 자동화된 리더 선출 프로토콜을 사용하여 팔로워 노드 중에서 새로운 리더를 선출한다.</p>
<p>단점은 수동으로 또는 선거 절차를 통해 리더를 교체하는데 시간이 걸리고 시스템이 일시적으로 쓰기 작업에 중단될 수 있다는 점이다. 새 리더가 자리를 잡으면 정상적인 운영이 재개될 수 있다. 일부 시스템에서는 이러한 지연이 허용되지 않을 수 있다.</p>
<p>여기까지 리더-팔로워 복제의 기본 사항에 대해 설명했다. 이 모델은 강력하고 인기 있는 모델이지만 유일한 모델은 아니다. 다음 시리즈에서는 리더-팔로워를 넘어 멀티리더와 리더리스 복제라는 두 가지 모델을 추가로 살펴본다.</p>
<p>이 두 가지 모델의 고유한 설계를 비교하고 탁월한 사용 사례를 살펴보고, 올바른 전략을 선택하기 위한 지침을 제공할 것이다.</p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2023/09/01/System%20Design/ByteByteGo/private/data-replication-a-key-component/">https://songhayoung.github.io/2023/09/01/System%20Design/ByteByteGo/private/data-replication-a-key-component/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2024 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>