<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[ByteByteGo] Capacity Planning"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[ByteByteGo] Capacity Planning | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Capacity-Planning"><span class="toc-number">1.</span> <span class="toc-text">Capacity Planning</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Throughput-Calculation"><span class="toc-number">2.</span> <span class="toc-text">Throughput Calculation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Throughput-hint-scenario"><span class="toc-number">2.1.</span> <span class="toc-text">Throughput hint scenario</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Throughput-through-DAU-scenario"><span class="toc-number">2.2.</span> <span class="toc-text">Throughput through DAU scenario</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Peak-QPS"><span class="toc-number">2.3.</span> <span class="toc-text">Peak QPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Estimating-server-requirement"><span class="toc-number">2.4.</span> <span class="toc-text">Estimating server requirement</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Understanding-request-sizes"><span class="toc-number">3.</span> <span class="toc-text">Understanding request sizes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Considerations-for-Request-Sizing"><span class="toc-number">3.1.</span> <span class="toc-text">Considerations for Request Sizing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bandwidth-amp-data-in-transit"><span class="toc-number">4.</span> <span class="toc-text">Bandwidth &amp; data in transit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Client-to-server-ingress"><span class="toc-number">4.1.</span> <span class="toc-text">Client to server (ingress)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Server-to-client-egress"><span class="toc-number">4.2.</span> <span class="toc-text">Server to client (egress)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Storage-amp-data-at-rest"><span class="toc-number">5.</span> <span class="toc-text">Storage &amp; data at rest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Caching"><span class="toc-number">6.</span> <span class="toc-text">Caching</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Caching-reads"><span class="toc-number">6.1.</span> <span class="toc-text">Caching reads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Caching-to-alleviate-write-bottlenecks"><span class="toc-number">6.2.</span> <span class="toc-text">Caching to alleviate write bottlenecks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Effective-cache-management"><span class="toc-number">6.3.</span> <span class="toc-text">Effective cache management</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Operating-capacity"><span class="toc-number">7.</span> <span class="toc-text">Operating capacity</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Alerts-amp-monitoring"><span class="toc-number">7.1.</span> <span class="toc-text">Alerts &amp; monitoring</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Staying-vigilance"><span class="toc-number">7.2.</span> <span class="toc-text">Staying vigilance</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">8.</span> <span class="toc-text">Conclusion</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.instagram.com/hayoung0_0/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">8253</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">193</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">60</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[ByteByteGo] Capacity Planning</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-07-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/Byte-Byte-Go/">Byte Byte Go</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3.1k</span><span class="post-meta__separator">|</span><span>Reading time: 19 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Capacity-Planning"><a href="#Capacity-Planning" class="headerlink" title="Capacity Planning"></a>Capacity Planning</h2><span id="more"></span>
<p>용량 계획은 실제 시스템 설계 환경에서 필수적인 역할을 한다. 이 복잡한 작업은 단순한 이론적 고려사항이 아니라 엔지니어가 제안한 시스템의 용량 요구 사항을 정확하게 예측하는 데 필수적이다. 시스템 설계에 용량 계획의 중요성을 강조하는 몇 가지 이유가 있다.</p>
<ul>
<li>용량 계획을 통해 제안된 설계가 실현 가능하지 여부를 알 수 있다. 엔지니어는 용량 계획을 통해 시스템 성능 또는 확장성의 잠재적인 병목 현상을 예측하고, 데이터 스토리지 요구 사항, 네트워크 대역폭 요구 사항을 평가하고, 예상 리소스 비용을 예측할 수 있다. 이를 통해 지연 시간, 처리량, 가용성과 같은 측면이 비기능적 요구사항과 일치하는지 확인할 수 있다.</li>
<li>어떤 설계는 기능적으로는 실현 가능해보이지만 운영상 문제가 있을 수 있다. 예를 들어, 시스템에서 급증하는 수요를 처리해야 하는 경우 많은 추가 리소스가 필요할 수 있다. 이로 인해 운영 비용이 엄청나게 높아질 수 있다.</li>
<li>효과적인 용량 계획은 시스템 설계에 대한 깊은 이해를 보여준다. 이는 엔지니어가 다양한 설계 옵션과 기술에 대한 지식과 각각의 장단점을 알고 있음을 나타낸다. 또한 잠재적인 문제를 예측하고 적절한 해결책을 찾는 능력도 반영한다. 이는 더 잘 작동하고 더 효율적인 시스템 개발로 이어질 수 있다.</li>
</ul>
<p>따라서 대규모 시스템을 설계할 때는 처음부터 용량 계획에 대해 고려하는 것이 중요하다. 엔지니어는 시스템이 수행해야 하는 작업과 필요한 성능을 이해함으로써 확장 가능하고 효율적인 시스템을 계획하고 구축할 수 있다. 이제 실제 시스템 설계에서 용량 계획이 어떻게 작동하는지 살펴보자.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230702004801606.png" alt=""></p>
<h2 id="Throughput-Calculation"><a href="#Throughput-Calculation" class="headerlink" title="Throughput Calculation"></a>Throughput Calculation</h2><p>대규모 시스템을 설계할 때는 처음에 시스템 규모를 추정하는 것이 중요하다. 요구 사항이 처리량을 암시하거나 일일 활성 사용자 수와 같은 관련 메트릭을 통해 추론해야 할 수 있다.</p>
<h3 id="Throughput-hint-scenario"><a href="#Throughput-hint-scenario" class="headerlink" title="Throughput hint scenario"></a>Throughput hint scenario</h3><p><strong>예제 1 - 온도 센서</strong> 라는 모니터링 시스템을 살펴보자. 이 시스템은 약 1,000만 개의 센서를 사용하여 카운티 전체의 온도 변화를 측정해야 한다. 이러한 센서는 5초마다 변화를 보고한다. 분석가는 이 시스템을 사용해 보고서를 표시하는 대시보드를 사용하여 날씨를 예측한다.</p>
<p>이런 요구 사항을 통해 시스템 용량에 대한 몇 가지 사항을 유추할 수 있다. 다음과 같이 처리량을 추정한다.</p>
<ul>
<li>극단적인 경우, 모든 센서가 동기화되면 초당 1,000만 개의 쿼리(QPS)가 발생할 수 있다. 그러나 이는 가능성이 희박한 엣지 케이스다.</li>
<li>센서에서 서버로 전송되는 각 요청이 200ms 동안 지속된다고 가정하면, 보다 현실적인 평균은 200만 QPS다.</li>
<li>따라서 이 시스템의 경우 적절한 처리량 추정치는 약 200만 QPS다.</li>
</ul>
<h3 id="Throughput-through-DAU-scenario"><a href="#Throughput-through-DAU-scenario" class="headerlink" title="Throughput through DAU scenario"></a>Throughput through DAU scenario</h3><p>때로는 처리량이 요구 사항에 명확하지 않을 수 있다. <strong>예제 2 - 미디어 뉴스 피드</strong>를 살펴보자.</p>
<p>이 시스템을 통해 사용자는 시간순으로 정리된 프로필 타임라인에 텍스트, 이미지, 동영상을 게시할 수 있다. 사용자는 다른 사용자를 팔로우하고 자신의 타임라인에서 자신이 팔로우하는 사용자의 관련 게시물을 볼 수 있다. 용량 계획에 정보를 제공하기 위해 다음과 같이 질문할 수 있다.</p>
<ul>
<li>이 시스템의 일일 활성 사용자는 몇 명인가?</li>
<li>2~5년 후 예상되는 사용자 기반 증가율은 얼마인가?</li>
</ul>
<p>그런 다음 기능 요구 사항에 따라 처리량을 계산한다. 가장 관련성이 높은 게시물이 홈페이지의 타임라인에 표시되면 모든 일일 활성 사용자가 해당 게시물과 상호 작용할 가능성이 높다. 각 사용자가 하루에 특정 횟수(예: 10회)로 상호 작용한다고 가정하면 하루에 50억 페이지 뷰, 즉 약 6만 QPS를 의미한다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">500M users @ 10x pageviews/user = 5B timeline pageviews/day</span><br><span class="line">5B pageviews / 86400 seconds (1 day = 24 * 60 * 60) = ~57.8k QPS</span><br><span class="line">Round up to 60k QPS</span><br></pre></td></tr></table></figure>
<p>프로필 방문은 홈페이지 방문보다 빈도가 낮을 가능성이 높다. 각 사용자가 하루에 프로필 페이지를 두 번 방문한다고 가정하면 평균 QPS는 약 12,000이다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Simplest way to calculate: 20% of 60k (previous example) = 12k QPS</span><br><span class="line"></span><br><span class="line">Or, to expand:</span><br><span class="line"></span><br><span class="line">500M users @ 2x pageviews/user = 1B profile pageviews/day</span><br><span class="line">1B pageviews / 86400 seconds (1 day = 24 * 60 * 60) = ~11.5k QPS</span><br><span class="line">Round up to 12k</span><br></pre></td></tr></table></figure>
<p>게시물의 경우, 평균적으로 일일 활성 사용자의 10%만이 하루에 한 번씩 게시물을 작성한다고 가정해보자. 이는 평균 QPS가 약 6천번이라는 것을 의미한다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Simplest way to calculate: 10% of 60k (previous example) = 6k QPS</span><br><span class="line"></span><br><span class="line">Or, to expand:</span><br><span class="line"></span><br><span class="line">500M users * 10% = 50M new posts/day</span><br><span class="line">50M new posts / 86400 seconds (1 day = 24 * 60 * 60) = ~5.7k QPS</span><br><span class="line">Round up to 6k</span><br></pre></td></tr></table></figure>
<p>이는 대략적인 추정치라는 점을 기억해야 한다. 대부분의 시스템 설계에서는 이 정도면 충분하다. 좋은 팁은 어림수로 생각하고 반올림하여 보수적인 추정을 보장하는 것이다.</p>
<h3 id="Peak-QPS"><a href="#Peak-QPS" class="headerlink" title="Peak QPS"></a>Peak QPS</h3><p>피크 QPS를 계산하는 것은 종종 설계의 용량 요구 사항을 결정하기 때문에 중요하다. 피크 QPS는 시스템이 쿼리를 처리할 것으로 예상되는 최고 속도를 의미하며, 사용량이 많거나 트래픽이 급증하는 시기에 주로 발생한다. 이는 평균 속도보다 훨씬 높을 수 있다. 그렇기 때문에 특별한 주의가 필요하다.</p>
<p>최대 QPS를 결정하는 일반적인 방법 중 하나는 과거 데이터 분석을 이용하는 것이다. 여기에는 며칠, 몇 주 또는 몇 달과 같은 특정 기간 동안 인프라가 처리하는 쿼리 수를 추적한 다음 가장 높은 값을 선택하는 것이 포함된다. 이 방법은 데이터의 가용성과 시스템의 과거 성능에 의존한다.</p>
<p>인프라를 오버프로비저닝하거나 오토 스케일링 기능을 활용하는 것도 피크 QPS를 처리하는 데 도움이 될 수 있다. 이러한 전략을 사용하면 시스템이 일시적으로 용량을 늘려 예기치 않은 트래픽 급증을 처리할 수 있다. 그러나 이러한 전략에는 자체 비용이 수반되므로 신중한 비용 편익 분석이 필요하다. 또한 피크 QPS는 비즈니스 요구 사항이나 예측 가능한 사용 패턴의 영향을 받을 수 있다. 예를 들면 아래와 같다.</p>
<ul>
<li>이벤트 기반 피크 : 주요 제품 출시 또는 마케팅 이벤트로 인해 짧은 시간 내에 시스템에 가입하거나 사용하는 사용자가 급증할 수 있다. 이러한 이벤트를 예측하고 대비하면 수요가 급증하는 동안 서비스 품질을 유지하는 데 도움이 될 수 있다.</li>
<li>시간 기반 피크 : 일부 시스템에서는 일별 또는 주별로 예측 가능한 사용량 변동이 발생할 수 있다. 예를 들어, 업무용 애플리케이션의 경우 늦은 저녁이나 이른 아침에 비해 근무 시간 중에 트래픽이 훨씬 더 많이 발생할 수 있다.</li>
</ul>
<p>최대 QPS를 추정하기 위해 예상되는 분포 특성을 기반으로 계산하는 경우가 많다. 예를 들어 하루 방문의 80%가 20%의 시간 내에 발생한다고 가정할 수 있다(파레토 법칙). 예상치 못한 급증을 처리하고 원활한 사용자 경험을 제공하기 위해 약간의 버퍼 용량을 추가한다.</p>
<p><strong>예제 2 - 소셜 미디어 뉴스피드</strong>에서 타임라인 페이지뷰의 80%가 8시간 내에 발생한다고 예상하면 이 기간의 최대 QPS는 약 13만 8천 건으로 계산할 수 있다. 하지만 이는 시작점일 뿐이므로 처음에는 초과 프로비저닝하고 데이터를 모니터링한 다음 실제 사용 패턴에 따라 조정하는 것이 항상 좋은 관행이다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">500M users @ 10x page views / user = 5B timeline pageviews/day</span><br><span class="line"></span><br><span class="line">80% of pageviews = 4B timeline pageviews</span><br><span class="line">Per hour over a period of 8 hours = 4B page views / 8 hours = 500M / hour</span><br><span class="line"></span><br><span class="line">Average Peak QPS = 500M / 3600 (60 minutes in seconds) = 138k</span><br></pre></td></tr></table></figure>
<p>최대 QPS에 대비하면 부하가 가장 많은 상황에서도 시스템의 안정성과 응답성을 유지할 수 있다. 이는 더 나은 사용자 경험과 시스템 안정성에 기여한다.</p>
<h3 id="Estimating-server-requirement"><a href="#Estimating-server-requirement" class="headerlink" title="Estimating server requirement"></a>Estimating server requirement</h3><p>예상 처리량과 응답 시간을 통해 애플리케이션을 실행하는데 필요한 서버 수를 추정할 수 있다. 예제 1 - 온도 센서에서 시스템의 평균 응답 시간이 200ms이고 2M QPS를 처리해야 하며 각 애플리케이션 서버가 32명의 작업자를 관리하며 160 QPS를 처리할 수 있다면 약 12.5만 개의 서버 인스턴스가 필요하다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2M QPS, 200ms avg response time per request</span><br><span class="line">Each instance has 32 workers</span><br><span class="line">Each worker can handle 5 queries per second (200ms*5)</span><br><span class="line">Each instance can handle then 160 QPS</span><br><span class="line">2M (average QPS) / 160 = 12.5k instances</span><br></pre></td></tr></table></figure>
<p>전체 시스템의 규모를 추정했으니 이제 요청 크기 조정부터 시작하여 설계 중인 시스템의 세부 사항에 집중해 본다.</p>
<h2 id="Understanding-request-sizes"><a href="#Understanding-request-sizes" class="headerlink" title="Understanding request sizes"></a>Understanding request sizes</h2><p>요청 크기를 평가하는 것은 대역폭과 스토리지 요구 사항을 결정하는 데 매우 중요하다. 시스템 설계 시 시스템 부하에 큰 영향을 미칠 수 있는 다양한 요청 유형을 수용해야 하는 경우가 많다. 이러한 요청은 데이터를 검색하는 GET 요청처럼 단순할 수도 있고 대용량 멀티미디어 파일을 포함하는 POST 요청처럼 복잡할 수도 있다.</p>
<p>초기 요구 사항에 특정 요청 크기가 포함되어 있지 않을 수도 있지만, 시스템의 기능과 처리하는 데이터의 특성을 바탕으로 정보에 입각한 가정을 할 수 있다. 요청 크기를 추정할 때 시스템 유형에 따라 당연히 기대치가 달라진다. 지금까지 논의한 두 가지 예를 살펴본다.</p>
<p><strong>예제 1 - 온도 센서</strong>와 같은 시스템의 경우 전송되는 데이터가 상대적으로 작을 수 있다. 데이터가 JSON 형식으로 전송된다고 가정하면 각 필드의 크기를 추정할 수 있다. 온도는 실수(4바이트)로 보고되고, 센서 ID는 UUID(16바이트)이며, 추가로 4바이트 필드 3개가 있다. JSON 형식을 고려하면 총 요청 본문 크기는 100바이트 미만이다. HTTP 헤더(일반적으로 200바이트에서 400바이트 사이)를 포함하면 각 요청 크기는 보수적으로 약 0.5KB로 추정할 수 있다. 이는 매우 작은 크기다. 그러나 수백만 개의 센서를 다룰 때는 이렇게 작은 데이터 요청도 합산될 수 있으므로 이를 고려해야 한다.</p>
<p><strong>예제 2 - 소셜 미디어 뉴스 피드</strong>와 같은 시스템에서는 텍스트, 이미지, 동영상 등 다양한 콘텐츠 유형을 처리한다. 텍스트 게시물은 몇 KB에 불과할 수 있지만 이미지 파일은 수백 KB, 동영상 파일은 몇 MB에 달할 수 있다. 이러한 시나리오에서 평균 요청 크기는 다양한 콘텐츠 유형의 분포과 크기를 고려해야 한다.</p>
<p>사용자 ID(UUID)와 평균 250자의 자유 형식 문자열을 포함하는 텍스트 전용 게시물을 약 1KB로 보수적으로 추정해 보자. 이미지 및 동영상의 경우 10개의 글마다 3개의 이미지(압축 후 평균 300KB 크기)와 1개의 동영상(평균 1MB 크기)이 있다고 가정해 보자. 계산을 단순화하기 위해 이러한 모든 미디어 유형을 평균으로 합산할 수 있다. 이렇게 하면 게시물당 평균 요청 크기가 약 200KB가 된다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">For 10 posts:</span><br><span class="line">- Every post has 1KB (text) = 10KB</span><br><span class="line">- Three have an image = 300KB * 3 = 900KB</span><br><span class="line">- One has a video = 1000KB</span><br><span class="line"></span><br><span class="line">~191KB, round up to 200KB</span><br></pre></td></tr></table></figure>
<h3 id="Considerations-for-Request-Sizing"><a href="#Considerations-for-Request-Sizing" class="headerlink" title="Considerations for Request Sizing"></a>Considerations for Request Sizing</h3><p>요청 크기를 이해하는 것은 방정식의 일부에 불과하다. 데이터 형식, 직렬화 / 역직렬화, 그리고 이것이 대역폭과 처리 요구 사항에 미치는 영향과 같은 요소도 고려해야 한다.</p>
<ul>
<li>데이터 형식 : 전송되는 데이터의 형식은 필요한 대역폭에 큰 영향을 미칠 수 있다. XML과 같이 더 자세한 데이터 형식은 JSON과 같이 덜 자세한 형식에 비해 더 많은 대역폭을 소비할 수 있다. 유사한 형식 중에서도 바이너리 JSON(BSON)과 같은 옵션이 더 효율적일 수 있다.</li>
<li>직렬화 / 역직렬화 : 데이터를 쉽게 전송하거나 저장할 수 있는 형식으로 변환(직렬화)한 다음 다시 원래 형식으로 되돌리려면(역직렬화) 상당한 리소스가 필요할 수 있다. 방법마다 비용과 이점이 다르다. 예를 들어 직렬화 및 역직렬화에서는 Protobuf가 JSON보다 빠르지만, 사람이 더 쉽게 읽을 수 있고 디버깅이 더 쉽다.</li>
<li>압축 : 데이터 압축을 구현하면 요청 크기를 효과적으로 줄이고 대역폭을 절약할 수 있다. 추가적인 처리 오버헤드가 발생하지만, 특히 대용량 페이로드의 경우 이 정도는 감수할 수 있거나 오히려 이득이 될 수도 있다.</li>
<li>네트워크 프로토콜 : 네트워크 프로토콜(HTTP / 1.1, HTTP / 2, gRPC 등)의 선택은 헤더의 차이, 헤더 압축 기능 및 기타 요인으로 인해 요청의 전체 크기에 영향을 미칠 수도 있다.</li>
</ul>
<p>요청 크기 조정은 용량 계획의 중요한 측면이다. 가정을 전제로 해야 하지만, 이러한 정보에 기반한 추측은 시스템의 요구 사항을 예측하는 데 도움이 된다. 이를 통해 예상되는 부하와 트래픽 패턴을 처리할 수 있는 준비를 갖출 수 있다.</p>
<h2 id="Bandwidth-amp-data-in-transit"><a href="#Bandwidth-amp-data-in-transit" class="headerlink" title="Bandwidth &amp; data in transit"></a>Bandwidth &amp; data in transit</h2><p>각 레코드의 비용을 이해하는 것은 기본이다. 클라이언트에서 서버로(ingress), 서버에서 클라이언트로(egress) 양방향으로 작업당 대역폭을 고려해야 한다.</p>
<h3 id="Client-to-server-ingress"><a href="#Client-to-server-ingress" class="headerlink" title="Client to server (ingress)"></a>Client to server (ingress)</h3><p><strong>예제 1 - 온도센서</strong>에서 센서가 애플리케이션으로 전송하는 데이터를 수신, 즉 애플리케이션의 네트워크로 들어오는 데이터라고 한다. 각 센서 요청이 0.5KB이고 평균 QPS가 400k라고 가정하면 평균 인그레스 대역폭은 초당 약 200MB다. 대시보드 등에 대한 읽기 경로는 용량에 큰 영향을 미치지 않을 것이므로 논의를 단순화할 수 있다.</p>
<p>고려해야할 흥미로운 측면은 서버에 데이터를 얼마나 자주 전송해야 하는가이다. 모든 데이터가 즉각적인 전송을 필요로 하는 것은 아닐 수 있다. 예를 들어 온도 센서는 온도 변화가 크게 일어났을 때만 데이터를 보고하면 될 수도 있다. 온도 상태를 센서에 로컬로 저장하고 변화가 있을 때만 전송하면 잠재적으로 용량 부하와 비용을 줄일 수 있다.</p>
<p>하지만 센서가 서버에 보고하지 않고 사용할 수 있는 최대 시간을 설정하는 것이 중요하다. 이렇게 하면 오작동하거나 오프라인 상태인 센서를 즉시 파악할 수 있다.</p>
<h3 id="Server-to-client-egress"><a href="#Server-to-client-egress" class="headerlink" title="Server to client (egress)"></a>Server to client (egress)</h3><p><strong>예제 2 - 소셜 네트워킹 뉴스 피드</strong>와 같은 시스템을 고려할 때 콘텐츠를 게시하는 것은 인그레스 트래픽과 동일하다. 이전 추정치에 따라 각 게시물의 용량이 1KB이고 평균 QPS가 6k라고 가정하면, 인그레스 대역폭은 초당 약 6MB이다.</p>
<p>송신, 즉 서버에서 클라이언트로 전송되는 데이터는 더 복잡할 수 있다. 시스템이 20개의 게시물마다 페이지네이션을 하고 서버가 매번 원시 파일 버전을 렌더링한다고 가정해 보겠다. 이 시나리오에서는 평균 송신 대역폭이 초당 250GB로 매우 높아진다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">500M users @ 10x pageviews/user = 5B timeline pageviews/day</span><br><span class="line">Average post request size: 200KB</span><br><span class="line">Assuming every time timelines are rendered the server sends everything to the client.</span><br><span class="line"></span><br><span class="line">20 posts * 200 KB = 4MB</span><br><span class="line">5B pageviews * 4MB = 20PB</span><br><span class="line">20PB / 86400 (1 day = 24 * 60 * 60) = ~231GB/s</span><br><span class="line"></span><br><span class="line">Round up to ~250GB/s</span><br></pre></td></tr></table></figure>
<p>하지만 이 송신 트래픽을 줄이기 위한 최적화 전략이 있다.</p>
<ul>
<li>콘텐츠 다듬기 : 기본적으로 글 콘텐츠의 전체 텍스트를 보내지 않음으로써 데이터 부하를 줄일 수 있다. 이렇게 하면 텍스트 크기를 절반으로 줄일 수 있다.</li>
<li>이미지 최적화 : 처음에는 저품질 이미지 플레이스홀더를 전송하고 사용자 상호 작용 및 뷰포트 가시성에 따라 고품질 이미지를 점진적으로 로드할 수 있다.</li>
<li>비디오 최적화 : 동영상 자동 재생을 끄고 기본적으로 썸네일만 로드할 수 있다. 전체 동영상은 필요에 따라 스트리밍할 수 있으므로 초기 데이터 부하를 크게 줄일 수 있다.</li>
</ul>
<p>대략적인 계산은 다음과 같다.</p>
<ul>
<li>전체 사용자중 80%는 타임라인에서 다섯 번째 게시물을 지나치지 않는다.</li>
<li>텍스트의 일부만 발췌하여 전송하면 텍스트 크기가 50% 줄어든다.</li>
<li>클라이언트에 전송되는 썸네일 크기를 플레이스홀더로 30KB로 줄이고 뷰포트에 표시되는 내용은 온디멘드(300KB)로만 로드한다.</li>
<li>동영상은 재싱 시에만 로드되며(자동 재생 없음), 기본적으로 이미지와 동일한 썸네일을 점진적으로 로드한다. 전체 사용자의 10%만이 동영상을 재상한다.</li>
</ul>
<p>캐싱 없이도 약 67%의 용량 절약을 달성할 수 있다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Previous average post request size: 200KB</span><br><span class="line">======</span><br><span class="line">Now, for 10 posts (without counting progressive loading):</span><br><span class="line">- Every post has 0.5KB (text) = 5KB</span><br><span class="line">- Three have an image = 30KB * 3 = 90KB</span><br><span class="line">- One has a video = 30KB</span><br><span class="line">12.5KB, round up to 15KB</span><br><span class="line"></span><br><span class="line">Timelines render 20 posts by default, 80% stops at 5th post (25%)</span><br><span class="line">Assume users will interact with every single post in every possible way for these 5 posts:</span><br><span class="line">15 posts @ 15KB + 5 posts @ 200KB = (15*15+5*200) / 20 = 61.25KB</span><br><span class="line">Round up to 65KB</span><br><span class="line"></span><br><span class="line">Saving = ~135KB (-67%)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>이러한 최적화를 결합하면 대역폭을 크게 절약하고 페이지 로드 시간을 단축하여 사용자 경험을 향상시킬 수 있다. 이러한 계산은 계획 수립에 유용하지만 실제 사용 패턴에 따라 달라질 수 있으므로 지속적인 모니터링과 조정을 통해 검증해야 한다는 점을 항상 기억해야 한다.</p>
<h2 id="Storage-amp-data-at-rest"><a href="#Storage-amp-data-at-rest" class="headerlink" title="Storage &amp; data at rest"></a>Storage &amp; data at rest</h2><p>모든 시스템의 아키텍처를 고려할 때는 저장 데이터, 즉 현재 네트워크를 통해 이동하지 않는 데이터의 저장 및 관리를 계획하는 것이 필수적이다. 스토리지 용량, 데이터 수명 주기 관리, 데이터 접근성, 데이터 보안, 비용 등 여러 가지 측면을 고려해야 한다.</p>
<p>스토리지와 관련된 용량 계획에는 시스템에서 생성하거나 관리할 데이터의 양을 예측하고 이를 처리할 수 있는 충분한 스토리지 용량을 확보하는 것이 포함된다.</p>
<p><strong>예제 1 - 온도 센서</strong>와 같이 센서가 지속적으로 온도 데이터를 수집하는 시스템에서는 생성되는 데이터의 양이 엄청나게 많을 수 있다. 각 데이터 포인트의 크기가 약 0.1KB이고 초당 200만 개의 데이터 포인트를 저장한다고 가정하면 하루에 약 17TB의 데이터를 저장해야 한다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2M QPS @ 0.1KB (not storing headers) = 200MB/s</span><br><span class="line">Storage per day = ~17TB</span><br></pre></td></tr></table></figure>
<p>이 정도 규모의 스토리지 요구 사항은 관리하기 어렵고 비용이 많이 들 수 있다. 따라서 스토리지를 최적화하는 방법을 찾는 것이 중요하다. 한 가지 접근 방식은 데이터 중복 제거로, 고유한 데이터 포인트 또는 중요한 변경 사항을 반영하는 데이터 포인트만 저장하는 것이다.</p>
<p><strong>예제 1 - 온도 센서</strong>의 경우 온도 데이터가 기록될 때마다 저장하는 대신 온도에 큰 변화가 있을 때만 데이터를 저장할 수 있다. 이렇게 하면 스토리지 요구 사항을 크게 줄일 수 있다. 예를 들어 온도가 1분에 한 번만 변하는 경우 일일 저장 용량이 약 1.5TB로 줄어든다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sensors send every 5 seconds = 17TB</span><br><span class="line">Sensors send every 60 seconds = 17TB / 12 = ~1.5TB</span><br></pre></td></tr></table></figure>
<p>중복 제거 기능을 사용하더라도 이렇게 많은 양의 데이터를 저장하는 것은 어려울 수 있다. 이 때 데이터 보존 정책과 수명주기 관리가 중요한 역할을 한다. 모든 시스템이 데이터를 무기한 보존해야 하는 것은 아니며, 규정 준수 문제로 인해 보존할 수 없는 경우도 있다. 효과적인 데이터 보존 정책은 시스템 성능을 획기적으로 개선하고 비용을 절감할 수 있다. 일반적인전략에는 데이터 세분화가 포함된다. 예를 들어, 시간 또는 센서 ID 별로 데이터를 집계할 수 있다.</p>
<p>최적화를 위해 지난 달의 원시 이벤트를 유지하고 이보다 오래된 데이터에 대해서는 세분성을 높일 수 있다. 각 시간의 최종 상태와 해당 시간 내에 여러 번 변경된 속성에 대한 계산을 유지한다. 이러한 계산에 0.1KB가 추가로 필요한 경우, 각 시간별 레코드의 비용은 0.2KB이다. 따라서 1년치 데이터는 약 1.8MB의 비용이 들며, 지난 달의 원시 이벤트는 약 45TB(1.5TB * 30일) 에 달한다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Per hour = 0.2KB</span><br><span class="line">Per day = 24h * 0.2KB = ~5KB</span><br><span class="line">Per month = 150KB</span><br><span class="line">Per year = 1.8MB</span><br></pre></td></tr></table></figure>
<h2 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h2><p>캐싱은 오버헤드를 줄이고 인프라 비용과 용량 제한을 완화하는데 도움이 되는 유용한 기술이다. 이 섹션에서는 효과적인 캐싱을 위한 몇 가지 전략에 대해 자세히 설명한다.</p>
<h3 id="Caching-reads"><a href="#Caching-reads" class="headerlink" title="Caching reads"></a>Caching reads</h3><p>콘텐츠의 일부가 전체 읽기의 대부분을 차지하는 경우가 많다. 이러한 경우 캐싱을 통해 대역폭 사용량을 크게 줄일 수 있다. <strong>예제 2 - 소셜 네트워킹 뉴스 피드</strong>에서는 Cloudfront와 같은 콘텐츠 전송 네트워크(CDN)을 사용하여 대부분의 콘텐츠를 캐싱할 수 있다.</p>
<p>캐싱을 사용하면 인프라의 대역폭을 절약할 수 있을 뿐만 아니라 특히 정적 자산의 경우 사용자 경험을 개선하고 비용을 절감할 수 있다. 콘텐츠의 20%가 읽기의 80%를 차지하는 이 예에서, 이 콘텐츠를 캐싱하면 대역폭 소비를 크게 줄일 수 있다.</p>
<h3 id="Caching-to-alleviate-write-bottlenecks"><a href="#Caching-to-alleviate-write-bottlenecks" class="headerlink" title="Caching to alleviate write bottlenecks"></a>Caching to alleviate write bottlenecks</h3><p>캐싱은 쓰기 작업이 많은 시스템에도 유용한 도구다. 캐싱은 필요한 스토리지 용량을 줄이는 데 도움이 된다. <strong>예제 1 - 온도 센서</strong>에서는 센서 / 온도 데이터 쌍을 캐시하고 변경이 발생할 때만 장기 스토리지에 커밋할 수 있다. 또한, 캐시에서 쓰기를 집계하여 특정 획수의 캐시 쓰기 후에만 장기 지속성 계층에 기록할 수 있다. 이 전략은 쓰기 병목 현상을 완화하고 스토리지 요구 사항을 줄이는 데 도움이 될 수 있다.</p>
<h3 id="Effective-cache-management"><a href="#Effective-cache-management" class="headerlink" title="Effective cache management"></a>Effective cache management</h3><p>캐싱은 강력한 도구가 될 수 있지만 예기치 않은 결과를 피하려면 효과적인 관리가 필요하다. 다음은 캐시 사용량을 관리하는 세 가지 전략이다.</p>
<ul>
<li><p>Write-through cache : 이 방법에서는 데이터가 캐시와 해당 데이터베이스에 동시에 기록된다. 캐시는 읽기 캐시 역할을 하며 데이터베이스는 장기 저장 계층으로 기능한다. 캐시 및 데이터베이스 쓰기가 모두 성공해야만 작업이 확인되므로 지연 시간이 증가한다는 단점이 있다.</p>
</li>
<li><p>Write-around cache : 이 전략은 캐시를 우회하여 장기 저장소에 직접 쓰는것을 포함한다. 즉시 액세스되지 않는 쓰기 작업에 대한 캐시 오버헤드를 줄일 수 있지만 단점이 있다. 느린 영속성 계층에서만 데이터를 읽을 수 있으므로 지연 시간이 증가한다.</p>
</li>
<li>Write-back cache : 이 접근 방식에서는 데이터가 캐시에만 쓰여지고 확인이 즉시 클라이언트로 전송된다. 영구 저장소에 대한 쓰기는 10번째 레코드마다 또는 설정된 시간마다 같은 특정 조건에서 이루어진다. 이 방법은 지연 시간이 짧지만 캐시가 플러시되거나 캐시에서 데이터가 손실되는 경우 데이터 손실 위험이 있다는 단점이 있다.</li>
</ul>
<h2 id="Operating-capacity"><a href="#Operating-capacity" class="headerlink" title="Operating capacity"></a>Operating capacity</h2><h3 id="Alerts-amp-monitoring"><a href="#Alerts-amp-monitoring" class="headerlink" title="Alerts &amp; monitoring"></a>Alerts &amp; monitoring</h3><p>잘못된 설계 가정으로 인해 발생할 수 있는 문제를  방지하는 한 가지 방법은 이러한 가정을 프로덕션 환경에서 경고로 코딩하는 것이다. 예를 들어, 설계에서 캐시 적중률을 20%로 가정했는데 실제로는 5%의 적중률만 달성했다면 모니터링을 통해 이러한 불일치를 감지할 수 있다. 모니터링이 이미 시행되고 있을 가능성이 높지만, 이러한 가정을 추적하는 것이 중요하다. 이전에 설정한 이러한 가정을 모니터링하면 다음 인프라 청구서가 도착하거나 사고가 발생할 때까지 기다리지 않고 사전 예방적인 조치를 취할 수 있다.</p>
<h3 id="Staying-vigilance"><a href="#Staying-vigilance" class="headerlink" title="Staying vigilance"></a>Staying vigilance</h3><p>데이터를 사용하여 시스템 부하를 예측하고 이해하기 위해 최선을 다하고 있지만 모든 시나리오를 완벽하게 예측할 수는 없는 것이 현실이다. 예측할 수 없는 시스템과 부하의 특성 때문에 시스템의 견고성과 성능을 유지하기 위해 지속적인 주의가 필요하다.</p>
<p>예를 들어, 시스템을 크게 변경할 때는 잠재적인 위험 요소를 고려하는 것이 필수적이다. 효과적인 전략 중 하나는 철저한 ‘가정’ 분석을 수행하는 것이다. 특정 매개변수가 예기치 않게 변경되면 어떻게 될까? 특정 기능이나 특징에 대한 수요가 갑자기 급증하면 어떤 결과가 초래될까?</p>
<p>또한 시스템 응답성이나 가동 시간 보장과 같은 비기능적 요구사항도 주시하는 것이 유용하다. 이러한 영역의 변경은 시스템 전체에 파급효과를 가져와 병목 현상이나 성능 문제를 일으킬 수 있다.</p>
<p>요컨데, 경계를 늦추지 않는다는 것은 변화와 예상치 못한 시나리오에 대한 시스템의 준비 상태를 지속적으로 질문하고 재평가하는 것을 의미한다. 이러한 지속적인 재평가는 잠재적인 문제가 확대되기 전에 발경하여 시스템의 복우너력을 유지하고 향후 문제를 처리할 수 있는 역량을 확보하는 데 도움이 될 수 있다.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>용량 계획은 효과적인 시스템 설계의 초석이다.</p>
<p>엔지니어는 용량 계획을 통해 리소스의 사용량, 성능, 비용 간의 복잡한 균형을 탐색하여 현재의 요구 사항을 충족할 뿐만 아니라 미래의 요구 사항에도 적응할 수 있는 시스템을 구축할 수 있다. 새로운 시스템을 설계하든 기존 시스템을 최적화하든 용량 계획은 시스템 설계의 근본적인 복잡성에 대한 가시성을 확보하고 정보에 입각한 의사 결정과 사전 예방적 문제 해결을 촉진하는 중요한 프로세스다.</p>
<p>용량 계획으로 미래를 완벽하게 예측할 수는 없지만, 이러한 원칙과 전략을 설계 프로세스에 통합하면 과잉 또는 과소 프로비저닝의 위험을 줄이고 시스템 성능을 개선하며 궁극적으로 보다 탄력적이고 효율적인 시스템을 구축할 수 있다.</p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2023/07/02/System%20Design/ByteByteGo/private/capacity-planning/">https://songhayoung.github.io/2023/07/02/System%20Design/ByteByteGo/private/capacity-planning/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2023 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>