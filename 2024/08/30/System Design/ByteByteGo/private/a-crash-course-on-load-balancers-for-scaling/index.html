<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[ByteByteGo] A Crash Course on Load Balancers for Scaling"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[ByteByteGo] A Crash Course on Load Balancers for Scaling | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-Crash-Course-on-Load-Balancers-for-Scaling"><span class="toc-number">1.</span> <span class="toc-text">A Crash Course on Load Balancers for Scaling</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-the-Need-for-Load-Balancing"><span class="toc-number">2.</span> <span class="toc-text">Why the Need for Load Balancing?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Workload-Distribution"><span class="toc-number">2.1.</span> <span class="toc-text">1 - Workload Distribution</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Redundancy"><span class="toc-number">2.2.</span> <span class="toc-text">2 - Redundancy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Types-of-Load-Balancers"><span class="toc-number">3.</span> <span class="toc-text">Types of Load Balancers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Layer-4-Load-Balancers"><span class="toc-number">3.1.</span> <span class="toc-text">1 - Layer 4 Load Balancers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Advantages-of-Layer-4-Load-Balancers"><span class="toc-number">3.1.1.</span> <span class="toc-text">Advantages of Layer 4 Load Balancers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Disadvantages-of-Layer-4-Load-Balancers"><span class="toc-number">3.1.2.</span> <span class="toc-text">Disadvantages of Layer 4 Load Balancers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Examples-of-Layer-4-Load-Balancers"><span class="toc-number">3.1.3.</span> <span class="toc-text">Examples of Layer 4 Load Balancers</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Layer-7-Load-Balancers"><span class="toc-number">3.2.</span> <span class="toc-text">2 - Layer 7 Load Balancers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Advantages-of-Layer-7-Load-Balancers"><span class="toc-number">3.2.1.</span> <span class="toc-text">Advantages of Layer 7 Load Balancers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Disadvantages-of-Layer-7-Load-Balancers"><span class="toc-number">3.2.2.</span> <span class="toc-text">Disadvantages of Layer 7 Load Balancers</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Examples-of-Layer-7-Load-Balancers"><span class="toc-number">3.3.</span> <span class="toc-text">Examples of Layer 7 Load Balancers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Load-Balancing-Algorithms"><span class="toc-number">4.</span> <span class="toc-text">Load Balancing Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Static-Load-Balancing-Algorithms"><span class="toc-number">4.1.</span> <span class="toc-text">Static Load Balancing Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Round-Robin"><span class="toc-number">4.1.1.</span> <span class="toc-text">1 - Round Robin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Sticky-Round-Robin"><span class="toc-number">4.1.2.</span> <span class="toc-text">2 - Sticky Round Robin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Weighted-Round-Robin"><span class="toc-number">4.1.3.</span> <span class="toc-text">3 - Weighted Round Robin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Hash-Based"><span class="toc-number">4.1.4.</span> <span class="toc-text">4 - Hash-Based</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dynamic-Load-Balancing-Algorithms"><span class="toc-number">4.2.</span> <span class="toc-text">Dynamic Load Balancing Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Least-Connections"><span class="toc-number">4.2.1.</span> <span class="toc-text">1 - Least Connections</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Lowest-Response-Time"><span class="toc-number">4.2.2.</span> <span class="toc-text">2 - Lowest Response Time</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scaling-Load-Balancers"><span class="toc-number">5.</span> <span class="toc-text">Scaling Load Balancers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS-Round-Robin"><span class="toc-number">5.1.</span> <span class="toc-text">DNS Round Robin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Clustered-Configuration-with-HAProxy-or-Nginx"><span class="toc-number">5.2.</span> <span class="toc-text">Clustered Configuration with HAProxy or Nginx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Global-Server-Load-Balancing"><span class="toc-number">5.3.</span> <span class="toc-text">Global Server Load Balancing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Active-Passive-Load-Balancing"><span class="toc-number">5.4.</span> <span class="toc-text">Active-Passive Load Balancing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Elastic-Load-Balancing-with-Cloud"><span class="toc-number">5.5.</span> <span class="toc-text">Elastic Load Balancing with Cloud</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Anycast-Load-Balancing"><span class="toc-number">5.6.</span> <span class="toc-text">Anycast Load Balancing</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/hayoung-song-9523b61bb/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">11049</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">196</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">62</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[ByteByteGo] A Crash Course on Load Balancers for Scaling</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-08-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/Byte-Byte-Go/">Byte Byte Go</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2k</span><span class="post-meta__separator">|</span><span>Reading time: 12 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="A-Crash-Course-on-Load-Balancers-for-Scaling"><a href="#A-Crash-Course-on-Load-Balancers-for-Scaling" class="headerlink" title="A Crash Course on Load Balancers for Scaling"></a>A Crash Course on Load Balancers for Scaling</h2><span id="more"></span>
<p>로드 밸런서는 시스템 아키텍처의 중요한 요소로 자리 잡았으며, 여러 서버에 수신되는 네트워크 트래픽을 분산하는 게이트키퍼 역할을 한다. 이를 통해 시스템 내 데이터 흐름을 관리해 시스템의 수평적 확장성을 보장한다. 또한 워크로드를 여러 서버에 효과적으로 분산하여 사용량이 폭증하는 경우에도 시스템 성능을 유지한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240830091159221.png" alt=""></p>
<p>부하 분산에는 여러 이점이 있다.</p>
<ul>
<li>지연 시간 단축 : 로드 밸런서는 사용자 요청에 대한 응답 시간을 최소화하는 데 도움이 된다. 이런 지연 시간 단축은 더 나은 사용자 경험으로 이루어진다.</li>
<li>다운타임 최소화 : 로드 밸런서는 상태가 좋지 않거나 오프라인 서버에서 트래픽을 감지하고 라우팅할 수 있다.</li>
<li>확장성 : 로드 밸런서는 수평적 확장성의 핵심이다. 트래픽 수요가 증가하면 서버를 추가할 수 있으며, 로드 밸런서는 확장된 인프라에 자동으로 워크로드를 분산한다.</li>
</ul>
<p>이 포스트에서는 로드 밸런서에 대해 자세히 알아보고 로드 밸런서가 필요한 이유, 로드 밸런서의 유형, 로드 밸런서를 구동하는 다양한 알고리즘에 대해 알아보자. 또한 로드 밸런서가 확장 가능하고 단일 장애 지점이 되지 않도록 하기 위한 몇 가지 중요한 기술을 살펴보자.</p>
<h2 id="Why-the-Need-for-Load-Balancing"><a href="#Why-the-Need-for-Load-Balancing" class="headerlink" title="Why the Need for Load Balancing?"></a>Why the Need for Load Balancing?</h2><p>트래픽이 많은 애플리케이션의 영역에서는 최적의 성능과 사용자 만족도를 유지하기 위해 많은 수의 동시 요청을 처리할 수 있는 능력이 매우 중요하다. 단일 시스템에 의존하는 것은 비현실적이고 불충분하다. 이 때 시스템의 확장성의 두 가지 중요한 측면인 워크로드 분산과 이중화가 중요한 역할을 한다.</p>
<h3 id="1-Workload-Distribution"><a href="#1-Workload-Distribution" class="headerlink" title="1 - Workload Distribution"></a>1 - Workload Distribution</h3><p>수천 개의 동시 요청을 처리해야 하는 트래픽이 많은 애플리케이션을 구축할 때 단일 시스템에 의존하는 것은 불가능하다. 시스템이 워크로드 증가를 처리할 수 있도록 하려면 수평적 확장이 필수적이다. 스케일 아웃이라고도 하는 수평적 확장은 시스템에 더 많은 컴퓨터를 추가하여 용량을 늘리는 기술이다. 워크로드를 여러 대의 컴퓨터에 분산함으로써 애플리케이션은 더 많은 수의 요청을 처리하고 최적의 성능을 유지할 수 있다. 로드 밸런서는 이런 워크로드 분산을 촉진하는데 중요한 역할을 한다.</p>
<p>로드 밸런서는 들어오는 요청의 진입점 역할을 하며 다양한 알고리즘과 정책에 따라 사용 가능한 시스템으로 지능적으로 라우팅하여 단일 시스템이 과부하되는 것을 방지한다.</p>
<h3 id="2-Redundancy"><a href="#2-Redundancy" class="headerlink" title="2 - Redundancy"></a>2 - Redundancy</h3><p>가용성은 시스템이 계속 작동하고 사용자가 액세스할 수 있는 능력을 측정하는 중요한 지표다. 고가용성은 이 개념을 훨씬 더 높은 수준으로 끌어올려 거의 연속적인 가동 시간을 목표로 한다. 일반적으로 서버의 가동 시간은 99.999%여야 고가용성으로 간주된다. 이런 높은 수준의 가용성을 달성하려면 인프라 또는 소프트웨어 계층내에서  SPOF를 제거해야 한다. 로드 밸런서는 이중화 및 장애 조치 기능을 제공하여 이 목표에 기여한다.</p>
<p>백엔드 서비스가 요청 처리를 담당하는 시나리오를 생각해보자. 이 서비스의 고가용성을 위해 여러 개의 서비스 인스턴스가 배포된다. 그러나 특정 인스턴스의 상태가 좋지 않아 해당 인스턴스로 요청이 라우팅 될 경우 서비스를 사용할 수 없게 될 수 있다. 로드밸런서는 백엔드 인스턴스의 상태를 지속적으로 모니터링하고 정상 인스턴스로만 요청을 라우팅한다.</p>
<h2 id="Types-of-Load-Balancers"><a href="#Types-of-Load-Balancers" class="headerlink" title="Types of Load Balancers"></a>Types of Load Balancers</h2><h3 id="1-Layer-4-Load-Balancers"><a href="#1-Layer-4-Load-Balancers" class="headerlink" title="1 - Layer 4 Load Balancers"></a>1 - Layer 4 Load Balancers</h3><p>레이어4 로드 밸런서는 OSI 모델의 전송 레이어에서 작동하며 IP 주소 및 포트 번호와 같이 이 레이어에서 사용 가능한 정보만을 기반으로 라우팅 결정을 내린다. 레이어4 로드밸런서의 주요 특징 중 하나는 데이터 패킷의 콘텐츠를 검사하지 않는다는 것이다. 네트워크 수준 정보에 집중하며 패킷이 전달하는 실제 메시지나 페이로드에 대한 가시성이 없다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240830092238704.png" alt=""></p>
<h4 id="Advantages-of-Layer-4-Load-Balancers"><a href="#Advantages-of-Layer-4-Load-Balancers" class="headerlink" title="Advantages of Layer 4 Load Balancers"></a>Advantages of Layer 4 Load Balancers</h4><ul>
<li>단순성 : 레이어4 로드밸런서는 상위 레이어 로드밸런서에 비해 실행 및 유지 관리가 더 간단하다. 전송 계층에서 작동하기 때문에 구성 및 관리 오버헤드가 적다.</li>
<li>성능 향상 : 레이어4 로드밸런서는 데이터 패킷의 콘텐츠를 검사할 필요가 없으므로 더 나은 성능을 얻을 수 있다. 데이터 조회나 심층 패킷 검사를 수행하지 않으므로 라우팅 결정이 빨라지고 지연 시간이 단축된다.</li>
<li>보안 강화 : 레이어4 로드밸런서는 애플리케이션 레이어 아래에서 작동하기 때문에 TLS 데이터를 해독할 필요가 없다. 따라서 암호화된 트래픽의 기밀성을 유지하고 공격 표면을 줄임으로써 보안이 강화된다.</li>
<li>효율적인 연결 처리 : 레이어4 로드밸런서는 일반적으로 클라이언트와 선택한 서버 간에 하나의 TCP 연결만 설정한다. 따라서 여러 연결을 관리하는 오버헤드가 줄어들고 전반적인 효율성이 향상된다.</li>
</ul>
<h4 id="Disadvantages-of-Layer-4-Load-Balancers"><a href="#Disadvantages-of-Layer-4-Load-Balancers" class="headerlink" title="Disadvantages of Layer 4 Load Balancers"></a>Disadvantages of Layer 4 Load Balancers</h4><ul>
<li>영리한 부하 분산 부족 : 레이어4 로드밸런서는 데이터 패킷의 콘텐츠를 기반으로 지능적인 라우팅 결정을 내릴 수 없다. 네트워크 수준 정보에만 의존하기 때문에 항상 최적의 부하 분산이 이루어지지 않을 수 있다.</li>
<li>제한된 라우팅 기능 : 레이어4 로드밸런서는 트래픽을 다른 서비스 유형으로 라우팅하거나 콘텐츠 기반 라우팅을 수행할 수 없다. IP 주소와 포트 번호에 기반한 라우팅으로 제한되기 때문에 복잡한 애플리케이션 아키텍처에 필요한 유연성을 제공하지 못할 수 있다.</li>
<li>캐싱 없음 : 레이어4 로드밸런서는 데이터 패킷의 콘텐츠를 볼 수 없으므로 캐싱을 수행할 수 없다. 로드 밸런서 수준에서 캐싱을 수행하면 자주 요청되는 콘텐츠를 로드 밸런서의 캐시에서 직접 제공함으로써 성능을 크게 향상시킬 수 있다.</li>
</ul>
<h4 id="Examples-of-Layer-4-Load-Balancers"><a href="#Examples-of-Layer-4-Load-Balancers" class="headerlink" title="Examples of Layer 4 Load Balancers"></a>Examples of Layer 4 Load Balancers</h4><ul>
<li>HAProxy : 레이어4 및 레이어7에서 작동할 수 있는 오픈 소스 로드밸런서 및 리버스 프록시</li>
<li>AWS Network Load Balancer : AWS에서 제공하는 확장성이 뛰어난 고성능 로드밸런서</li>
<li>Azure Load Balancer : 가상 머신 간에 트래픽을 분산하기 위해 Microsoft Azure에서 제공하는 레이어4 로드밸런서</li>
</ul>
<h3 id="2-Layer-7-Load-Balancers"><a href="#2-Layer-7-Load-Balancers" class="headerlink" title="2 - Layer 7 Load Balancers"></a>2 - Layer 7 Load Balancers</h3><p>레이어4 로드밸런서와 달리 레이어7 로드밸런서는 OSI 모델의 애플리케이션 레이어에서 작동한다. HTTPS, WebSocket, FTP, SMTP와 같은 레이어7 프로토콜을 처리한다. 레이어4와 레이어7 부하 분산 장치의 주요 차이점은 데이터 패킷의 콘텐츠를 검사하는 기능에 있다. 레이어4 로드밸런서는 네트워크 수준 정보만을 기반으로 라우팅 결정을 내리는 반면, 레이어7 로드밸런서는 패킷 내의 실제 데이터를 검사하고 해당 정보를 기반으로 라우팅 결정을 내릴 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240830092910166.png" alt=""></p>
<p>블로그 게시물(/post)을 처리하는 마이크로서비스와 댓글(/comments)을 관리하는 마이크로서비스가 두 개 있는 시나리오를 생각해보자. 레이어7 로드밸런서가 클라이언트 요청을 처리하는 방식은 다음과 같다.</p>
<ul>
<li>클라이언트가 로드 밸런서와 TCP 연결을 설정하고 /post 경로에 액세스하라는 요청을 보낸다.</li>
<li>로드밸런서는 데이터를 해독하고 구성된 라우팅 규칙을 검사한다.</li>
<li>요청 대상(/post)을 기반으로 로드 밸런서는 Post 서비스를 호스팅하는 서버 인스턴스에 대한 새 TCP 연결을 설정한다.</li>
<li>포스트 서비스 인스턴스로부터 응답이 수신되면 부하 분산 장치는 클라이언트에 응답을 보낸다.</li>
</ul>
<h4 id="Advantages-of-Layer-7-Load-Balancers"><a href="#Advantages-of-Layer-7-Load-Balancers" class="headerlink" title="Advantages of Layer 7 Load Balancers"></a>Advantages of Layer 7 Load Balancers</h4><ul>
<li>더 스마트한 부하 분산 : 레이어7 로드밸런서는 데이터 패킷의 콘텐츠를 기반으로 지능적인 라우팅 결정을 내릴 수 있다. 헤더, URL, 쿠키, 기타 애플리케이션 수준 정보를 검사하여 가장 적합한 서버 인스턴스로 요청을 라우팅할 수 있다. 이를 통해 보다 고급 로드 밸런싱 전략과 최적화된 리소스 활용이 가능하다.</li>
<li>캐싱 기능 : 레이어7 로드 밸런서는 자주 요청되는 콘텐츠를 캐시하여 백엔드 서버의 부하를 줄이고 응답 시간을 개선할 수 있다. 로드 밸런서에서 캐시된 콘텐츠를 직접 제공함으로써 네트워크 지연 시간을 최소화하고 애플리케이션 성능을 향상시킨다.</li>
<li>리버스 프록시 기능 : 레이어7 로드밸런서는 역방향 프록시 역할을 수행하여 SSL 종료, URL 재작성, 요청/응답 수정 등의 추가 기능을 제공할 수 있다. 이를 통해 보안, 성능 최적화, 애플리케이션 아키텍처를 간소화할 수 있다.</li>
</ul>
<h4 id="Disadvantages-of-Layer-7-Load-Balancers"><a href="#Disadvantages-of-Layer-7-Load-Balancers" class="headerlink" title="Disadvantages of Layer 7 Load Balancers"></a>Disadvantages of Layer 7 Load Balancers</h4><ul>
<li>높은 비용 : 레이어7 로드밸런서는 레이어4 로드밸런서에 비해 더 복잡하고 리소스 집약적이다. 애플리케이션 수준 데이터를 검사하고 조작하는데 더 많은 처리 능력과 메모리가 필요하므로 운영 및 유지 관리 비용이 높아질 가능성이 있다.</li>
<li>데이터 암호 해독 : 암호화된 트래픽(HTTPS)의 콘텐츠를 검사하려면 레이어7 로드밸런서가 데이터 패킷을 복호화해야 한다. 로드밸런서가 암호화 키에 액세스해야 하므로 이러한 추가 처리 오버헤드는 성능에 영향을 미치고 보안 고려 사항을 도입할 수 있다.</li>
<li>다중 TCP 연결 : 레이어7 로드밸런서는 일반적으로 클라이언트와 로드밸런서간 연결, 로드밸런서와 백엔드 서버 간 연결 등 두 개의 TCP 연결을 유지한다. 이로 인해 레이어4 로드밸런서에 비해 리소스 사용률이 증가하고 잠재적인 성능 오버헤드가 발생할 수 있다.</li>
</ul>
<p>하지만 몇 년이 지나면서 이런 단점도 무시할 수 있을 정도로 줄어들었고 레이어7 로드밸런서가 훨씬 더 널리 보급되었다는 점도 중요하다. 레이어4 로드밸런서에 대한 강력한 요구 사항이 없는 한 대부분의 경우 레이어7 로드밸런서를 선택하는 것이 훨씬 낫다.</p>
<h3 id="Examples-of-Layer-7-Load-Balancers"><a href="#Examples-of-Layer-7-Load-Balancers" class="headerlink" title="Examples of Layer 7 Load Balancers"></a>Examples of Layer 7 Load Balancers</h3><ul>
<li>HAProxy : 레이어4 및 레이어7에서 작동할 수 있는 오픈 소스 로드밸런서 및 리버스 프록시</li>
<li>Nginx : 널리 사용되는 웹 서버 및 리버스 프록시로 레이어7 로드밸런서로도 작동할 수 있음</li>
<li>AWS Application Load Balancer : 고급 라우팅 기능 및 다른 AWS 서비스와의 통합 제공</li>
<li>Azure 애플리케이션 게이트웨이 : SSL 종료, URL 기반 라우팅, 웹 애플리케이션 방화벽 등의 기능 제공</li>
</ul>
<h2 id="Load-Balancing-Algorithms"><a href="#Load-Balancing-Algorithms" class="headerlink" title="Load Balancing Algorithms"></a>Load Balancing Algorithms</h2><p>부하 분산 요과는 어떤 요청을 어떤 특정 서버로 라우팅할지 결정하는데 사용되는 알고리즘에 따라 크게 달라진다. 부하 분산 알고리즘은 크게 정적 및 동적 두 가지 유형으로 분류할 수 있다.</p>
<h3 id="Static-Load-Balancing-Algorithms"><a href="#Static-Load-Balancing-Algorithms" class="headerlink" title="Static Load Balancing Algorithms"></a>Static Load Balancing Algorithms</h3><p>정적 부하 분산 알고리즘은 미리 정해진 규칙 또는 고정된 구성을 기반으로 서버 간에 트래픽을 분산한다. 이런 알고리즘은 변화하는 서버 워크로드에 적응하지 않으며 요청 분배를 위해 미리 정의된 기준에 의존한다.</p>
<h4 id="1-Round-Robin"><a href="#1-Round-Robin" class="headerlink" title="1 - Round Robin"></a>1 - Round Robin</h4><p>라운드 로빈 알고리즘에서는 요청이 서버 그룹에 순차적으로 분산된다. 각 서버는 주기적으로 들어오는 요청을 처리하는 차례를 갖는다. 주요 가정은 동일한 사용자의 후속 요청이 동일한 서버 인스턴스에 도달한다는 보장이 없기 때문에 서비스가 stateless라는 것이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240830094045052.png" alt=""></p>
<h4 id="2-Sticky-Round-Robin"><a href="#2-Sticky-Round-Robin" class="headerlink" title="2 - Sticky Round Robin"></a>2 - Sticky Round Robin</h4><p>스티키 라운드 로빈은 기본 라운드 로빈 알고리즘을 개선한 것이다. 이 알고리즘은 동일한 사용자의 후속 요청이 동일한 서버 인스턴스로 라우팅 되도록 한다. 이는 세션 선호도를 유지하는 것이 중요한 특정 사용 사례에서 바람직할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240830094143211.png" alt=""></p>
<h4 id="3-Weighted-Round-Robin"><a href="#3-Weighted-Round-Robin" class="headerlink" title="3 - Weighted Round Robin"></a>3 - Weighted Round Robin</h4><p>가중치 라운드 로빈 알고리즘은 각 서버 인스턴스에 특정 가중치 값을 할당한다. 가중치는 특정 서버로 전달되는 트래픽의 비율을 결정한다. 가중치가 높은 서버는 트래픽의 더 많은 부분을 할당받고 가중치가 낮은 서버는 더 적은 부분을 할당받는다. 예를 들어 서버 인스턴스 A에 0.75의 가중치가 할당되고 인스턴스 B에 0.25가 할당되면 서버 A는 인스턴스 B보다 3배 많은 트래픽을 받게 된다. 이 방법은 서버마다 용량 수준이 다르고 이를 기준으로 트래픽을 할당해야 할 때 유용하다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240830094311440.png" alt=""></p>
<h4 id="4-Hash-Based"><a href="#4-Hash-Based" class="headerlink" title="4 - Hash-Based"></a>4 - Hash-Based</h4><p>해시 기반 알고리즘은 소스 및 대상 IP 주소의 조합과 같은 특정 키의 해시 값에 따라 요청을 배포한다. 해시 함수는 요청을 처리할 서버 인스턴스를 결정한다. 이 알고리즘은 동일한 해시 값을 가진 요청이 동일한 서버 인스턴스로 일관되게 라우팅되도록 보장한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240830094408489.png" alt=""></p>
<h3 id="Dynamic-Load-Balancing-Algorithms"><a href="#Dynamic-Load-Balancing-Algorithms" class="headerlink" title="Dynamic Load Balancing Algorithms"></a>Dynamic Load Balancing Algorithms</h3><p>동적 부하 분산 알고리즘은 동적으로 변화하는 실시간 요인을 고려하여 라우팅 결정을 내린다. 이런 알고리즘은 서버의 현재 상태에 적응하고 그에 따라 트래픽을 분산한다.</p>
<h4 id="1-Least-Connections"><a href="#1-Least-Connections" class="headerlink" title="1 - Least Connections"></a>1 - Least Connections</h4><p>최소 연결 알고리즘은 활성 연결 수가 가장 적은 서버 인스턴스에 새 요청을 할당한다. 연결 수는 각 서버의 상대적인 컴퓨팅 용량에 따라 결정된다. 리소스가 더 많은 서버 인스턴스는 리소스가 적은 인스턴스에 비해 더 많은 수의 연결을 지원할 수 있다. 이 알고리즘은 현재 연결 수를 기준으로 서버 간에 부하를 균등하게 분산한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240830094536443.png" alt=""></p>
<h4 id="2-Lowest-Response-Time"><a href="#2-Lowest-Response-Time" class="headerlink" title="2 - Lowest Response Time"></a>2 - Lowest Response Time</h4><p>최단 응답 시간 알고리즘에서는 로드 밸런서가 들어오는 요청을 응답 시간이 가장 짧은 서버에 할당한다. 가장 빠른 응답을 제공할 수 있는 서버로 요청을 라우팅하여 시스템의 전체 응답 시간을 최소화하는 것이 목표다. 이 알고리즘은 응답 시간이 중요한 요소이고 응답 속도가 가장 빠른 서버 인스턴스에서 요청을 처리해야 하는 시나리오에서 특히 유용하다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240830094643728.png" alt=""></p>
<h2 id="Scaling-Load-Balancers"><a href="#Scaling-Load-Balancers" class="headerlink" title="Scaling Load Balancers"></a>Scaling Load Balancers</h2><p>로드 밸런서는 애플리케이션을 확장하는데 도움이 되지만 확장성에 병목 현상이 발생하지 않도록 하는 것이 중요하다.</p>
<h3 id="DNS-Round-Robin"><a href="#DNS-Round-Robin" class="headerlink" title="DNS Round Robin"></a>DNS Round Robin</h3><p>DNS 라운드 로빈은 로드 밸런서를 확장하는 간단한 기술이다. 여러 로드 밸런서가 서로 다른 IP 주소로 구성되지만 동일한 도메인 이름을 공유한다. 클라이언트가 도메인 이름에 대한 DNS 쿼리를 보내면 DNS 서버는 구성된 풀의 IP 주소 중 하나를 사용하여 응답한다.</p>
<p>DNS 서버는 IP 주소를 순환하며 로드 밸런서 전체에 트래픽을 분산한다. 이후의 각 DNS 쿼리는 로테이션의 다음 IP 주소를 수신하여 요청이 균형 있게 분산되도록 한다.</p>
<h3 id="Clustered-Configuration-with-HAProxy-or-Nginx"><a href="#Clustered-Configuration-with-HAProxy-or-Nginx" class="headerlink" title="Clustered Configuration with HAProxy or Nginx"></a>Clustered Configuration with HAProxy or Nginx</h3><p>HAProxy또는 Nginx Plus와 같은 소프트웨어 부하 분산 솔루션은 여러 서버에 트래픽을 분산하기 위한 하드웨어 기반 클러스터링의 대안을 제공한다. 소프트웨어 부하 분산 설정에서는 별도의 서버 또는 가상 머신에 HAProxy 또는 Nginx Plus와 같은 부하 분산 소프트웨어의 여러 인스턴스가 설치된다. 이런 인스턴스는 클러스터 구성에서 함께 작동하여 백엔드 서버 전체에 들어오는 트래픽을 분산한다.</p>
<h3 id="Global-Server-Load-Balancing"><a href="#Global-Server-Load-Balancing" class="headerlink" title="Global Server Load Balancing"></a>Global Server Load Balancing</h3><p>GSLB는 부하 분산 개념을 단일 데이터 센터나 지리적 위치를 넘어 확장하는 기술이다. GSLB 설정에서는 여러 데이터 센터 또는 서버 클러스터가 서로 다른 지리적 위치에 배포된다. 각 데이터 센터는 애플리케이션 및 관련 리소스의 복제본을 호스팅한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240830095022894.png" alt=""></p>
<p>GSLB 시스템은 DNS를 사용하여 클라이언트 요청을 적절한 데이터 센터로 라우팅한다. 클라이언트가 애플리케이션의 도메인 이름에 대한 DNS 쿼리를 보내면 GSLB 시스템은 요청을 처리하는데 가장 적합한 데이터 센터의 IP 주소로 응답한다.</p>
<h3 id="Active-Passive-Load-Balancing"><a href="#Active-Passive-Load-Balancing" class="headerlink" title="Active-Passive Load Balancing"></a>Active-Passive Load Balancing</h3><p>액티브 - 패시브 로드 밸런싱은 간단한 장애 조치 메커니즘을 제공하여 고가용성을 보장하는 배포 전략이다. 액티브 - 패시브 로드 밸런싱 구성에서는 두 개의 로드 밸런서가 이중으로 배포된다. 액티브 로드 밸런서라고 하는 기본 로드 밸런서는 들어오는 트래픽을 백엔드 서버로 능동적으로 분산하는 역할을 담당한다.</p>
<p>패시브 또는 대기 로드 밸런서라고 하는 보조 로드 밸런서는 유휴 상태로 유지되며 트래픽 분산에 적극적으로 참여하지 않는다. 액티브 로드 밸런서의 상태를 지속적으로 모니터링한다. 액티브 로드 밸런서에 장애가 발생하거나 중단되는 경우 패시브 로드 밸런서가 장애를 감지하고 자동으로 트래픽 처리 책임을 넘겨 받는다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240830095237872.png" alt=""></p>
<h3 id="Elastic-Load-Balancing-with-Cloud"><a href="#Elastic-Load-Balancing-with-Cloud" class="headerlink" title="Elastic Load Balancing with Cloud"></a>Elastic Load Balancing with Cloud</h3><p>자동 확장 로드 밸런서는 들어오는 트래픽에 따라 로드 밸런서 인스턴스 수를 자동으로 조정하는 클라우드 제공 업체가 제공하는 강력한 기능이다. 자동 확장 로드 밸런서 설정에서 클라우드 공급 업체는 로드 밸런서의 트래픽 패턴과 리소스 사용률을 지속적으로 모니터링한다. 트래픽이 증가하면 자동 확장 매커니즘이 자동으로 로드 밸런서 인스턴스를 추가로 프로비저닝하여 증가된 부하를 처리한다.</p>
<p>반대로 트래픽이 감소하면 자동 확장 매커니즘은 리소스 사용률과 비용을 최적화하기 위해 초과 로드 밸런서 인스턴스를 제거한다. 일반적인 확장 메트릭에는 CPU 사용률, 요청 속도, 응답 시간 및 네트워크 대역폭이 포함된다.</p>
<h3 id="Anycast-Load-Balancing"><a href="#Anycast-Load-Balancing" class="headerlink" title="Anycast Load Balancing"></a>Anycast Load Balancing</h3><p>애니케스트 로드 밸런싱은 여러 로드 밸런서가 서로 다른 지리적 위치에서 동일한 IP 주소를 공유하는 기술이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240830095448213.png" alt=""></p>
<p>애니케스트 로드 밸런싱 설정에서는 데이터 센터나 지역 등 다양한 위치에 여러 로드 밸런서가 배포된다. 각 로드 밸런서에는 애니캐스트 주소라고 하는 동일한 IP 주소가 할당된다. 클라이언트가 애니캐스트 주소로 요청을 보내면 네트워크 토폴로지 및 라우팅 프로토콜에 따라 가장 가까운 사용 가능한 로드 밸런서로 요청이 라우팅된다. 라우팅 결정은 네트워크 인프라에 의해 이루어지며, 일반적으로 BGP(Border Gateway Protocol)을 사용하여 가장 가까운 로드 밸런서에 대한 최단 경로를 결정한다.</p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2024/08/30/System%20Design/ByteByteGo/private/a-crash-course-on-load-balancers-for-scaling/">https://songhayoung.github.io/2024/08/30/System%20Design/ByteByteGo/private/a-crash-course-on-load-balancers-for-scaling/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2024 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>