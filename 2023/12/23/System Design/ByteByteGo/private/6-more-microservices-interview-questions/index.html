<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[ByteByteGo] 6 More Microservices Interview Questions"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[ByteByteGo] 6 More Microservices Interview Questions | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-More-Microservices-Interview-Questions"><span class="toc-number">1.</span> <span class="toc-text">6 More Microservices Interview Questions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-What-is-API-Gateway"><span class="toc-number">2.</span> <span class="toc-text">1. What is API Gateway?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-What-Are-the-Differences-Between-REST-and-RPC"><span class="toc-number">3.</span> <span class="toc-text">2. What Are the Differences Between REST and RPC?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-What-is-a-Configuration-Manager"><span class="toc-number">4.</span> <span class="toc-text">3. What is a Configuration Manager?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-What-are-Common-Microservices-Fault-Tolerance-Approaches"><span class="toc-number">5.</span> <span class="toc-text">4. What are Common Microservices Fault Tolerance Approaches?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Circuit-breaker"><span class="toc-number">5.1.</span> <span class="toc-text">Circuit breaker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fallback"><span class="toc-number">5.2.</span> <span class="toc-text">Fallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Request-caching"><span class="toc-number">5.3.</span> <span class="toc-text">Request caching</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Request-coalescing"><span class="toc-number">5.4.</span> <span class="toc-text">Request coalescing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bulkhead-isolation"><span class="toc-number">5.5.</span> <span class="toc-text">Bulkhead isolation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Health-monitoring"><span class="toc-number">5.6.</span> <span class="toc-text">Health monitoring</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-How-do-We-Manage-Distributed-Transactions"><span class="toc-number">6.</span> <span class="toc-text">5. How do We Manage Distributed Transactions?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Try-Confirm-Cancel-TCC"><span class="toc-number">6.1.</span> <span class="toc-text">Try-Confirm-Cancel (TCC)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Two-Phase-Commit-2PC"><span class="toc-number">6.2.</span> <span class="toc-text">Two-Phase Commit (2PC)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Saga"><span class="toc-number">6.3.</span> <span class="toc-text">Saga</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-How-do-we-Choose-Between-Monolithic-and-Microservices-Architectures"><span class="toc-number">7.</span> <span class="toc-text">6. How do we Choose Between Monolithic and Microservices Architectures?</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/hayoung-song-9523b61bb/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">9944</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">191</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">59</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[ByteByteGo] 6 More Microservices Interview Questions</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-12-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/Byte-Byte-Go/">Byte Byte Go</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2k</span><span class="post-meta__separator">|</span><span>Reading time: 12 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="6-More-Microservices-Interview-Questions"><a href="#6-More-Microservices-Interview-Questions" class="headerlink" title="6 More Microservices Interview Questions"></a>6 More Microservices Interview Questions</h2><span id="more"></span>
<p>이 포스트에서는 마이크로 서비스 인터뷰 질문에 대해 살펴본다.</p>
<ol>
<li>What is an API Gateway?</li>
<li>What are the differences between REST and RPC?</li>
<li>What is a configuration manager?</li>
<li>What are common microservices fault tolerance approaches?</li>
<li>How do we manage distributed transactions?</li>
<li>How do we choose between monolithic and microservices architectures?</li>
</ol>
<h2 id="1-What-is-API-Gateway"><a href="#1-What-is-API-Gateway" class="headerlink" title="1. What is API Gateway?"></a>1. What is API Gateway?</h2><p>마이크로서비스 아키텍처에서 API 게이트웨이는 클라이언트 요청에 대한 단일 진입점 역할을 한다. API 게이트웨이는 요청 라우팅, 프로토콜 변환 등을 담당하며 인증, 권한 부여, 캐싱, 속도 제한 등의 기능을 제공한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231223174026166.png" alt=""></p>
<ul>
<li>Step 1 : 클라이언트가 API 게이트웨이에 HTTP 요청을 보낸다.</li>
<li>Step 2 : API 게이트웨이가 HTTP 요청의 값을 파싱하고 유효성을 검사한다.</li>
<li>Step 3 : API 게이트웨이가 allow / deny 목록을 확인한다.</li>
<li>Step 4 : API 게이트웨이가 ID 프로바이더를 통해 인증 및 권한을 부여한다.</li>
<li>Step 5 : Rate limiting 규칙이 적용된다. 한도를 넘어서는 요청은 거부된다.</li>
<li>Step 6 and 7 : API 게이트웨이가 경로 매칭을 통해 요청을 관련 백엔드 서비스로 라우팅한다.</li>
<li>Step 8 : API 게이트웨이가 요청을 적절한 프로토콜로 변환해 백엔드 마이크로서비스로 전달한다.</li>
<li>Step 9 : API 게이트웨이는 요청을 처리하는 동안 발생할 수 있는 오류를 처리해 서비스를 점진적으로 저하시킨다.</li>
<li>Step 10 : API 게이트웨이는 서킷 브레이커와 같은 복원력 패턴을 구현해 장애를 감지하고 상호 연결된 서비스의 과부하를 방지하여 연쇄적인 장애를 방지한다.</li>
<li>Step 11 : API 게이트웨이는 로깅, 모니터링, 추적, 디버깅을 위해 ELK 스택과 같은 통합 시각화 도구를 활용한다.</li>
<li>Step 12 : API 게이트웨이는 응답성을 개선하기 위해 선택적으로 일반적인 요청에 대한 응답을 캐시할 수 있다.</li>
</ul>
<p>API 게이트웨이는 요청 라우팅 외에도 마이크로서비스의 응답을 클라이언트를 위한 단일 응답으로 집계할 수도 있다. API 게이트웨이는 로드 밸런서와는 다르다. 둘 다 네트워크 트래픽을 처리하지만, API 게이트웨이는 애플리케이션 레이어에서 작동하며 주로 HTTP 요청을 처리하고, 로드 밸런서는 주로 전송 레이어에서 작동하며 TCP / UDP 프로토콜을 처리한다. API 게이트웨이는 요청 페이로드를 확인하면서 더 많은 기능을 제공한다.</p>
<p>기존 로드밸런서가 애플리케이션 데이터를 보지 않고 전송 레이어에서 작동해 TCP / UDP 연결을 처리하는 반면, API 게이트웨이는 일반적으로 애플리케이션 레이어에서 작동하여 HTTP 요청을 처리하고 메세지 페이로드를 이해한다는 점에서 로드밸런서와 차이가 있다.</p>
<p>하지만 이 두 가지 유형의 인프라 사이에는 경계가 모호할 수 있다. 일부 고급 로드밸런서는 API 게이트웨이와 유사한 애플리케이션 레이어 시각화 및 라우팅 기능을 제공한다. 그러나 일반적으로 API 게이트웨이는 페이로드에 기반한 보안, 라우팅, 설정, 복원력과 같은 애플리케이션 수준 문제에 초점을 맞추는 반면, 기존 로드 밸런서는 주로 IP 및 포트 번호와 같은 전송 수준 메타데이터를 기반으로 요청을 백엔드 서버에 매핑한다.</p>
<p>각기 다른 클라이언트와 사용자 경험 요구사항에 맞게 조정된 별도의 API 게이트웨이가 있는 경우가 많다. 아래 다이어그램은 일반적인 아키텍처를 보여준다. 모바일 기기와 웹 애플리케이션의 요청을 처리하는 API 게이트웨이는 각각 사용자 경험에 대한 고유한 요구사항이 있기 때문에 서로 다르다. 또한 HTTP 게이트웨이와 비교해 연결 지속성 및 속도 제한 요구 사항이 다르기 떄문에 웹소켓 API 게이트웨이를 분리한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231223174847764.png" alt=""></p>
<p>최근 API 게이트웨이 트랜드</p>
<ul>
<li>GraphQL 지원 : GraphQL은 API를 위한 타입 시스템이자 쿼리 언어다. 현재 많은 API 게이트웨이가 GraphQL과의 통합을 제공한다.</li>
<li>서비스 메시 통합 : Istio 및 Linkerd와 같은 서비스 메시는 마이크로서비스 간의 통신을 처리하는데 사용된다. API 게이트웨이는 트래픽 관리 기능을 향상시키기 위해 이들과 통합하고 있다.</li>
<li>AI 통합 : API 게이트웨이는 AI 기능과 통합되어 더 스마트한 요청 라우팅이나 트래픽 패턴의 이상 징후 탐지가 가능하다.</li>
</ul>
<h2 id="2-What-Are-the-Differences-Between-REST-and-RPC"><a href="#2-What-Are-the-Differences-Between-REST-and-RPC" class="headerlink" title="2. What Are the Differences Between REST and RPC?"></a>2. What Are the Differences Between REST and RPC?</h2><p>REST(Representational State Transfer)와 RPC(Remote Procedure Call)는 분산 시스템에서 통신에 사용되는 두 가지 일반적인 아키텍처 패턴이다. REST는 주로 클라이언트 - 서버 통신에서 사용되며 RPC는 서버 - 서버 통신에 사용된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231223175133848.png" alt=""></p>
<ol>
<li>REST는 GET, POST, PUT, DELETE와 같은 표준 HTTP 메서드를 기반으로 한다. RPC는 HTTP/2와 같은 더 빠른 프로토콜을 기반으로 한다.</li>
<li>REST는 일반적으로 리소스와 그 상태를 표현하기 위해 JSON 또는 XML 과 같은 표준 데이터 형식을 사용한다. RPC의 데이터 형식은 표준 JSON 또는 XML을 기반으로 하거나 ProtoBuf와 같은 독점 형식을 기반으로 할 수 있다.</li>
<li>REST에서 리소스는 URI로 식별되는 반면, RPC에서는 데이터가 일반적으로 명령이나 작업을 나타내는데 사용된다.</li>
<li>RPC는 마이크로서비스 통신에 사용되며 더 높은 성능을 위해 최적화되어 있다. 예를 들어 페이로드는 인코딩되며 압축된다. 반면 REST는 클라이언트 - 서버 통신에 사용되는 표준 HTTP 프로토콜을 기반으로 한다.</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231223175401766.png" alt=""></p>
<h2 id="3-What-is-a-Configuration-Manager"><a href="#3-What-is-a-Configuration-Manager" class="headerlink" title="3. What is a Configuration Manager?"></a>3. What is a Configuration Manager?</h2><p>마이크로서비스 아키텍처에서 각 서비스는 데이터베이스 연결, 서비스 포트, 로깅 레벨과 같은 측면에 대한 설정을 유지 관리해야 한다. 서비스 및 구성의 수는 방대할 수 있다. 수백 개에 달하는 서비스에 걸친 이런 수많은 구성은 구성 관리자를 통해 중앙 집중화되고 유지 관리된다. 또한 환경마다 구성이 달라져야 하는 경우가 많다. 구성 관리자를 사용하면 서비스별로 구성을 처리할 때보다 환경 전반에 걸쳐 이런 광범위한 구성을 간편하게 관리할 수 있다.</p>
<p>구성 관리자의 주요 책임은 다음과 같다.</p>
<ul>
<li>각 서비스가 스토어에서 구성을 검색할 수 있도록 중앙 집중식 구성 관리. 이렇게 하면 구성 변경을 위해 새 서비스 버전을 릴리스할 필요가 없다. 분산 KV Store에 의존하는 것이 일반적인 구현 방식이다.</li>
<li>런타임 구성 업데이트를 통해 서비스를 다시 시작하거나 다시 배포하지 않고도 업데이트된 구성을 다시 로드할 수 있다. 이를 통해 구성 변경사항을 지속적으로 제공할 수 있다.</li>
<li>소스 코드 버전 관리 시스템에 필적하는 구성 버전 관리 및 이력 추적. 코드 변경 사항을 관련 구성에 연결하여 필요할 때 관련 코드와 함께 구성을 롤백할 수 있다.</li>
<li>구성, 특히 중요한 자격 증명이나 설정에 대한 액세스 제어. 역할 기반 가시성 규칙을 통해 적절한 팀만 마이크로서비스와 관련된 구성을 보거나 수정할 수 있다. 예를 들어 SRE 팀만 프로덕션 구성을 보거나 결제 팀만 결제 채널 주소를 수정할 수 있도록 허용할 수 있다.</li>
<li>환경별 구성은 테스트, QA 및 스테이징 구성을 프로덕션과 구분하는 환경별 구성이다. 구성을 배포할 때 코드 배포 파이프라인과 유사한 워크플로를 활용할 수 있다.</li>
<li>멀티테넌시 지원. 여러 클라이언트 또는 고객이 각자의 선호도를 반영하는 별도의 구성이 필요한 멀티테넌트 시나리오에서 사용자 지정 구성 파티셔닝을 지원한다. 예를 들어, 판매자는 이커머스 플랫폼에서 서로 다른 선호도를 가지고 있다. 구성 격리는 클라이언트간 충돌을 방지한다.</li>
</ul>
<p>구성 관리자 자체의 가용성이 높아야 한다. 구성 저장소에 다운타임이 발생하거나 클라이언트 서비스에 응답할 수 없는 경우 해당 서비스가 시작되지 않거나 제대로 작동하지 않는다. 이는 광범위한 시스템 중단으로 이어질 수 있다. 이를 완화하기 위해 구성 관리자는 종종 클러스터링을 활용해 노드 간 복제 및 중복성을 통해 복원력을 높인다.</p>
<p>인기 있는 오픈 소스 구성 관리자로는  HashiCorp Consul, etcd, Apache ZooKeeper 등이 있다. Spring Cloud Config Server와 같은 관리형 클라우드 솔루션도 존재한다.</p>
<p>구성 관리자는 컨테이너 오케스트레이터와 같은 인프라와도 통합된다. 예를 들어 k8s는 etcd를 서비스 검색 및 k8s 구성 요소간의 조정을 위한 백엔드 데이터베이스로 사용한다. 따라서 etcd는 중앙 집중식 구성 관리와 기본 쿠버네티스 클러스터 관리를 모두 지원한다. 이는 구성 관리자가 최신 환경에서 구성 저장소와 오케스트레이터 통합이라는 여러 가지 주요 역할을 수행하는 방법을 보여준다.</p>
<h2 id="4-What-are-Common-Microservices-Fault-Tolerance-Approaches"><a href="#4-What-are-Common-Microservices-Fault-Tolerance-Approaches" class="headerlink" title="4. What are Common Microservices Fault Tolerance Approaches?"></a>4. What are Common Microservices Fault Tolerance Approaches?</h2><p>마이크로서비스 아키텍처를 설계할 때 내결함성을 구축하는 것은 매우 중요하다. 넷플릭스는 마이크로서비스에 지연 시간 및 내결함성을 제공하기 위해 Hystrix라는 라이브러리를 만들었다. 이 라이브러리는 새로운 도구가 등장하더라도 여전히 관련성이 있는 몇 가지 일반적인 복원력 패턴을 구현한다.</p>
<p>Hystrix는 강력한 마이크로서비스를 만드는데 유용한 회로 차단기 및 fallback 같은 패턴을 개척했다. 현재 Netflix는 보다 최신의 복원력 라이브러리로 Resilience4j를 권장하지만, Hystrix에서 사용된 핵심 접근 방식은 여전히 적용된다. 이러한 핵심 기술 몇 가지를 간략히 살펴본다.</p>
<h3 id="Circuit-breaker"><a href="#Circuit-breaker" class="headerlink" title="Circuit breaker"></a>Circuit breaker</h3><p>서킷 브레이커 패턴은 서비스에 대한 요청을 모니터링한다. 실패율이 임계값을 초과하면 회로가 trips되어 실패할 가능성이 있는 요청의 전송을 중지한다. 이렇게 하면 상호 연결된 서비스에서 연쇄적인 장애가 발생하는 것을 방지할 수 있다.</p>
<h3 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h3><p>폴백은 서비스 호출이 실패하거나 시간이 초과된 경우 기본 또는 다운그레이드된 응답을 제공한다. 이를 통해 서비스 중단 시 보다 원활한 사용자 경험을 제공한다.</p>
<h3 id="Request-caching"><a href="#Request-caching" class="headerlink" title="Request caching"></a>Request caching</h3><p>반복 요청의 결과를 캐싱하면 동일한 데이터에 대한 기본 서비스에 대해 중복 호출이 줄어든다.</p>
<h3 id="Request-coalescing"><a href="#Request-coalescing" class="headerlink" title="Request coalescing"></a>Request coalescing</h3><p>동일한 데이터에 대한 여러 개의 동시 요청을 일괄 처리로 결합한다. 이렇게 하면 동일한 리소스에 대한 중복된 동시 호출을 방지할 수 있다. 대신 요청이 그룹화되어 하나의 통합된 배치로 전송된다. 이렇게 하면 다운스트림 서비스의 부하가 줄어든다.</p>
<h3 id="Bulkhead-isolation"><a href="#Bulkhead-isolation" class="headerlink" title="Bulkhead isolation"></a>Bulkhead isolation</h3><p>벌크헤드 격리는 리소스 사용 제한을 설정해 장애가 구성 요소와 서비스 간에 연쇄적으로 발생하는 것을 방지한다. 예를 들어, 최대 동시 실행 제한으로 스레드 풀을 구성하여 격리 경계를 만들 수 있다. 하나의 컴포넌트나 서비스가 장애를 일으키거나 리소스를 너무 많이 사용하기 시작하면 격리 경계는 장애와 리소스 고갈이 시스템 전체로 확산되지 않고 해당 경계 내에서 격리되도록 한다. 따라서 전체 시스템 중단을 방지할 수 있다.</p>
<h3 id="Health-monitoring"><a href="#Health-monitoring" class="headerlink" title="Health monitoring"></a>Health monitoring</h3><p>상태 메트릭을 추적하면 서킷 브레이커 임계값, 벌크 헤드 크기 및 기타 복원력 매개변수에 대한 의사 결정을 내릴 수 있다.</p>
<h2 id="5-How-do-We-Manage-Distributed-Transactions"><a href="#5-How-do-We-Manage-Distributed-Transactions" class="headerlink" title="5. How do We Manage Distributed Transactions?"></a>5. How do We Manage Distributed Transactions?</h2><p>트랜잭션은 컴퓨팅 시스템 내에서 분할할 수 없는 단일 원자 단위로 실행되는 일련의 작업으로 구성된 작업 단위다. 트랜잭션에는 ACID 속성이 있다.</p>
<ul>
<li>Atomicity - 일련의 작업이 전체적으로 수행되거나 전혀 수행되지 않는다.</li>
<li>Consistency - 데이터베이스는 트랜잭션 이후에도 일관된 상태로 유지된다.</li>
<li>Isolation - 동시 진행 중인 트랜잭션이 서로 격리된다.</li>
<li>Durability - 트랜잭션이 커밋된 후에도, 시스템 장애가 발생한 후에도 데이터가 지속된다.</li>
</ul>
<p>데이터베이스가 분산되어 방대한 양의 데이터를 처리하기 때문에 트랜잭션은 “분산” 된다. 분산 트랜잭션은 ACID 속성을 따르는 것을 목표로 하지만, 이를 달성하려면 중앙 집중식 데이터베이스의 트랜잭션에 비해 추가적인 문제가 발생한다. 각 속성을 살펴보자.</p>
<ul>
<li><p>Atomicity</p>
<ul>
<li>분산 트랜잭션은 여러 리소스에 걸쳐있을 수 있다. 어느 한 부분에 장애가 발생하면 모든 리소스를 롤백해야 하므로 조율하기가 복잡하다. 이 시나리오에서는 2PC와 같은 보다 완화된 프로토콜을 사용할 수 있다.</li>
</ul>
</li>
<li><p>Consistency</p>
<ul>
<li>분산 환경에서 이 속성은 여러 리소스가 서로 일관된 상태를 유지해야 함을 의미한다. 한 리소스에 장애가 발생하거나 데이터가 손실되면 전체 시스템 상태가 일관되지 않게 된다. 이 문제를 해결하기 위해 “최종 일관성”이라는 절충안을 적용하는 경우가 많다. 이 개념은 일부 데이터가 노드 간에 일시적으로 일관되지 않더라도 시간이 지나면 노드가 결국 일관된 상태로 수렴한다는 것이다. 따라서 가용성과 파티션 허용 오차를 개선하기 위해 단기간의 불일치를 허용하여 시스템 전체가 궁극적으로 일관성에 도달할 수 있도록 절대적인 일관성 보장을 완화한다.</li>
</ul>
</li>
<li><p>Isolation</p>
<ul>
<li>노드 간 동시 트랜잭션은 리소스 충돌을 일으킬 수 있다. 이는 분산 환경에서는 어려운 문제다. 낙관적 잠금 또는 스냅샷 격리를 사용하면 격리를 달성하는데 도움이 될 수 있다.</li>
</ul>
</li>
<li><p>Durability</p>
<ul>
<li>일부 노드에 장애가 발생하더라도 데이터를 재구성할 수 있을 만큼 충분히 분산된 노드에 데이터가 지속되어야 한다. 이는 일관성과도 연결되는데, 영구 데이터도 일관성을 유지해야 한다. 일반적으로 데이터는 중복성을 위해 여러 노드에 복제된다. 그런 다음 Raft나 Paxos와 같은 합의 알고리즘을 통해 장애 발생 후 복제본이 일관성을 읽을 경우를 대비해 노드 간에 데이터의 올바른 “골든 카피”에 대한 합의를 도출할 수 있다.</li>
</ul>
<p>아래 다이어그램은 한 가지 예를 보여준다. 밥이 앨리스에게 10달러를 송금하고 싶다고 가정해보자. 두 사람의 계정은 서로 다른 데이터베이스에 있으므로 단일 데이터베이스 트랜잭션으로 밥의 계정에서 차감하고 앨리스의 계정을 원자 단위로 늘릴 수는 없다. 앞서 설명한 요구 사항을 충족하기 위해 두 작업을 조정해야 한다.</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231223183533152.png" alt=""></p>
<p>분산 트랜잭션 관리는 복잡하다. 몇 가지 프레임워크와 패턴이 이 문제를 해결하는데 도움이 된다.</p>
<h3 id="Try-Confirm-Cancel-TCC"><a href="#Try-Confirm-Cancel-TCC" class="headerlink" title="Try-Confirm-Cancel (TCC)"></a>Try-Confirm-Cancel (TCC)</h3><p>TCC는 분산 트랜잭션 패턴이다. 각 트랜잭션을 시도, 확인, 취소 단계로 나눈다. 시도 단계에서는 로컬 트랜잭션을 실행하려고 시도한다. 확인 단계에서는 트랜잭션을 커밋한다. 시도 또는 확인 단계가 실패하면 취소 단계에서 트랜잭션을 롤백한다. TCC는 중앙 코디네이터에 의존하지 않고 일관성을 보장한다.</p>
<h3 id="Two-Phase-Commit-2PC"><a href="#Two-Phase-Commit-2PC" class="headerlink" title="Two-Phase Commit (2PC)"></a>Two-Phase Commit (2PC)</h3><p>2PC는 분산 트랜잭션의 원자성과 일관성을 보장하는 프로토콜이다. 모든 참여자가 변경 내용을 커밋하거나 모두 초기 상태로 롤백한다. 준비와 커밋의 두 단계로 구성된다.</p>
<p>준비 단계에서는 중앙 코디네이터(트랜잭션 매니저)가 각 참가자에게 트랜잭션 준비를 요청하는 요청을 보낸다. 참여자는 커밋 또는 중단 투표로 응답한다.</p>
<p>커밋 단계에서 모든 참가자가 커밋에 투표한 경우, 코디네이터는 변경 사항을 영구적으로 적용하라는 “커밋” 메세지를 보낸다. 중단에 투표한 사람이 있거나 실패가 발생하면 코디네이터는 “롤백” 메세지를 보내 모든 노드를 준비 단계의 트랜잭션 이전 상태로 되돌린다.</p>
<h3 id="Saga"><a href="#Saga" class="headerlink" title="Saga"></a>Saga</h3><p>사가 패턴은 중앙 코디네이터 없이 분산 트랜잭션을 처리한다. 대신, 장기 실행 트랜잭션을 일련의 작은 독립 트랜잭션(saga)으로 분해한다. 각 사가는 자체 로컬 커밋 및 롤백 로직을 관리한다. 이를 통해 보다 유연하고 확장 가능한 분산 트랜잭션 처리가 가능하다.</p>
<p>사가 패턴은 중앙 코디네이터 없이 분산 트랜잭션을 처리한다. 대신, 장기 실행 트랜잭션을 사가라고 하는 일련의 작은 독립 트랜잭션으로 분해한다.</p>
<p>각 사가는 자체 트랜잭션 경계를 관리하며 독립적으로 완료될 수 있다. 사가가 실패하면 이전 변경 사항을 상쇄하는 보상 트랜잭션을 트리거하여 보상함으로써 시스템의 일관성을 유지한다.</p>
<p>예를 들어 밥에서 엘리스에게 10달러를 이체하는 경우 이런 사가가 포함될 수 있다.</p>
<ol>
<li>밥의 계좌에서 10달러 인출 - 밥의 계좌에 10달러를 다시 입금해 보상한다.</li>
<li>앨리스의 계좌에 10달러 입금 - 앨리스의 계좌에서 10달러를 인출해 보상한다.</li>
</ol>
<p>각 사가는 자체 거래 한도를 관리한다. 입금이 실패하면 deposit 사가는 실수로 입금된 금액을 인출해 보상을 받는다. 이렇게 하면 시스템이 일관성을 유지한다.</p>
<p>사가 패턴의 가장 큰 장점은 탈중앙화다. 중앙 코디네이터가 필요하지 않으므로 유연하고 확장 가능한 분산 트랜잭션이 가능하다. 참여자는 글로벌 코디네이터가 아닌 사가의 전임자 및 후임자와만 협력하면 된다.</p>
<p>단, 사가는 가용성을 위해 원자성을 희생한다는 단점이 있다. 결국 변경 사항은 완벽하게 조율되기 보다는 일관성을 유지하게 된다.</p>
<h2 id="6-How-do-we-Choose-Between-Monolithic-and-Microservices-Architectures"><a href="#6-How-do-we-Choose-Between-Monolithic-and-Microservices-Architectures" class="headerlink" title="6. How do we Choose Between Monolithic and Microservices Architectures?"></a>6. How do we Choose Between Monolithic and Microservices Architectures?</h2><p>모놀리식 아키텍처와 마이크로서비스 아키텍처 사이의 선택이 항상 간단한 것은 아니다. 각 접근 방식에는 장단점이 있으며, 소프트웨어 시스템과 개발 팀의 특정 요구 사항과 상황에 따라 신중하게 검토해야 한다.</p>
<p>아래 마틴 파울러의 다이어그램에서 볼 수 있듯이, 일반적으로 비즈니스 요구사항이 단순하고 소프트웨어 시스템이 아직 복잡하지 않으며 개발팀의 규모가 비교적 작을 때는 모놀리식 아키텍처로 시작하는 것이 좋다. 시간이 지남에 따라 복잡성이 증가하면 모놀리식 시스템은 유지 관리 및 확장이 더 어려워진다. 이런 변곡점에서 마이크로서비스 아키텍처로 전환하면 모듈성, 확장성, 기술 유연성을 개선할 수 있다. 또한 마이크로서비스 접근 방식은 여러 도메인에서 작업하는 대규모 엔지니어링 팀에게 더 빠른 기능 속도를 제공한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20231223184434823.png" alt=""></p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2023/12/23/System%20Design/ByteByteGo/private/6-more-microservices-interview-questions/">https://songhayoung.github.io/2023/12/23/System%20Design/ByteByteGo/private/6-more-microservices-interview-questions/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2024 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>