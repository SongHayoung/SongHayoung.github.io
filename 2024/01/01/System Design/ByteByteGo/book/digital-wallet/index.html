<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[System Design] Digital Wallet"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[System Design] Digital Wallet | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Digital-Wallet"><span class="toc-number">1.</span> <span class="toc-text">Digital Wallet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-1-Understand-the-Problem-and-Establish-Design-Scope"><span class="toc-number">2.</span> <span class="toc-text">Step 1 - Understand the Problem and Establish Design Scope</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Functional-Requirements"><span class="toc-number">2.1.</span> <span class="toc-text">Functional Requirements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Back-of-the-envelope-estimation"><span class="toc-number">2.2.</span> <span class="toc-text">Back-of-the-envelope estimation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-2-Propose-High-Level-Design-and-Get-Buy-In"><span class="toc-number">3.</span> <span class="toc-text">Step 2 - Propose High-Level Design and Get Buy-In</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API-Design"><span class="toc-number">3.1.</span> <span class="toc-text">API Design</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#In-memory-sharding-solution"><span class="toc-number">3.2.</span> <span class="toc-text">In-memory sharding solution</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Distributed-transactions"><span class="toc-number">3.3.</span> <span class="toc-text">Distributed transactions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Database-sharding"><span class="toc-number">3.3.1.</span> <span class="toc-text">Database sharding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Distributed-transaction-two-phase-commit"><span class="toc-number">3.3.2.</span> <span class="toc-text">Distributed transaction: two-phase commit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Distributed-transaction-Try-Confirm-Cancel-TC-C"><span class="toc-number">3.3.3.</span> <span class="toc-text">Distributed transaction: Try-Confirm&#x2F;Cancel (TC&#x2F;C)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Distributed-transaction-Saga"><span class="toc-number">3.3.4.</span> <span class="toc-text">Distributed transaction: Saga</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event-sourcing"><span class="toc-number">3.4.</span> <span class="toc-text">Event sourcing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Background"><span class="toc-number">3.4.1.</span> <span class="toc-text">Background</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Definition"><span class="toc-number">3.4.2.</span> <span class="toc-text">Definition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Wallet-service-example"><span class="toc-number">3.4.3.</span> <span class="toc-text">Wallet service example</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reproducibility"><span class="toc-number">3.4.4.</span> <span class="toc-text">Reproducibility</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Command-query-responsibility-segregation-CQRS"><span class="toc-number">3.4.5.</span> <span class="toc-text">Command-query responsibility segregation (CQRS)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-3-Design-Deep-Dive"><span class="toc-number">4.</span> <span class="toc-text">Step 3 - Design Deep Dive</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#High-performance-event-sourcing"><span class="toc-number">4.1.</span> <span class="toc-text">High-performance event sourcing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#File-based-command-and-event-list"><span class="toc-number">4.1.1.</span> <span class="toc-text">File-based command and event list</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#File-based-state"><span class="toc-number">4.1.2.</span> <span class="toc-text">File-based state</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Snapshot"><span class="toc-number">4.1.3.</span> <span class="toc-text">Snapshot</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reliable-high-performance-event-sourcing"><span class="toc-number">4.2.</span> <span class="toc-text">Reliable high-performance event sourcing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Reliability-analysis"><span class="toc-number">4.2.1.</span> <span class="toc-text">Reliability analysis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Consensus"><span class="toc-number">4.2.2.</span> <span class="toc-text">Consensus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reliable-solution"><span class="toc-number">4.2.3.</span> <span class="toc-text">Reliable solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Distributed-event-sourcing"><span class="toc-number">4.3.</span> <span class="toc-text">Distributed event sourcing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pull-vs-push"><span class="toc-number">4.3.1.</span> <span class="toc-text">Pull vs push</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Distributed-transaction"><span class="toc-number">4.3.2.</span> <span class="toc-text">Distributed transaction</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-4-Wrap-Up"><span class="toc-number">5.</span> <span class="toc-text">Step 4 - Wrap Up</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-Summary"><span class="toc-number">6.</span> <span class="toc-text">Chapter Summary</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/hayoung-song-9523b61bb/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">10938</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">195</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">62</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[System Design] Digital Wallet</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-01-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/System-Design-Interview/">System Design Interview</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">5.4k</span><span class="post-meta__separator">|</span><span>Reading time: 34 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Digital-Wallet"><a href="#Digital-Wallet" class="headerlink" title="Digital Wallet"></a>Digital Wallet</h2><span id="more"></span>
<p>결제 플랫폼은 일반적으로 고객에게 디지털 지갑 서비스를 제공해 고객이 지갑에 돈을 저장하고 나중에 사용할 수 있도록 한다. 예를 들어, 은행 카드에서 디지털 지갑에 돈을 추가하고 온라인에서 제품을 구매할 때 지갑에 있는 돈으로 결제할 수 있는 옵션이 제공된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101215221491.png" alt=""></p>
<p>디지털 지갑이 제공하는 기능은 돈을 쓰는 것만이 아니다. PayPal과 같은 결제 플랫폼의 경우, 같은 결제 플랫폼에 있는 다른 사람의 지갑으로 직접 돈을 이체할 수도 있다. 은행 간 이체에 비해 디지털 지갑 간 직접 이체는 더 빠르며, 가장 중요한 것은 일반적으로 추가 수수료가 부과되지 않는다는 점이다. 아래는 지갑 간 잔액 이체 작업을 보여준다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101215317954.png" alt=""></p>
<p>지갑 간 잔액 이체 작업을 지원하는 디지털 지갑 애플리케이션의 설계를 살펴보자.</p>
<h2 id="Step-1-Understand-the-Problem-and-Establish-Design-Scope"><a href="#Step-1-Understand-the-Problem-and-Establish-Design-Scope" class="headerlink" title="Step 1 - Understand the Problem and Establish Design Scope"></a>Step 1 - Understand the Problem and Establish Design Scope</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Candidate: Should we only focus on balance transfer operations between two digital wallets? Do we need to worry about other features?</span><br><span class="line">Interviewer: Let’s focus on balance transfer operations only.</span><br><span class="line"></span><br><span class="line">Candidate: How many transactions per second (TPS) does the system need to support?</span><br><span class="line">Interviewer: Let’s assume 1,000,000 TPS.</span><br><span class="line"></span><br><span class="line">Candidate: A digital wallet has strict requirements for correctness. Can we assume transactional guarantees are sufficient?</span><br><span class="line">Interviewer: That sounds good.</span><br><span class="line"></span><br><span class="line">Candidate: Do we need to prove correctness?</span><br><span class="line">Interviewer: This is a good question. Correctness is usually only verifiable after a transaction is complete. One way to verify is to compare our internal records with statements from banks. The limitation of reconciliation is that it only shows discrepancies and cannot tell how a difference was generated. Therefore, we would like to design a system with reproducibility, meaning we could always reconstruct historical balance by replaying the data from the very beginning.</span><br><span class="line"></span><br><span class="line">Candidate: Can we assume the availability requirement is 99.99%</span><br><span class="line">Interviewer: Sounds good.</span><br><span class="line"></span><br><span class="line">Candidate: Do we need to take foreign exchange into consideration?</span><br><span class="line">Interviewer: No, it’s out of scope.</span><br></pre></td></tr></table></figure>
<h3 id="Functional-Requirements"><a href="#Functional-Requirements" class="headerlink" title="Functional Requirements"></a>Functional Requirements</h3><ul>
<li>두 디지털 지갑 간의 잔액 이체 작업 지원</li>
<li>1,000,000 TPS 지원</li>
<li>99.99% 이상의 안정성</li>
<li>트랜잭션 지원</li>
<li>재현성 지원</li>
</ul>
<h3 id="Back-of-the-envelope-estimation"><a href="#Back-of-the-envelope-estimation" class="headerlink" title="Back-of-the-envelope estimation"></a>Back-of-the-envelope estimation</h3><p>TPS에 대해 이야기할 때 트랜잭션 데이터베이스가 사용된다는 것을 의미한다. 오늘날 일반적인 데이터센터 노드에서 실행되는 관계형 데이터베이스는 초당 수천 건의 트랜잭션을 지원할 수 있다. 데이터베이스 노드가 1,000 TPS를 지원할 수 있다고 가정해보자. 1M TPS에 도달하려면 1000개의 데이터베이스 노드가 필요하다.</p>
<p>그러나 이 계산은 약간 부정확하다. 각 이체 명령에는 한 계좌에서 돈을 공제하고 다른 계좌에서 돈을 입금하는 두 가지 작업이 포함되기 때문에 초당 1M의 이체를 지원하려면 2M TPS를 처리해야 하며 이는 2000개의 노드가 필요하다는 의미다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Per-node TPS</th>
<th style="text-align:left">Node Number</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">100</td>
<td style="text-align:left">20,000</td>
</tr>
<tr>
<td style="text-align:left">1,000</td>
<td style="text-align:left">2,000</td>
</tr>
<tr>
<td style="text-align:left">10,000</td>
<td style="text-align:left">200</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Step-2-Propose-High-Level-Design-and-Get-Buy-In"><a href="#Step-2-Propose-High-Level-Design-and-Get-Buy-In" class="headerlink" title="Step 2 - Propose High-Level Design and Get Buy-In"></a>Step 2 - Propose High-Level Design and Get Buy-In</h2><h3 id="API-Design"><a href="#API-Design" class="headerlink" title="API Design"></a>API Design</h3><p>RESTful API 컨벤션을 사용한다. 우리는 하나의 API만 지원하면 된다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>API</strong></th>
<th style="text-align:left"><strong>Detail</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">POST /v1/wallet/balance_transfer</td>
<td style="text-align:left">Transfer balance from one wallet to another</td>
</tr>
</tbody>
</table>
</div>
<p>요청 매개변수는 다음과 같다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Field</strong></th>
<th style="text-align:left"><strong>Description</strong></th>
<th style="text-align:left"><strong>Type</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">from_account</td>
<td style="text-align:left">The debit account</td>
<td style="text-align:left">string</td>
</tr>
<tr>
<td style="text-align:left">to_account</td>
<td style="text-align:left">The credit account</td>
<td style="text-align:left">string</td>
</tr>
<tr>
<td style="text-align:left">amount</td>
<td style="text-align:left">The amount of money</td>
<td style="text-align:left">string</td>
</tr>
<tr>
<td style="text-align:left">currency</td>
<td style="text-align:left">The currency type</td>
<td style="text-align:left">string (ISO 4217 [3])</td>
</tr>
<tr>
<td style="text-align:left">transaction_id</td>
<td style="text-align:left">ID used for deduplication</td>
<td style="text-align:left">uuid</td>
</tr>
</tbody>
</table>
</div>
<p>응답은 다음과 같다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Status&quot;: &quot;success&quot;</span><br><span class="line">  &quot;Transaction_id&quot;: &quot;01589980-2664-11ec-9621-0242ac130002&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>한 가지 언급할 만한 점은 “금액” 필드의 데이터 유형이 <code>double</code>이 아닌 <code>string</code> 이라는 점이다. 실제로는 거의 모든 프로그래밍 언어와 데이터베이스에서 지원되기 때문에 여전히 많은 사람들이 float나 double을 사용한다. 정밀도를 잃을 수 있는 잠재적 위험을 이해한다면 이는 적절한 선택이다.</p>
<h3 id="In-memory-sharding-solution"><a href="#In-memory-sharding-solution" class="headerlink" title="In-memory sharding solution"></a>In-memory sharding solution</h3><p>지갑 애플리케이션은 모든 사용자 계정에 대한 계정 잔액을 유지한다. 이 <user, balance> 관계를 나타내는 좋은 데이터 구조는 해시 테이블(map) 또는 KV Store라고 하는 map이다.</p>
<p>인메모리 저장소의 경우 redis가 많이 사용된다. Redis 노드 하나만으로는 1M TPS를 처리하기 충분하지 않다. Redis 노드 클러스터를 설정하고 사용자 계정을 균등히 분산시켜야 한다. 이 과정을 파티셔닝 또는 샤딩이라 한다.</p>
<p>KV 데이터를 N개의 파티션에 분산하려면 키의 해시값을 계산한 후 이를 N으로 나누고 나머지가 파티션의 대상이다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String accountID = &quot;A&quot;;</span><br><span class="line">Int partitionNumber = 7;</span><br><span class="line">Int myPartition = accountID.hashCode() % partitionNumber;</span><br></pre></td></tr></table></figure>
<p>모든 Redis 노드의 파티션 수와 주소는 중앙 집중화된 곳에 저장할 수 있다. 가용성이 높은 config storage 솔루션으로 Zookeeper를 사용할 수 있다. 이 솔루션의 마지막 구성 요소는 이체 명령을 처리하는 서비스다. 지갑 서비스라고 부르는 이 서비스는 몇 가지 핵심적인 역할을 수행한다.</p>
<ol>
<li>이체 명령 수신</li>
<li>이체 명령의 유효성 검사</li>
<li>명령이 유효하면 이체와 관련된 두 사용자의 계정 잔액을 업데이트한다. 클러스터에서 계정 잔액은 서로 다른 Redis 노드에 있을 수 있다.</li>
</ol>
<p>지갑 서비스는 stateless다. 수평적 확장이 용우하다. 아래는 인메모리 솔루션을 보여준다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101220414624.png" alt=""></p>
<p>이 예제에는 3개의 Redis 노드가 있다. A,B,C 라는 세명의 클라이언트가 있으며, 이들의 계정 잔액은 이 세 개의 Redis 노드에 고르게 분산되어 있다. 이 예시에는 잔액 이체 요청을 처리하는 지갑 서비스 노드가 두 개 있다. 지갑 서비스 노드 중 하나가 클라이언트 A에서 클라이언트 B로 1을 이체하라는 전송 명령을 받으면 두 개의 Redis 노드에 두 개의 명령을 내린다. 클라이언트 A의 잔액이 포함된 Redis 노드의 경우, 지갑 서비스는 계정에서 1을 차감한다. 클라이언트 B의 경우, 지갑 서비스는 계정에 1달러를 더한다.</p>
<p><strong>Candidate</strong>: 이 설계에서는 계정 잔액이 여러 Redis 노드에 분산된다. 주키퍼는 샤딩 정보를 유지하는데 사용된다. Stateless 지갑 서비스는 샤딩 정보를 사용해 클라이언트를 위한 Redis 노드를 찾고 그에 따라 계정 잔액을 업데이트 한다.</p>
<p><strong>Interviewer</strong>: 이 설계는 작동하지만 정확성 요구사항을 충족하지 못한다. 지갑 서비스는 송금할 때마다 두 개의 Redis 노드를 업데이트한다. 두 업데이트가 모두 성공한다는 보장은 없다. 예를 들어 첫 번째 업데이트가 완료된 후 두 번째 업데이트가 완료되기 전에 지갑 서비스 노드가 충돌하면 불완전한 이체가 발생한다. 두 업데이트는 하나의 atomic 트랜잭션에 포함되어야 한다.</p>
<h3 id="Distributed-transactions"><a href="#Distributed-transactions" class="headerlink" title="Distributed transactions"></a>Distributed transactions</h3><h4 id="Database-sharding"><a href="#Database-sharding" class="headerlink" title="Database sharding"></a>Database sharding</h4><p>서로 다른 두 스토리지 노드에 대한 업데이트를 원자적으로 수행하려면 어떻게 해야할까? 첫 번째 단계는 각 Redis 노드를 트랜잭션 관계형 데이터베이스 노드로 교체하는 것이다. 아래는 아키텍처를 보여준다. 이번에는 클라이언트 A, B, C가 3개의 Redis 노드가 아닌 3개의 관계형 데이터베이스로 분할된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101221202999.png" alt=""></p>
<p>트랜잯녀 데이터베이스를 사용하면 문제의 일부만 해결할 수 있다. 마지막 섹션에서 언급했듯이 하나의 이전 명령으로 서로 다른 두 데이터베이스에 있는 두 계정을 업데이트해야 할 가능성이 매우 높다. 두 개의 업데이트 작업이 정확히 동시에 처리된다는 보장은 없다. 첫 번째 계정 잔액을 업데이트한 후 지갑 서비스가 다시 시작되었다면 두 번째 계정도 업데이트될지 어떻게 확인할 수 있을까?</p>
<h4 id="Distributed-transaction-two-phase-commit"><a href="#Distributed-transaction-two-phase-commit" class="headerlink" title="Distributed transaction: two-phase commit"></a>Distributed transaction: two-phase commit</h4><p>분산 시스템에서 트랜잭션은 여러 노드에서 여러 프로세스를 포함할 수 있다. 트랜잭션을 원자적으로 만들려면 분산 트랜잭션이 해답이 될 수 있다. 분산 트랜잭션을 구현하는 방법에는 저수준 솔루션과 고수준 솔루션의 두 가지가 있다. 각각을 살펴보자.</p>
<p>저수준 솔루션은 데이터베이스 자체에 의존한다. 가장 일반적으로 사용되는 알고리즘은 2PC다. </p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101221417707.png" alt=""></p>
<ol>
<li>코디네이터는 정상적으로 여러 데이터베이스에 대한 읽기 및 쓰기 작업을 수행한다. 아래서 볼 수 있듯이 데이터베이스 A와 C는 모두 잠겨있다.</li>
<li>애플리케이션이 트랜잭션을 커밋하려고 할 때 코디네이터는 모든 데이터베이스에 트랜잭션을 준비하도록 요청한다.</li>
<li>두 번째 단계에서 코디네이터는 모든 데이터베이스에서 응답을 수집하고 다음을 수행한다.<ol>
<li>모든 데이터베이스가 “yes”라고 응답하면 코디네이터는 모든 데이터베이스에 수신한 트랜잭션을 커밋하도록 요청한다.</li>
<li>어떤 데이터베이스가 “no”로 응답하면 코디네이터는 모든 데이터베이스에 트랜잭션을 중단하도록 요청한다.</li>
</ol>
</li>
</ol>
<p>준비 단계에서는 데이터베이스 트랜잭션에 특별한 수정이 필요하기 때문에 저수준 솔루션이다. 예를 들어, 2PC를 달성하기 위해 이기종 데이터베이스를 조정하는 X/Open XA 표준이 있다. 2PC의 가장 큰 문제점은 다른 노드의 메세지를 기다리는 동안 잠금이 매우 오랫동안 유지될 수 있기 때문에 성능이 좋지 않다는 점이다. 2PC의 또다른 문제는 아래서 볼 수 있듯이 코디네이터가 단일 장애 지점이 될 수 있다는 점이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101221719741.png" alt=""></p>
<h4 id="Distributed-transaction-Try-Confirm-Cancel-TC-C"><a href="#Distributed-transaction-Try-Confirm-Cancel-TC-C" class="headerlink" title="Distributed transaction: Try-Confirm/Cancel (TC/C)"></a>Distributed transaction: Try-Confirm/Cancel (TC/C)</h4><p>TCC는 두 단계로 구성된 보상 트랜잭션의 한 유형이다.</p>
<ol>
<li>첫 번째 단계에서는 코디네이터가 모든 데이터베이스에 트랜잭션을 위한 리소스를 예약하도록 요청한다.</li>
<li>두 번째 단계에서는 코디네이터가 모든 데이터베이스에서 응답을 수집한다.<ol>
<li>모든 데이터베이스가 “yes”로 응답하면 코디네이터는 모든 데이터베이스에 작업을 확인하도록 요청하는데, 이게 Try-Confirm 프로세스다.</li>
<li>어떤 데이터베이스가 “no”로 응답하면 코디네티어는 모든 데이터베이스에 작업 취소를 요청하는 Try-Cancel 프로세스를 수행한다.</li>
</ol>
</li>
</ol>
<p>2PC의 두 단계는 동일한 트랜잭션으로 묶여있지만 TCC에서는 각 단계가 별도의 트랜잭션이라는 점에 유의해야 한다.</p>
<p><strong>TC/C example</strong></p>
<p>A 계좌에서 C 계좌로 1달러를 이체한다고 가정해보자. 아래는 각 단계에서 TCC가 어떻게 실행되는지 요약한 것이다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Phase</th>
<th style="text-align:left">Operation</th>
<th style="text-align:left">A</th>
<th style="text-align:left">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Try</td>
<td style="text-align:left">Balance change: -$1</td>
<td style="text-align:left">Do nothing</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">Confirm</td>
<td style="text-align:left">Do nothing</td>
<td style="text-align:left">Balance change: +$1</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">Cancel</td>
<td style="text-align:left">Balance change: +$1</td>
<td style="text-align:left">Do Nothing</td>
</tr>
</tbody>
</table>
</div>
<p>지갑 서비스가 TCC의 코디네이터라고 가정해보자. 분산 트랜잭션이 시작될 때 계정 A의 잔액은 1이고 계정 C의 잔액은 0이다.</p>
<p><strong>First phase: Try</strong></p>
<p>Try 단계에서 코디네이터 역할을 하는 지갑 서비스는 두 개의 트랜잭션 명령을 두 개의 데이터베이스로 보낸다.</p>
<ol>
<li>계정 A가 포함된 데이터베이스의 경우, 코디네이터는 A의 잔액을 1달러 감소시키는 로컬 트랜잭션을 시작한다.</li>
<li>계정 C가 포함된 데이터베이스에 대해 코디네이터는 NOP(no operation)을 반환한다. 이 예제를 다른 시나리오에 적용할 수 있도록 코디네이터가 이 데이터베이스에 NOP 명령을 보낸다고 가정해보자. 데이터베이스는 NOP 명령에 대해 아무 작업도 수행하지 않고 항상 코디네이터에게 성공 메세지로 응답한다.</li>
</ol>
<p>Try 단계는 아래 나와있다. 굵은 선은 트랜잭션에 의해 잠금이 유지되고 있음을 나타낸다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101222305360.png" alt=""></p>
<p><strong>Second phase: Confirm</strong></p>
<p>두 데이터베이스가 모두 “yes”라고 응답하면 지갑 서비스는 다음 확인 단계를 시작한다.</p>
<p>계정 A의 잔액은 첫 번째 단계에서 이미 업데이트가 되었다. 지갑 서비스는 잔액을 변경할 필요가 없다. 그러나 계정 C는 첫 번째 단계에서 계정 A로부터 아직 1을 받지 못했다. Confirm 단계에서 지갑 서비스는 계정 C의 잔액에 1을 추가해야 한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101222454751.png" alt=""></p>
<p><strong>Second phase: Cancel</strong></p>
<p>첫 번째 Try 단계가 실패하면 어떻게 해야 할까? 위 에서는 계정 C에 대한 NOP 작업이 항상 성공한다고 가정했지만 실제로는 실패할 수도 있다. 예를 들어 C 계정은 불법 계쩡일 수 있으며 규제 당국은 이 계정으로 자금이 유입되거나 유출될 수 없도록 규정하고 있다. 이 경우 분산된 트랜잭션을 취소하고 정리해야 한다.</p>
<p>Try 단계의 트랜잭션에서 계정 A의 잔액이 이미 업데이트 되었기 때문에 지갑 서비스에서 완료된 트랜잭션을 취소하는 것은 불가능하다. 할 수 있는 일은 Try 단계의 트랜잭션 효과를 되돌릴 수 있는 다른 트랜잭션을 시작하는 것, 즉 계정 A에 1달러를 다시 추가하는 것이다.</p>
<p>Try 단계에서 계정 C가 업데이트되지 않았기 때문에 지갑 서비스는 계정 C의 데이터베이스에 NOP 작업을 전송하기만 하면 된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101222729080.png" alt=""></p>
<p><strong>Comparison between 2PC and TC/C</strong></p>
<p>아래는 2PC와 TCC를 비교한 표다. 2PC에서는 두 번째 단계가 시작될 때 모든 로컬 트랜잭션이 완료되지 않고(still locked) TCC에서는 두 번째 단계가 시작될 때 모든 로컬 트랜잭션이 완료된다(unlocked). 즉 2PC의 두 번째 단계는 중단 또는 커밋과 같이 완료되지 않은 트랜잭션을 완료하는 것이고, TCC의 두 번째 단계는 오류가 발생했을 때 이전 트랜잭션 결과를 상쇄하기 위해 역방향 연산을 사용하는 것이다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong> First Phase</strong></th>
<th><strong>Second Phase: success</strong></th>
<th><strong>Second Phase: fail</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>2PC</td>
<td>Local transactions are not done yet</td>
<td>Commit all local transactions Cancel all local transactions</td>
<td>Cancel all local transactions</td>
</tr>
<tr>
<td>TC/C</td>
<td>All local transactions are completed, either committed or canceled</td>
<td>Execute new local transactions if needed</td>
<td>Reverse the side effect of the already committed transaction, or called “undo”</td>
</tr>
</tbody>
</table>
</div>
<p>TCC는 보상에 의한 분산 트랜잭션이라고도 한다. “실행 취소”라고 하는 보상이 비즈니스 로직에서 구현되기 때문에 고수준 솔루션이다. 이 접근 방식의 장점은 데이터베이스에 구애받지 않는다는 것이다. 데이터베이스가 트랜잭션을 지원하는 한 TCC는 작동한다. 단점은 애플리케이션 계층의 비즈니스 로직에서 세부 사항을 관리하고 분산된 트랜잭션의 복잡성을 처리해야 한다는 것이다.</p>
<p><strong>Phase status table</strong></p>
<p>우리는 앞서 질문한 TCC 도중 지갑 서비스가 다시 시작되면 어떻게 되는지에 대해 답을 못했다. 서비스가 다시 시작되면 이전의 모든 작업 기록이 손실될 수 있으며, 시스템에서 복구 방법을 모를 수도 있다.</p>
<p>해결책은 간단하다. TCC의 진행 상황을 트랜잭션 데이터베이스에 phase status 상태로 저장하면 된다. Phase status에는 최소한 다음 정보가 포함된다.</p>
<ul>
<li>분산 트랜잭션의 ID와 콘텐츠</li>
<li>각 데이터베이스의 Try 단계 상태. 상태는 “not sent yet”, “has been sent”, “response received”가 될 수 있다.</li>
<li>두 번째 단계의 이름. “Confirm” 또는 “Cancel”이 될 수 있다. Try 단계의 결과를 사용해 계산할 수 있다.</li>
<li>두 번째 단계의 상태</li>
<li>Out-of-order flag</li>
</ul>
<p>Phase status 테이블은 어디에 두어야 할까? 일반적으로 phase status는 돈이 차감되는 지갑 계정에 포함된 데이터베이스에 저장한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101224013832.png" alt=""></p>
<p><strong>Unbalanced state</strong></p>
<p>Try 단계가 끝날 때 아래 다이어그램에서 1$가 누락된 것을 볼 수 있다.</p>
<p>모든 것이 순조롭게 진행되었다고 가정하면 Try 단계가 끝날 때 계정 A에서 1달러가 차감되고 계정 C는 그대로 유지된다. A와 C의 계정 잔액 합계는 0이 되며 이는 TCC 시작 시점보다 적다. 이는 트랜잭션 후 금액이 동일하게 유지되어야 한다는 회계의 기본 규칙을 위반하는 것이다.</p>
<p>좋은 소식은 트랜잭션 보증이 TCC에 의해 여전히 유지된다는 것이다. TCC는 여러 개의 독립적인 로컬 트랜잭션으로 구성된다. TCC는 애플리케이션에 의해 구동되기 때문에 애플리케이션 자체에서 이런 로컬 트랜잭션 사이의 중간 결과를 확인할 수 있다. 반면, 데이터베이스 트랜잭션 또는 2PC 버전의 분산 트랜잭션은 상위 수준의 애플리케이션에는 보이지 않는 데이터베이스에 의해 유지관리된다.</p>
<p>분산 트랜잭션을 실행하는 동안에는 항상 데이터 불일치가 발생한다. 데이터베이스와 같은 하위 시스템에서 이미 불일치를 수정했기 때문에 불일치가 투명하게 드러날 수도 있다. 그렇지 않은 경우 우리가 직접 처리해야 한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101224429456.png" alt=""></p>
<p><strong>Valid operation orders</strong></p>
<p>Try 단계에서는 3가지 선택지가 있다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Try phase choices</th>
<th style="text-align:left">Account A</th>
<th style="text-align:left">Account C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Choice 1</td>
<td style="text-align:left">-$1</td>
<td style="text-align:left">NOP</td>
</tr>
<tr>
<td style="text-align:left">Choice 2</td>
<td style="text-align:left">NOP</td>
<td style="text-align:left">+$1</td>
</tr>
<tr>
<td style="text-align:left">Choice 3</td>
<td style="text-align:left">-$1</td>
<td style="text-align:left">+$1</td>
</tr>
</tbody>
</table>
</div>
<p>세 가지 선택지 모두 그럴듯해 보이지만, 일부는 유효하지 않다.</p>
<p>선택지 2의 경우 계정 C에서 Try 단계가 성공했지만 계정 A에서 실패한 경우(NOP) 지갑 서비스는 취소 단계로 진입해야 한다. 다른 사람이 개입해 계정 C에서 1을 옮길 가능성이 있다. 나중에 지갑 서비스가 계정 C에서 1을 차감하려고 하면 아무것도 남지 않은 것을 발견하게 되며, 이는 분산 트랜잭션의 트랜잭션 보증을 위반하는 것이다.</p>
<p>선택지 3의 경우 계정 A에서 1을 차감하고 동시에 계정 C에 추가하면 많은 문제가 발생한다. 예를 들어 1이 계정 C에 추가되었지만 계정 A에서 돈을 공제하지 못했다. 이 경우 어떻게 해야할까?</p>
<p>따라서 선택지 2와 선택지 3은 잘못된 선택이며 선택지 1만 유효하다.</p>
<p><strong>Out-of-order execution</strong></p>
<p>TCC의 한 가지 부작용은 순서를 벗어난 실행이다. 예제를 사용하면 훨씬 쉽게 설명할 수 있다. 아래서 볼 수 있듯이 계정 A에서 계정 C로 1달러를 이체하는 위의 예시를 다시 사용한다. Try 단계에서 계정 A에 대한 작업이 실패하면 지갑 서비스에 실패를 반환하고 지갑 서비스는 취소 단계로 진입해 계정 A와 계정 C 모두에 취소 작업을 보낸다.</p>
<p>계정 C를 처리하는 데이터베이스에 네트워크 문제가 발생하여 Try 명령보다 먼저 취소 명령을 받는다고 가정해보자. 이 경우 취소할 것이 없다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101225009786.png" alt=""></p>
<p>순서가 맞지 않는 작업을 처리하기 위해 각 노드는 다음과 같은 업데이트로 기존 로직을 개선해 Try 명령을 받지 않고도 TCC를 취소할 수 있다.</p>
<ul>
<li><p>순서가 맞지 않는 취소 연산은 데이터베이스에 취소 연산은 보았지만 아직 Try 연산은 보지 못했음을 나타내는 플래그를 남긴다.</p>
</li>
<li><p>Try 작업은 항상 out-of-order 플래그가 있는지 여부를 확인하고 플래그가 있는 경우 실패를 반환하도록 개선한다.</p>
</li>
</ul>
<p>이것이 바로 “Phase Status Table” 섹션의 phase status table에 out-of-order 플래그를 추가한 이유다.</p>
<h4 id="Distributed-transaction-Saga"><a href="#Distributed-transaction-Saga" class="headerlink" title="Distributed transaction: Saga"></a>Distributed transaction: Saga</h4><p><strong>Linear order execution</strong></p>
<p>Saga라는 또 다른 인기 있는 분산 트랜잭션 솔루션이 있다. Saga는 마이크로 서비스 아키텍처의 사실상의 표준이다. Saga의 개념은 간단하다.</p>
<ol>
<li>모든 작업이 순서대로 정렬된다. 각 작업은 자체 데이터베이스에서 독립적인 트랜잭션이다.</li>
<li>작업은 첫 번째 작업부터 마지막 작업까지 실행된다. 한 작업이 완료되면 다음 작업이 트리거된다.</li>
<li>작업이 실패하면 전체 프로세스는 보상 트랜잭션을 사용해 현재 작업에서 첫 번째 작업으로 역순으로 롤백하기 시작한다. 따라서 분산 트랜잭션에 n개의 연산이 있는 경우, 정상적인 경우의 연산과 롤백 중 보상 트랜잭션에 대한 또 다른 연산, 즉 2n개의 연산을 준비해야 한다.</li>
</ol>
<p>예제를 사용하면 더 쉽게 이해할 수 있다. 아래는 계정 A에서 계정 C로 1달러를 이체하는 Saga 워크플로우를 보여준다. 상단 가로줄은 일반적인 실행 순서를 보여준다. 두 개의 세로선은 오류가 발생했을 때 시스템이 수행해야 하는 작업을 보여준다. 오류가 발생하면 이체 작업이 롤백되고 클라이언트를 오류 메세지를 받게 된다. “Valid operation orders” 섹션에서 언급했듯이 더하기 연산보다 빼기 연산을 먼저 수행해야 한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101225521896.png" alt=""></p>
<p>연산을 조율하는 방법에는 두 가지가 있다.</p>
<ol>
<li>Choreography. 마이크로서비스 아키텍처에서는 사가 분산 트랜잭션에 관련된 모든 서비스가 다른 서비스의 이벤트를 구독함으로써 작업을 수행한다. 따라서 완전히 탈중앙화된 조정이다.</li>
<li>Orchestration. 단일 코디네이터가 모든 서비스가 올바른 순서로 작업을 수행하도록 지시한다.</li>
</ol>
<p>어떤 코디네이션 모델을 사용할 지는 비즈니스 요구와 목표에 따라 결정된다. 코디네이션 솔루션의 문제점은 서비스가 완전히 비동기식으로 통신하기 때문에 각 서비스가 내부 상태 머신을 유지하여 다른 서비스가 이벤트를 발생시킬 때 수행해야 할 작업을 파악해야 한다는 것이다. 서비스가 많으면 관리가 어려워질 수 있다. 오케스트레이션 솔루션은 복잡성을 잘 처리하므로 일반적으로 디지털 지갑 시스템에서 선호되는 솔루션이다.</p>
<p><strong>Comparison between TC/C and Saga</strong></p>
<p>TCC와 Saga는 모두 어플리케이션 레벨의 분산 트랜잭션이다. 아래는 둘의 차이를 표로 정리했다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">TC/C</th>
<th style="text-align:left">Saga</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Compensating action</td>
<td style="text-align:left">In Cancel phase</td>
<td style="text-align:left">In rollback phase</td>
</tr>
<tr>
<td style="text-align:left">Central coordination</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes (orchestration mode)</td>
</tr>
<tr>
<td style="text-align:left">Operation execution order</td>
<td style="text-align:left">any</td>
<td style="text-align:left">linear</td>
</tr>
<tr>
<td style="text-align:left">Parallel execution possibility</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">No (linear execution)</td>
</tr>
<tr>
<td style="text-align:left">Could see the partial inconsistent status</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">Application or database logic</td>
<td style="text-align:left">Application</td>
<td style="text-align:left">Application</td>
</tr>
</tbody>
</table>
</div>
<p>실제로 어떤 것을 사용해야 할까? 답은 지연 시간 요구 사항에 따라 달라진다. Saga의 작업은 선형 순서로 실행해야 하지만 TCC에서는 병렬로 실행할 수 있다. 따라서 결정은 몇 가지 요인에 따라 달라진다.</p>
<p>지연 시간이 필요하지 않거나 송금 예시 처럼 서비스가 거의 없는 경우에는 둘중 하나를 선택할 수 있다. 마이크로서비스 아키텍처의 트랜드를 따르고 싶다면 Saga를 선택하면 된다.</p>
<p>지연 시간에 민감하고 많은 서비스 / 연산을 포함하는 시스템이라면 TCC가 더 나은 옵션일 수 있다. </p>
<p><strong>Candidate</strong>: 잔액 이체를 트랜잭션으로 처리하기 위해 Redis를 관계형 데이터베이스로 대체하고, 분산 트랜잭션을 구현하기 위해 TCC 또는 Saga를 사용한다.</p>
<p><strong>Interviewer</strong>: 분산 트랜잭션 솔루션은 작동하지만 제대로 작동하지 않는 경우가 있을 수 있다. 예를 들어 사용자가 애플리케이션 수준에서 잘못된 연산을 입력할 수 있다. 이 경우 우리가 지정한 금액이 잘못되었을 수 있다. 문제의 근본 원인을 역추적하고 모든 계정 작업을 감사할 수 있는 방법이 필요하다.</p>
<h3 id="Event-sourcing"><a href="#Event-sourcing" class="headerlink" title="Event sourcing"></a>Event sourcing</h3><h4 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h4><p>실생활에서 디지털 지갑 제공업체는 감사를 받을 수 있다. 외부 감사인은 예를 들어 몇 가지 까다로운 질문을 할 수 있다.</p>
<ol>
<li>특정 시점의 계정 잔액을 알고 있는가?</li>
<li>과거 계정 잔액과 현재 계정 잔액이 정확한지 어떻게 알 수 있는가?</li>
<li>코드 변경 후 시스템 로직이 정확하다는 것을 어떻게 증명할 수 있는가?</li>
</ol>
<p>이런 질문에 체계적으로 답할 수 있는 설계 철학 중 하나가 DDD에서 개발된 기법인 이벤트 소싱이다.</p>
<h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>이벤트 소싱에는 4가지 핵심이 있다.</p>
<ul>
<li>Command</li>
<li>Event</li>
<li>State</li>
<li>State machine</li>
</ul>
<p><strong>Command</strong></p>
<p>명령은 외부에서 의도한 동작을 의미한다. 예를 들어 고객 A에서 고객 C로 1달러를 송금하려는 경우 이 송금 요청은 명령이다.</p>
<p>이벤트 소싱에서는 모든 것이 순서를 갖는 것이 매우 중요하다. 따라서 명령은 일반적으로 FIFO 대기열에 넣는다.</p>
<p><strong>Event</strong></p>
<p>일부 명령은 유효하지 않아 실행되지 않을 수 있으므로 명령은 의도가 아니라 사실이다. 예를 들어, 이체 후 계정 잔액이 마이너스가 되면 이체 작업은 실패한다.</p>
<p>명령은 어떤 조치를 취하기 전에 반드시 유효성 검사를 거쳐야 한다. 명령이 유효성 검사를 통과하면 유효하며 반드시 실행되어야 한다. 이행 결과를 이벤트라고 한다.</p>
<p>명령과 이벤트에는 크게 두 가지 차이점이 있다.</p>
<ol>
<li>이벤트는 검증된 사실을 나타내므로 반드시 실행되어야 한다. 실제로는 보통 이벤트에 과거 시제를 사용한다. 명령이 “1을 A에서 C로 전송”인 경우, 이벤트는 “1을 A에서 C로 전송했다”가 된다.</li>
<li>명령은 무작위성이나 입출력을 포함할 수 있지만 이벤트는 결정론적이여야 한다. 이벤트는 역사적 사실을 나타낸다.</li>
</ol>
<p>이벤트 생성 과정에는 두 가지 중요한 특성이 있다.</p>
<ol>
<li>하나의 명령은 여러 개의 이벤트를 생성할 수 있다. 0개 이상의 이벤트를 생성할 수도 있다.</li>
<li>이벤트 생성에는 무작위성이 포함될 수 있으며, 이는 명령이 항상 동일한 이벤트를 생성한다는 보장이 없다는 것을 의미한다. 이벤트 생성에는 외부 I/O 또는 임의의 숫자가 포함될 수 있다.</li>
</ol>
<p>이벤트의 순서는 명령의 순서를 따라야 한다. 따라서 이벤트도 FIFO 큐에 저장된다.</p>
<p><strong>State</strong></p>
<p>상태는 이벤트가 적용될 때 변경되는 내용이다. 지갑 시스템에서 상태는 모든 클라이언트 계정의 잔액으로, map 데이터 구조로 나타낼 수 있다. 키는 계정 이름 또는 ID이고 값은 계정 잔액이다. KV 스토어는 일반적으로 이런 map 데이터를 저장하는데 사용된다. 관계형 데이터베이스도 KV 스토어로 볼 수 있는데 여기서 키는 기본 키이고 값은 테이블 행이다.</p>
<p><strong>State machine</strong></p>
<p>상태 머신은 이벤트 소싱 프로세스를 구동한다. 두 가지 주요 기능이 있다.</p>
<ol>
<li>명령의 유효성을 검사하고 이벤트를 생성한다.</li>
<li>이벤트를 적용해 상태를 업데이트 한다.</li>
</ol>
<p>이벤트 소싱을 위해서는 상태 머신의 동작이 결정론적이여야 한다. 따라서 상태 머신 자체에 임의성이 포함되어서는 안된다. 예를 들어 I/O를 사용해 외부에서 임의의 것을 읽거나 임의의 숫자를 사용해서는 안된다. 상태에 이벤트를 적용할 때는 항상 동일한 결과를 생성해야 한다.</p>
<p>아래는 이벤트 소싱 아키텍처의 static view를 보여준다. 상태 머신은 명령을 이벤트로 변환하고 이벤트를 적용하는 역하을 담당한다. 상태 머신에는 두 가지 주요 기능이 있기 때문에 일반적으로 명령의 유효성 검사를 위한 상태 머신과 이벤트 적용을 위한 상태 머신을 두 개씩 그려 넣는다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101231457636.png" alt=""></p>
<p>시간 차원을 추가하면 아래는 이벤트 소싱의 dynamic view를 보여준다. 시스템은 계속해서 명령을 수신하고 하나씩 처리한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101231530888.png" alt=""></p>
<h4 id="Wallet-service-example"><a href="#Wallet-service-example" class="headerlink" title="Wallet service example"></a>Wallet service example</h4><p>지갑 서비스의 경우 명령은 잔액 이체 요청이다. 이런 명령은 FIFO 대기열에 넣는다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101231613431.png" alt=""></p>
<p>상태(계정 잔액)가 관계형 데이터베이스에 저장되어 있다고 가정해보자. 상태 머신은 각 명령을 FIFO 순서로 하나씩 검사한다. 각 명령에 대해 계정에 충분한 잔액이 있는지 확인한다. 잔액이 충분하면 상태 머신은 각 계정에 대한 이벤트를 생성한다. 예를 들어 명령이 “A-&gt;1-&gt;C” 인 경우 상태 머신은 두 개의 이벤트를 생성한다. “A:-$1”, “C:+$1”</p>
<p>아래는 상태 머신의 작동 방식을 5단계로 보여준다.</p>
<ol>
<li>명령 대기열에서 명령을 읽는다.</li>
<li>데이터베이스에서 잔액 상태를 읽는다.</li>
<li>명령의 유효성을 검사한다. 유효하면 각 계정에 대해 두 개의 이벤트를 생성한다.</li>
<li>다음 이벤트를 읽는다.</li>
<li>데이터베이스에서 잔액을 업데이트해 이벤트를 적용한다.</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101231911249.png" alt=""></p>
<h4 id="Reproducibility"><a href="#Reproducibility" class="headerlink" title="Reproducibility"></a>Reproducibility</h4><p>이벤트 소싱이 다른 아키텍처에 비해 갖는 가장 중요한 장점은 재현성이다.</p>
<p>앞서 언급한 분산 트랜잭션 솔루션에서는 지갑 서비스가 업데이트된 계정 잔액(상태)을 데이터베이스에 저장한다. 계정 잔액이 변경된 이유를 알기 어렵다. 또한 업데이트 작업 중 과거 잔액 정보가 손실된다. 이벤트 소싱 설계에서는 모든 변경 사항을 변경 불가능한 기록으로 먼저 저장한다. 데이터베이스는 특정 시점의 잔액이 어떻게 보이는지에 대한 업데이트된 뷰로만 사용된다.</p>
<p>이벤트를 처음부터 다시 재생하면 언제든지 과거의 밸런스 상태를 재구성할 수 있다. 이벤트 목록은 불변이고 상태 머신 로직은 결정론적이기 때문에 각 리플레이에서 생성된 과거 상태가 동일하다는 것이 보장된다.</p>
<p>아래는 이벤트를 재생해 지갑 서비스의 상태를 재현하는 방법을 보여준다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101232134442.png" alt=""></p>
<p>재현성은 감사관이 섹션을 시작할때 물었던 어려운 질문에 답하는 데 도움이 된다.</p>
<ul>
<li>특정 시점의 계정 잔액을 알 수 있나요?<ul>
<li>처음부터 계쩡 잔액을 알고 싶은 시점까지 이벤트를 재생해 답을 찾을 수 있다.</li>
</ul>
</li>
<li>과거 계정 잔액과 현재 계정 잔액이 정확한지 어떻게 알 수 있나요?<ul>
<li>이벤트 목록에서 계정 잔액을 다시 계산해 계정 잔액의 정확성을 확인할 수 있다.</li>
</ul>
</li>
<li>코드 변경 후 시스템 로직이 정확하다는 것을 어떻게 증명할 수 있나요?<ul>
<li>이벤트에 대해 서로 다른 버전의 코드를 실행해 결과가 동일한지 확인할 수 있다.</li>
</ul>
</li>
</ul>
<p>감사 기능으로 인해 이벤트 소싱은 종종 지갑 서비스를 위한 사실상의 솔루션으로 선택된다.</p>
<h4 id="Command-query-responsibility-segregation-CQRS"><a href="#Command-query-responsibility-segregation-CQRS" class="headerlink" title="Command-query responsibility segregation (CQRS)"></a>Command-query responsibility segregation (CQRS)</h4><p>지금까지 우리는 한 계좌에서 다른 계좌로 돈을 효율적으로 이체할 수 있도록 지갑 서비스를 설계했다. 하지만 클라이언트는 여전히 계좌 잔액이 얼마인지 알 수 없다. 이벤트 소싱 프레임워크 외부에 있는 클라이언트가 상태를 알 수 있도록 상태(잔액 정보)를 게시할 수 있는 방법이 필요하다.</p>
<p>직관적으로 데이터베이스의 읽기 전용 복사본(과거 상태)를 만들어 외부와 공유할 수 있다. 이벤트 소싱은 약간 다른 방식으로 이 질문에 답한다.</p>
<p>이벤트 소싱은 상태(잔액 정보)를 게시하는 대신 모든 이벤트를 게시한다. 외부 세계는 사용자 정의된 상태를 자체적으로 재구성할 수 있다. 이런 설계 철학을 CQRS라고 한다.</p>
<p>CQRS에서는 상태의 쓰기 부분을 담당하는 하나의 상태 머신이 있지만, 상태의 뷰를 구축하는 읽기 전용 상태 머신이 다수 존재할 수 있다. 이런 뷰는 쿼리에 사용될 수 있다.</p>
<p>이런 읽기 전용 상태 머신은 이벤트 큐에서 다양한 상태 표현을 도출할 수 있다. 예를 들어, 클라이언트가 잔액을 알고 싶어할 경우 읽기 전용 상태 머신이 데이터베이스에 상태를 저장해 잔액 쿼리를 처리할 수 있다. 또 다른 상태 머신은 특정 기간 동안의 상태를 구축해 이중 청구 가능성과 같은 문제를 조사하는 데 도움을 줄 수 있다. 상태 정보는 재무 기록을 조정하는데 도움이 될 수 있는 감사 추적 정보다.</p>
<p>읽기 전용 상태머신은 어느 정도 뒤처지지만 언제든 따라잡을 수 있다. 아키텍처 설계는 결국 일관성을 유지한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240101232723716.png" alt=""></p>
<p><strong>Candidate</strong>: 이 설계에서는 이벤트 소싱 아키텍처를 사용해 전체 시스템을 재현하도록 한다. 모든 유효한 비즈니스 기록은 불변의 이벤트 대기열에 저장되어 정확성 검증에 사용될 수 있다.</p>
<p><strong>Interviewer</strong>: 하지만 제안한 이벤트 소싱 아키텍처는 한 번에 하나의 이벤트만 처리하고 여러 외부 시스템과 통신해야 한다. 더 빠르게 만들 수 있을까?</p>
<h2 id="Step-3-Design-Deep-Dive"><a href="#Step-3-Design-Deep-Dive" class="headerlink" title="Step 3 - Design Deep Dive"></a>Step 3 - Design Deep Dive</h2><h3 id="High-performance-event-sourcing"><a href="#High-performance-event-sourcing" class="headerlink" title="High-performance event sourcing"></a>High-performance event sourcing</h3><p>앞선 예제에서는 Kafka를 명령 및 이벤트 저장소로 데이터베이스를 상태 저장소로 사용했다. 몇 가지 최적화를 살펴보자.</p>
<h4 id="File-based-command-and-event-list"><a href="#File-based-command-and-event-list" class="headerlink" title="File-based command and event list"></a>File-based command and event list</h4><p>첫 번째 최적화는 명령과 이벤트를 Kafka와 같은 원격 저장소가 아닌 로컬 디스크에 저장하는 것이다. 이렇게 하면 네트워크를 통한 전송 시간을 피할 수 있다. 이벤트 목록은 append-only 데이터 구조를 사용한다. 추가는 순차적 쓰기작업으로 일반적으로 매우 빠르다. 운영체제가 순차적 읽기 및 쓰기에 크게 최적화되어 있기 때문에 하드 드라이브에서도 잘 동작한다. </p>
<p>두 번째 최적화는 최근 명령과 이벤트를 메모리에 캐시하는 것이다. 앞서 설명했듯이, 우리는 명령과 이벤트가 지속된 직후에 처리한다. 로컬 디스크에서 다시 로드하는 시간을 절약하기 위해 메모리에 캐시할 수 있다.</p>
<p>몇 가지 구현 세부 사항을 살펴보자. 앞서 언급한 최적화를 구현하는데는 mmap이라는 기술이 유용하다. Mmap은 로컬 디스크에 쓰면서 동시에 최근 콘텐츠를 메모리에 캐시할 수 있다. 디스크 파일을 메모리에 배열로 매핑한다. 운영 체제는 읽기 및 쓰기 작업을 가속화하기 위해 파일의 특정 섹션을 메모리에 캐시한다. Append-only 파일 작업의 경우 모든 데이터가 메모리에 저장되는 것이 거의 보장되므로 매우 빠르다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240103233219084.png" alt=""></p>
<h4 id="File-based-state"><a href="#File-based-state" class="headerlink" title="File-based state"></a>File-based state</h4><p>이전 설계에서 상태는 관계형 데이터베이스에 저장된다. 프로덕션 환경에서 데이터베이스는 일반적으로 네트워크를 통해서만 액세스할 수 있는 독립형 서버에서 실행된다. 명령 및 이벤트에 대한 최적화와 마찬가지로 상태 정보도 로컬 디스크에 저장할 수 있다.</p>
<p>보다 구체적으로, 파일 기반 로컬 관계형 데이터베이스인 SQLite나 로컬 KV 스토어인 RocksDB를 사용할 수 있다. RocksDB는 쓰기 작업에 최적화된 LSM 트리를 사용하기 때문에 선택되었다. 읽기 성능을 개선하기 위해 가장 최근의 데이터가 캐시된다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240103233358502.png" alt=""></p>
<h4 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h4><p>모든 것이 파일 기반이 되면 재현성 프로세스를 가속화하는 방법을 고려해보자. 재현성을 처음 도입했을 때, 상태 머신은 매번 처음부터 이벤트를 처리해야 했다. 우리가 최적화할 수 있는 방법은 주기적으로 상태 머신을 중지하고 현재 상태를 파일에 저장하는 것이다. 이를 스냅샷이라 한다.</p>
<p>스냅샷은 과거 상태에 대한 불변의 뷰다. 스냅샷이 저장되면 상태 머신은 더 이상 처음부터 다시 시작할 필요가 없다. 상태 머신은 스냅샷에서 데이터를 읽고 중단된 지점을 확인한 다음 거기서부터 처리를 재개할 수 있다.</p>
<p>지갑 서비스와 같은 금융 애플리케이션의 경우, 재무팀은 당일 발생한 모든 거래를 확인할 수 있도록 00:00에 스냅샷을 찍어야하는 경우가 많다. 이벤트 소싱의 CQRS를 처음 도입했을 때 해결책은 처음부터 지정된 시간이 충족될 때까지 읽는 읽기 전용 상태 머신을 설정하는 것이다. 스냅샷을 사용하면 읽기 전용 상태 머신은 데이터가 포함된 스냅샷 하나만 로드하면 된다.</p>
<p>스냅샷은 거대한 바이너리 파일이며, 일반적인 해결책은 HDFS와 같은 오브젝트 스토리지 솔루션에 저장하는 것이다.</p>
<p>아래는 파일 기반 이벤트 소싱 아키텍처를 보여준다. 모든 것이 파일 기반일때, 시스템은 컴퓨터 하드웨어의 최대 I/O 처리량을 적극적으로 활용할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240103233726488.png" alt=""></p>
<p><strong>Candidate</strong>: 명령 목록, 이벤트 목록, 상태, 스냅샷이 모두 파일에 저장되도록 이벤트 소싱의 설계를 리팩터링할 수 있다. 이벤트 소싱 아키텍처는 이벤트 목록을 선형적인 방식으로 처리하므로 하드 디스크 및 운영 체제 캐시 설계에 잘 맞다.</p>
<p><strong>Interviewer</strong>: 로컬 파일 기반 솔루션의 성능이 원격 카프카 및 데이터베이스에서 데이터에 액세스해야 하는 시스템보다 낫다. 하지만 데이터가 로컬 디스크에 저장되기 때문에 서버가 stateful이 되어 SPOF가 발생한다는 또 다른 문제가 있다. 시스템의 안정성을 어떻게 개선해야 할까?</p>
<h3 id="Reliable-high-performance-event-sourcing"><a href="#Reliable-high-performance-event-sourcing" class="headerlink" title="Reliable high-performance event sourcing"></a>Reliable high-performance event sourcing</h3><p>솔루션을 설명하기 전에 시스템에서 신뢰성 보증이 필요한 부분을 살펴보자.</p>
<h4 id="Reliability-analysis"><a href="#Reliability-analysis" class="headerlink" title="Reliability analysis"></a>Reliability analysis</h4><p>개념적으로 노드가 수행하는 모든 작업은 데이터와 계산이라는 두 가지 개념을 중심으로 이루어진다. 데이터가 내구성이 있는 한, 다른 노드에서 동일한 코드를 실행해 계산 결과를 복구하는 것은 쉽다. 즉, 데이터가 손실되면 영원히 손실되기 때문에 데이터의 신뢰성에 대해서만 걱정하면 된다. 시스템의 신뢰성은 대부분 데이터의 신뢰성에 관한 것이다.</p>
<p>우리는 네 가지 유형의 데이터를 다룬다.</p>
<ul>
<li>파일 기반 명령</li>
<li>파일 기반 이벤트</li>
<li>파일 기반 상태</li>
<li>상태 스냅샷</li>
</ul>
<p>각 데이터 유형의 신뢰성을 보장하는 방법을 자세히 살펴보자. 상태와 스냅샷은 이벤트 목록을 재생하여 언제든지 다시 생성할 수 있다. 상태 및 스냅샷의 안정성을 향상시키려면 이벤트 목록의 안정성을 보장하기만 하면 된다.</p>
<p>이제 명령을 살펴보자. 겉으로 보기에 이벤트는 명령에서 생성된다. 명령에 대한 강력한 신뢰성을 보장하는 것으로 충분하다고 생각할 수 있다. 언뜻 보기에는 맞지만, 중요한 것을 놓치고 있다. 이벤트 생성은 결정론적이라고 바장할 수 없으며, 난수, 외부 I/O 등과 같은 임의의 요소가 포함될 수 있다. 따라서 명령은 이벤트의 재현성을 보장할 수 없다.</p>
<p>이제 이벤트에 대해 자세히 살펴보자. 이벤트는 상태에 변화를 가져오는 역사적 사실을 나타낸다. 이벤트는 불변하며 상태를 재구성하는데 사용할 수 있다. 이런 분석을 통해 이벤트 데이터는 높은 신뢰성을 보장해야 하는 유일한 데이터라는 결론을 내릴 수 있다.</p>
<h4 id="Consensus"><a href="#Consensus" class="headerlink" title="Consensus"></a>Consensus</h4><p>높은 안정성을 제공하려면 여러 노드에 걸쳐 이벤트 목록을 복제해야 한다. 복제 과정에서 다음과 같은 속성을 보장해야 한다.</p>
<ul>
<li>데이터 손실 없음</li>
<li>로그 파일 내 데이터의 상대적 순서는 노드 간에 동일하게 유지</li>
</ul>
<p>이런 보장을 달성하려면 합의 기반 복제가 적합하다. 합의 알고리즘은 여러 노드가 이벤트 목록이 무엇인지에 대해 합의에 도달하도록 한다. Raft 컨센서스 알고리즘을 예로 살펴보자.</p>
<p>Raft는 노드의 절반 이상이 온라인 상태인 한, 노드의 append-only 목록이 동일한 데이터를 갖도록 보장한다. 예를 들어, 5개의 노드가 있고 Raft 알고리즘을 사용해 데이터를 동기화하는 경우 아래 표시된 것처럼 노드 중 최소 3개가 켜져있으면 시스템 전체가 정상적으로 작동할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240103234526399.png" alt=""></p>
<p>Raft 알고리즘에서 노드는 세 가지 역할을 수행할 수 있다.</p>
<ul>
<li>Leader</li>
<li>Candidate</li>
<li>Follower</li>
</ul>
<p>여기서는 고수준의 개념만 간단히 다룬다. Raft에서는 최대 하나의 노드가 클러스터의 리더가 되고 나머지 노드는 팔로워가 된다. 리더는 외부 명령을 수신하고 클러스터 내 노드 간에 데이터를 안정적으로 복제하는 역할을 담당한다.</p>
<p>Raft 알고리즘을 사용하면 대부분의 노드가 작동하는 한 시스템이 안정적이다. 예를 들어, 클러스터에 노드가 3개라면 1개 노드의 장애를 견딜 수 있고, 5개라면 2개 노드의 장애를 견딜 수 있다.</p>
<h4 id="Reliable-solution"><a href="#Reliable-solution" class="headerlink" title="Reliable solution"></a>Reliable solution</h4><p>복제를 사용하면 파일 기반 이벤트 소싱 아키텍처에서 SPOF가 발생하지 않는다. </p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240103234722460.png" alt=""></p>
<p>다이어그램에서 3개의 이벤트 소싱 노드를 설정했다. 이 노드는 Raft 알고리즘을 사용해 이벤트 목록을 안정적으로 동기화한다.</p>
<p>리더는 외부 사용자로부터 들어오는 명령 요청을 받아 이벤트로 변환하고 로컬 이벤트 목록에 이벤트를 추가한다. Raft 알고리즘은 새로 추가된 이벤트를 팔로워에게 복제한다.</p>
<p>팔로워를 포함한 모든 노드가 이벤트 목록을 처리하고 상태를 업데이트한다. Raft 알고리즘은 리더와 팔로워가 동일한 이벤트 목록을 갖도록 보장하며, 이벤트 소싱은 이벤트 목록이 동일하기만 하면 모든 상태가 동일하도록 보장한다.</p>
<p>신뢰할 수 있는 시스템은 장애를 원활하게 처리해야 하므로 노드 충돌이 어떻게 처리되는지 살펴보자.</p>
<p>리더가 크래시되면 Raft 알고리즘은 나머지 정상 노드 중에서 새로운 리더를 자동으로 선택한다. 새로 선출된 리더는 외부 사용자의 명령을 수락할 책임이 있다. 노드가 다운되더라도 클러스터 전체가 계속 서비스를 제공할 수 있도록 보장한다.</p>
<p>리더가 다운되면 명령어 목록이 이벤트로 변환되기 전에 다운이 발생할 수 있다. 이 경우 클라이언트는 시간 초과 또는 오류 응답을 수신해 문제를 알아챌 수 있다. 클라이언트는 새로 선출된 리더에게 동일한 명령을 다시 보내야 한다.</p>
<p>이와는 대조적으로 팔로워 충돌은 처리하기가 훨씬 쉽다. 팔로워가 충돌하면 해당 팔로워로 전송된 요청이 실패한다. Raft는 충돌한 노드가 다시 시작되거나 새 노드가 이를 대체할 때까지 무한정 재시도하는 방식으로 실패를 처리한다.</p>
<p><strong>Candidate</strong>: 이 설계에선 Raft 알고리즘을 통해 여러 노드에 걸쳐 이벤트를 복제한다. 리더는 명령을 받아 다른 노드에 이벤트를 복제한다.</p>
<p><strong>Interviewer</strong>: 시스템이 더 안정적이고 내결함성이 좋아졌지만, 100만 TPS를 처리하려면 서버 한대만으로는 충분하지 않다. 어떻게 하면 좋을까?</p>
<h3 id="Distributed-event-sourcing"><a href="#Distributed-event-sourcing" class="headerlink" title="Distributed event sourcing"></a>Distributed event sourcing</h3><p>이전 섹션에서는 안정적인 고성은 이벤트 소싱 아키텍처를 구현하는 방법에 대해 설명했다. 이 아키텍처는 신뢰성 문제를 해결하지만 두 가지 한계가 있다.</p>
<p>디지털 지갑이 업데이트되면 업데이트된 결과를 즉시 받기를 원한다. 하지만 CQRS 설계에서는 요청 / 응답 흐름이 느려질 수 있다. 클라이언트는 디지털 지갑이 업데이트되는 시점을 정확히 알 수 없고, 주기적인 폴링에 의존해야 할 수도 있기 때문이다.</p>
<p>단일 Raft 그룹의 용량은 제한되어 있다. 일정 규모 이상에서는 데이터를 샤딩하고 분산 트랜잭션을 구현해야 한다.</p>
<p>이 두가지 문제에 대한 해결 방안을 살펴보자.</p>
<h4 id="Pull-vs-push"><a href="#Pull-vs-push" class="headerlink" title="Pull vs push"></a>Pull vs push</h4><p>Pull 모델에서는 외부 사용자가 읽기 전용 상태 머신에서 주기적으로 실행 상태를 폴링한다. 이 모델은 실시간이 아니며 폴링 빈도를 너무 높게 설정하면 지갑 서비스에 과부하가 걸릴 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240103235422310.png" alt=""></p>
<p>나이브한 pull 모델은 외부 사용자와 이벤트 소싱 노드 사이에 역방향 프록시를 추가해 개선할 수 있다. 이 설계에서는 외부 사용자가 역방향 프록시로 명령을 보내면, 역방향 프록시가 이벤트 소싱 노드로 명령을 전달하고 주기적으로 실행 상태를 폴링한다. 이 설계는 클라이언트 로직을 단순화하지만 통신은 여전히 실시간이 아니다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240103235521010.png" alt=""></p>
<p>역방향 프록시를 추가하면 읽기 전용 상태 머신을 수정해 응답 속도를 높일 수 있다. 앞서 언급했듯이 읽기 전용 상태 머신은 자체적인 동작을 가질 수 있다. 예를 들어, 읽기 전용 상태 머신이 이벤트를 수신하자마자 실행 상태를 역방향 프록시로 푸시하는 것이 한 가지 동작일 수 있다. 이렇게 하면 사용자가 실시간 응답을 받는다는 느낌을 받을 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240103235647639.png" alt=""></p>
<h4 id="Distributed-transaction"><a href="#Distributed-transaction" class="headerlink" title="Distributed transaction"></a>Distributed transaction</h4><p>모든 이벤트 소싱 노드 그룹에 동기 실행이 채택되면 분산 트랜잭션 솔루션인 TCC나 Saga를 채택할 수 있다. 키의 해시값을 2로 나누어 데이터를 분할한다고 가정하자.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240103235759966.png" alt=""></p>
<p>최종 분산 이벤트 소싱 아키텍처에서 송급이 어떻게 작동하는지 살펴보자. 이해하기 쉽도록 Saga를 사용하며 롤백 없는 방식만 설명한다.</p>
<p>송금 작업에는 두 가지 분산 작업이 포함된다. <code>A-1</code>과 <code>C+1</code>. 코디네이터는 아래와 같이 실행을 조정한다.</p>
<ol>
<li>사용자 A는 Saga 코디네이터에게 분산 트랜잭션을 전송한다. 여기에는 두 가지 연산이 포함된다. <code>A-1</code>과 <code>C+1</code>.</li>
<li>Saga 코디네이터는 트랜잭션의 상태를 추적하기 위해 단계 상태 테이블에 레코드를 생성한다.</li>
<li>Saga 코디네이터는 작업 순서를 검토한 후 A-1을 먼저 처리해야 한다고 결정한다. 코디네이터는 계정 A의 정보가 포함된 A-1을 명령으로 파티션 1에 보낸다.</li>
<li>파티션 1의 Raft 리더는 A-1 명령을 수신해 명령 목록에 저장한다. 그런 다음 명령의 유효성을 검사한다. 명령이 유효하면 이벤트로 변환된다. Raft 알고리즘은 서로 다른 노드에서 동기화하는데 사용된다. 동기화가 완료되면 이벤트(A의 계정 잔액에서 1을 차감)가 실행된다.</li>
<li>이벤트가 동기화된 후, 파티션 1의 이벤트 소싱 프레임워크는 CQRS를 사용하여 데이터를 읽기 경로에 동기화한다. 읽기 경로는 상태와 실행 상태를 재구성한다.</li>
<li>파티션 1의 읽기 경로는 상태를 이벤트 소싱 프레임워크의 호출자, 즉 Saga 코디네이터에 다시 푸시한다.</li>
<li>Saga 코디네이터는 파티션 1에서 성공 상태를 수신한다.</li>
<li>Saga 코디네이터는 파티션 1의 작업이 성공했음을 나타내는 레코드를 단계 상태 테이블에 생성한다.</li>
<li>첫 번째 작업이 성공했으므로 Saga 코디네이터는 두 번째 작업인 C+1을 실행한다. 코디네이터는 계정 C의 정보가 포함된 C+1을 명령으로 파티션 2에 보낸다.</li>
<li>파티션 2의 Raft 리더는 C+1 명령을 수신해 명령 목록에 저장한다. 그런 다음 명령의 유효성을 검사한다. 명령이 유효하면 이벤트로 변환된다. Raft 알고리즘은 서로 다른 노드에서 동기화하는데 사용된다. 동기화가 완료되면 이벤트(C의 계정 잔액에서 1을 추가)가 실행된다.</li>
<li>이벤트가 동기화된 후, 파티션 2의 이벤트 소싱 프레임워크는 CQRS를 사용하여 데이터를 읽기 경로에 동기화한다. 읽기 경로는 상태와 실행 상태를 재구성한다.</li>
<li>파티션 2의 읽기 경로는 상태를 이벤트 소싱 프레임워크의 호출자, 즉 Saga 코디네이터에 다시 푸시한다.</li>
<li>Saga 코디네이터는 파티션 2에서 성공 상태를 수신한다.</li>
<li>Saga 코디네이터는 파티션 2의 작업이 성공했음을 나타내는 레코드를 단계 상태 테이블에 생성한다.</li>
<li>이 때 모든 작업이 성공하고 분산 트랜잭션이 완료된다. Saga 코디네이터는 호출자에게 결과를 응답한다.</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240104000950908.png" alt=""></p>
<h2 id="Step-4-Wrap-Up"><a href="#Step-4-Wrap-Up" class="headerlink" title="Step 4 - Wrap Up"></a>Step 4 - Wrap Up</h2><p>이 포스트에선 초당 1M의 결제 요청을 처리하는 지갑 서비스를 설계했다. 추정치에서 이런 부하를 지원하기 위해서 수천개의 노드가 필요하다는 결론을 내렸다.</p>
<p>첫 번째 설계에서는 Redis와 같은 KV Store를 사용하는 솔루션을 제안했다. 이 설계의 문제는 데이터의 내구성이 떨어진다는 것이다.</p>
<p>두 번째 설계에선 인메모리 캐시가 트랜잭션 데이터베이스로 대체된다. 여러 노드를 지원하기 위해 2PC, TCC, Saga와 같은 다양한 트랜잭션 프로토콜이 제안된다. 트랜잭션 기반 솔루션의 가장 큰 문제점은 데이터 감사를 쉽게 수행할 수 없다는 점이다.</p>
<p>다음으로 이벤트 소싱을 살펴봤다. 처음에는 외부 데이터베이스와 큐를 통해 이벤트 소싱을 구현했지만 성능이 좋지 않았다. 로컬 노드에 명령어, 이벤트, 상태를 저장해 성능을 개선했다.</p>
<p>단일 노드는 SPOF를 의미한다. 시스템 안정성 향상을 위해 Raft 알고리즘을 통한 이벤트 노드 복제를 수행했다.</p>
<p>마지막으로 이벤트 소싱에 CQRS를 도입했다. 외부 사용자를 위해 비동기식 이벤트 소싱 프레임워크를 동기식 프레임워크로 변경하기 위해 역방향 프록시를 추가했다. TCC 또는 Saga 프로토콜은 여러 노드 그룹에서 명령 실행을 조정하는데 사용된다.</p>
<h2 id="Chapter-Summary"><a href="#Chapter-Summary" class="headerlink" title="Chapter Summary"></a>Chapter Summary</h2><p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20240104001308337.png" alt=""></p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2024/01/01/System%20Design/ByteByteGo/book/digital-wallet/">https://songhayoung.github.io/2024/01/01/System%20Design/ByteByteGo/book/digital-wallet/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2024 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>