<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[Effective Java] 타입 안전 이종 컨테이너를 고려하라"><meta name="keywords" content="JAVA"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[Effective Java] 타입 안전 이종 컨테이너를 고려하라 | SUMFIのBlog</title><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0"><span class="toc-number">1.</span> <span class="toc-text">들어가며</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-safe-heterogeneous-container-pattern"><span class="toc-number">2.</span> <span class="toc-text">type safe heterogeneous container pattern</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%A0%9C%EC%95%BD%EC%82%AC%ED%95%AD"><span class="toc-number">3.</span> <span class="toc-text">제약사항</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%83%80%EC%9E%85%EC%9D%98-%EC%A0%9C%ED%95%9C"><span class="toc-number">4.</span> <span class="toc-text">타입의 제한</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.instagram.com/hayoung0_0/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">6698</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">184</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">64</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[Effective Java] 타입 안전 이종 컨테이너를 고려하라</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-12</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/Effective-Java/">Effective Java</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1.2k</span><span class="post-meta__separator">|</span><span>Reading time: 7 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h2><span id="more"></span>
<p>제네릭은 <code>Set&lt;E&gt;, Map&lt;K,V&gt;</code>등의 컬렉션에도 흔히 쓰인다. 이런 모든 쓰임에서 매개변수화 되는 대상은 컨테이너 자신이다. 따라서 하나의 컨테이너에서 매개변수화할 수 있는 타입의 수가 제한된다. 하지만 더 유연한 수단이 필요할 때도 있다.</p>
<h2 id="type-safe-heterogeneous-container-pattern"><a href="#type-safe-heterogeneous-container-pattern" class="headerlink" title="type safe heterogeneous container pattern"></a>type safe heterogeneous container pattern</h2><p>타입 안전 이종 컨테이너 패턴(type safe heterogeneous container pattern) 이란 컨테이너 대신 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공하는 패턴이다. 이렇게 하면 제네릭 타입 시스템이 값의 타입이 키와 같음을 보장해준다.</p>
<p>다음은 간단한 예제 코드이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Favorites</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; favorites = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> &#123;</span><br><span class="line">        favorites.put(Objects.requireNonNull(type), Objects.requireNonNull(instance));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getFavorite</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type.cast(favorites.get(type));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Favorites</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Favorites</span>();</span><br><span class="line"></span><br><span class="line">    f.putFavorite(String.class, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">    f.putFavorite(Integer.class, <span class="number">0xcafebabe</span>);</span><br><span class="line">    f.putFavorite(Class.class, Favorites.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">favoriteString</span> <span class="operator">=</span> f.getFavorite(String.class);</span><br><span class="line">    <span class="type">int</span> <span class="variable">favoriteInteger</span> <span class="operator">=</span> f.getFavorite(Integer.class);</span><br><span class="line">    Class&lt;?&gt; favoriteClass = f.getFavorite(Class.class);</span><br><span class="line"></span><br><span class="line">    System.out.printf(<span class="string">&quot;%s %x %s\n&quot;</span>, favoriteString, favoriteInteger, favoriteClass.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드에서 각 타입의 Class 객체를 매개변수화한 키 역할로 사용하고 있는데 이 방식이 동작하는 이유는 class의 클래스가 제네릭이기 때문이다. <strong>class 리터럴의 타입은 Class가 아닌 Class\<T\>다.</strong> 예를들어 String.class의 타입은 Class\<String\>이고 Integer.class의 타입은 Class\<Integer\>인 방식이다.</p>
<p>또한 컴파일타임 타입 정보와 런타임 타입 정보를 알아내기 위해 메소드들이 주고받는 class 리터럴을 <strong>타입 토큰(type token)</strong>이라 한다.</p>
<p>Favorites 인스턴스는 타입 안전하다. String을 요청했는데 Integer를 반환하는 일은 절대없다. 또한 모든 키의 타입이 제각각이라 일반적인 맵과 달리 여러 가지 타입의 원소를 담을 수 있다. 따라서 Favorites는 타입 안전 이종 컨테이너라 할 만하다.</p>
<p>Favorites의 private Map variable을 보자. Map\<Class\<?\>, Object>이다. 비한정적 와일드카드 타입이라 이 맵 안에 아무것도 넣을 수 없다고 생각할 수 있지만 그 반대다. <strong>와일드카드 타입이 중첩(nested) 되었다</strong>는 점을 깨달아야 한다. 맵이 아니라 키가 와일드카드 타입인 것이다. 이는 모든 키가 서로 다른 매개변수화 타입일 수 있다는 뜻으로 첫번째는 Class\<String\>, 두번째는 Class\<Integer\>식으로 될 수 있다. 다양한 타입을 지원하는 힘은 여기서 나온다.</p>
<p>그 다음으로 봐야할 부분은 favorites Map의 값 타입은 Object라는 것이다. 이는 이 맵은 <strong>키와 값 사이의 타입 관계를 보증하지 않는다.</strong>라는 이야기다. 자바의 타입 시스템에서는 이 관계를 명시할 방법이 없다. 하지만 우리는 이 관계가 성립함을 알고 있고 검색할 때 그 이점을 누린다.</p>
<p>putFavorites는 쉽다. 주어진 Class 객체와 즐겨찾기 인스턴스를 favorites에 추가해 관계를 지으면 끝이다. 키와 값 사이의 <strong>타입 링크(type link)</strong> 정보는 버려진다. 즉, 그 값이 그 키 타입의 인스턴스라는 정보가 사라진다. 하지만 getFavorite에서 이를 되살린다.</p>
<p>getFavorite는 중요하다. 먼저 주어진 Class 객체에 해당하는 값을 favorites Map 에서 꺼낸다. 이 객체가 바로 반환해야할 객체임은 분병하지만 <strong>잘못된 컴파일타임 타입을 가지고 있다.</strong> 이 객체의 타입은 Object이나 이를 T로 바꾸어야 한다. 따라서 getFavorite 구현은 Class의 cast 메소드를 사용해 이 객체 참조를 Class 객체가 가리키는 타입으로 <strong>동적 형 변환</strong>을 수행한다.</p>
<p>cast 메소드는 형 변환 연산자의 동적 버전이다. 이 메소드는 단순히 주어진 인수가 Class 객체가 알려주는 타입의 인스턴스인지를 검사한 다음, 맞으면 인수를, 아니면 ClassCastException을 던진다. 클라이언트 코드가 깔끔히 컴파일 된다면 우리는 getFavorite이 ClassCastException을 던지지 않을 것임을 알고 있다. 그런데 cast 메소드가 인수를 그대로 반환한다면 이를 왜 사용할까? 그 이유는 cast 메소드의 시그니처가 Class 클래스가 제네릭 이라는 이점을 완벽히 활용하기 때문이다. 다음 코드를 보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Class</span>&lt;T&gt; &#123;</span><br><span class="line">	T <span class="title function_">cast</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드에서 보듯 cast의 반환 타입은 Class 객체의 타입 매개변수와 같다. 이것이 정확히 getFavorite 메소드에 필요한 기능으로 T로 비검사 형 변환하는 손실 없이도 Favorites를 타입 안전하게 만드는 비결이다.</p>
<h2 id="제약사항"><a href="#제약사항" class="headerlink" title="제약사항"></a>제약사항</h2><p>하지만 이 Favorites 클래스에는 두 가지 제약사항이 있다. 첫번째로는 악의적인 클라이언트가 Class 객체를 로 타입(non generic)으로 넘기면 Favorites 인스턴스의 타입 안전성이 쉽게 깨진다. 하지만 이렇게 짜여진 클라이언트 코드에서는 컴파일할 때 비검사 경고가 뜰 것이다. 다음 코드를 수행하면 런타임에 ClassCastException을 던진다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.putFavorite((Class)Integer.class, <span class="string">&quot;Integer의 인스턴스가 아닙니다.&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">favoriteInteger</span> <span class="operator">=</span> f.getFavorite(Integer.class);</span><br></pre></td></tr></table></figure>
<p>이는 HashSet과 HashMap 등의 일반 컬렉션 구현체도 가지고 있는 문제다. 예를 들어 HashSet의 로 타입을 사용하면 HashSet<Integer>에 String을 넣는건 아주 쉽다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">((HashSet)set).add(<span class="string">&quot;string&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>이는 Favorites가 타입 불변식을 어기는 일이 없도록 보장해야 한다. 방법은 간단하다. 동적 형변환을 수행하면 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> &#123;</span><br><span class="line">    favorites.put(Objects.requireNonNull(type), Objects.requireNonNull(type.cast(instance)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이와 같은 방법을 사용한 컬렉션들이 checkedSet, checkedList, checkedMap같은 컬렉션 래퍼들이다.</p>
<p>두번째 제약은 실체화 불가 타입에는 사용할 수 없다는 것이다. 다시 말해 String이나 String[]에는 저장할 수 있어도 List\<String\>이나 List\<Integer\>는 저장할 수 없다는 이야기다. List\<String\>용 Class 객체를 얻을 수 없기 때문이다. List\<String\>.class는 문법 오류다. <strong>List\<String\>과 List\<Integer\>는 둘 다 List.class라는 객체를 공유</strong>하므로 만약 List\<String\>.class와 List\<Integer\>.class를 허용해서 둘 다 같은 타입의 객체 참조를 반환한다면 Favorites 객체 내부는 아수라장이 되버린다. 이 두 번째 제약에 대한 우회로는 <strong>슈퍼 타입 토큰(super type token)</strong>이 있으나 이도 완벽한 방법은 아니다. 슈퍼 타입 토큰을 고안한 닐 개프터(Neal Gafter)가 고안하였고, 닐 개프터의 가까운 지인인 조슈아 블로크(Effective Java 3/E 저자)가 슈퍼 타입 토큰을 언급하지 않고 <strong>완벽히 만족스러운 우회로는 없다</strong>라고 한 이유도 있을것이며 이는 닐 개프터의 글을 참조하길 바란다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.putFavorite(<span class="keyword">new</span> <span class="title class_">TypeRef</span>&lt;List&lt;String&gt;&gt;()&#123;&#125;, listItems);</span><br><span class="line">List&lt;String&gt; returnItems = f.getFavorite(<span class="keyword">new</span> <span class="title class_">TypeRef</span>&lt;List&lt;String&gt;&gt;()&#123;&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="타입의-제한"><a href="#타입의-제한" class="headerlink" title="타입의 제한"></a>타입의 제한</h2><p>Favorites가 사용하는 타입 토큰은 비 한정적이다. 즉, getFavorite와 putFavorite는 어떤 Class 객체든 받아들인다. 때로는 이 메소드들이 허용하는 타입을 제한하고 싶을 때가 있는데 이 때는 한정적 타입 토큰을 활용하면 된다.</p>
<p>애너테이션 API는 한정적 타입 토큰을 적극적으로 사용한 예다. 다음 코드를 보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;A <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationClass) &#123;</span><br><span class="line">    Objects.requireNonNull(annotationClass);</span><br><span class="line"></span><br><span class="line">    <span class="type">AnnotationData</span> <span class="variable">annotationData</span> <span class="operator">=</span> annotationData();</span><br><span class="line">    <span class="keyword">return</span> AnnotationSupport.getAssociatedAnnotations(annotationData.declaredAnnotations,</span><br><span class="line">                                                      <span class="built_in">this</span>,</span><br><span class="line">                                                      annotationClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>여기서 annotationClass 인수는 애너테이션 타입을 뜻하는 한정적 타입 토큰이다. 이 메소드는 토큰으로 명시한 타입의 애너테이션 대상 요소에 달려 있다면 그 애너테이션을 반환하고 없다면 null을 반환한다. 즉, 애너테이션된 요소는 그 키가 애너테이션 타입인 타입 안전 이종 컨테이너인 것이다.</p>
<p>Class&lt;?&gt; 타입의 객체가 있고 이를 한정적 타입 토큰을 받는 메소드에 넘기려면 어떻게 해야 할까? 객체를 <code>Class&lt;? extends Annotation&gt;</code>으로 형 변환할 수도 있지만 이 형 변환은 비검사이므로 컴파일하면 경고가 뜰 것이다. 이 때는 asSubclass 메소드를 사용하면 된다. asSubclass 메소드는 형 변환을 안전하고 동적으로 수행하는 메소드이다. 이 메소드로 호출된 인스턴스 자신의 Class 객체를 인수가 명시한 클래스로 형변환한다. 형 변환에 성공하면 인수로 받은 클래스 객체를, 실패하면 ClassCastException을 던진다. 다음 코드는 컴파일 시점에는 타입을 알 수 없는 애너테이션을 asSubclass 메소드를 사용해 런타임에 읽어내는 예이다. 이 메소드는 오류나 경고 없이 컴파일된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Annotation <span class="title function_">getAnnotation</span><span class="params">(AnnotatedElement element, String annotationTypeName)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; annotationType = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        annotationType = Class.forName(annotationTypeName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element.getAnnotation(annotationType.asSubclass(Annotation.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2020/08/12/Effective%20JAVA/item33/">https://songhayoung.github.io/2020/08/12/Effective%20JAVA/item33/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/08/12/Java/concatAndPlus/"><i class="fa fa-chevron-left">  </i><span>[Java] String의 concat과 +</span></a></div><div class="next-post pull-right"><a href="/2020/08/12/Effective%20JAVA/item32/"><span>[Effective Java] 제네릭과 가변인수를 함께 쓸 때는 신중하라</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2023 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>