<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[ByteByteGo] Database Indexing Strategies - Part 2"><meta name="keywords" content="System Design"><meta name="author" content="Song Hayoung"><meta name="copyright" content="Song Hayoung"><title>[ByteByteGo] Database Indexing Strategies - Part 2 | SUMFIのBlog</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/songcon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169368422-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7LZ6OJ4D6C","apiKey":"9a84e13f74ea78c3fd54512c10139c56","indexName":"git blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="SUMFIのBlog" type="application/rss+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Database-Indexing-Strategies-Part-2"><span class="toc-number">1.</span> <span class="toc-text">Database Indexing Strategies - Part 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Indexing-in-Non-relational-Databases"><span class="toc-number">2.</span> <span class="toc-text">Indexing in Non-relational Databases</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NoSQL-LSM-Tree-and-Indexing"><span class="toc-number">2.1.</span> <span class="toc-text">NoSQL, LSM Tree, and Indexing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Secondary-Index-for-LSM-Tree-based-Databases"><span class="toc-number">2.2.</span> <span class="toc-text">Secondary Index for LSM Tree-based Databases</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Index-Use-Cases"><span class="toc-number">3.</span> <span class="toc-text">Index Use Cases</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Point-Lookup"><span class="toc-number">3.1.</span> <span class="toc-text">Point Lookup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Range-Lookup"><span class="toc-number">3.2.</span> <span class="toc-text">Range Lookup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prefix-Search"><span class="toc-number">3.3.</span> <span class="toc-text">Prefix Search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Geo-Location-Lookup"><span class="toc-number">3.4.</span> <span class="toc-text">Geo-Location Lookup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Text-Search"><span class="toc-number">3.5.</span> <span class="toc-text">Text Search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Partial-Index"><span class="toc-number">3.6.</span> <span class="toc-text">Partial Index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Join-Optimization"><span class="toc-number">3.7.</span> <span class="toc-text">Join Optimization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Order-By-Optimization"><span class="toc-number">3.8.</span> <span class="toc-text">Order By Optimization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Group-By-Optimization"><span class="toc-number">3.9.</span> <span class="toc-text">Group By Optimization</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SARGable-Queries"><span class="toc-number">4.</span> <span class="toc-text">SARGable Queries</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Indexing-Best-Practices"><span class="toc-number">5.</span> <span class="toc-text">Indexing Best Practices</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Determine-Our-Needs"><span class="toc-number">5.1.</span> <span class="toc-text">Determine Our Needs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Choose-the-Right-Columns-for-Indexing"><span class="toc-number">5.2.</span> <span class="toc-text">Choose the Right Columns for Indexing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Weigh-the-Cost-of-Updates-to-Indexed-Columns"><span class="toc-number">5.3.</span> <span class="toc-text">Weigh the Cost of Updates to Indexed Columns</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Limit-the-Number-of-Indexes"><span class="toc-number">5.4.</span> <span class="toc-text">Limit the Number of Indexes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Use-Composite-Indexes-Effectively"><span class="toc-number">5.5.</span> <span class="toc-text">Use Composite Indexes Effectively</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leverage-Covering-Indexes"><span class="toc-number">5.6.</span> <span class="toc-text">Leverage Covering Indexes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Regularly-Monitor-and-Optimize-the-Indexes"><span class="toc-number">5.7.</span> <span class="toc-text">Regularly Monitor and Optimize the Indexes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Drop-Unused-Indexes"><span class="toc-number">5.8.</span> <span class="toc-text">Drop Unused Indexes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">6.</span> <span class="toc-text">Conclusion</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/37806785?s=460&amp;u=8c68d685faf7c5280cfbd736a6b1730b55fb4203&amp;v=4"></div><div class="author-info__name text-center">Song Hayoung</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/hayoung-song-9523b61bb/">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">10496</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">193</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">61</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">VISITED</div><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Seoul Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Jeju Korea</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">British Columbia Canada</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Boracay Philippines</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">三重　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">大阪　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">名古屋　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">静岡　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">札幌　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">京都　日本</a><a class="author-info-links__name text-center" href="https://songhayoung.github.io/">Bangkok Thailand</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://xxxx.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SUMFIのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[ByteByteGo] Database Indexing Strategies - Part 2</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-08-04</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/">System Design</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/System-Design/Byte-Byte-Go/">Byte Byte Go</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1.9k</span><span class="post-meta__separator">|</span><span>Reading time: 11 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Database-Indexing-Strategies-Part-2"><a href="#Database-Indexing-Strategies-Part-2" class="headerlink" title="Database Indexing Strategies - Part 2"></a>Database Indexing Strategies - Part 2</h2><span id="more"></span>
<p>이번 포스트에서는 NoSQL 데이터베이스에서의 인덱싱이 어떻게 사용되는지에 대해 간략히 살펴본다.</p>
<h2 id="Indexing-in-Non-relational-Databases"><a href="#Indexing-in-Non-relational-Databases" class="headerlink" title="Indexing in Non-relational Databases"></a>Indexing in Non-relational Databases</h2><h3 id="NoSQL-LSM-Tree-and-Indexing"><a href="#NoSQL-LSM-Tree-and-Indexing" class="headerlink" title="NoSQL, LSM Tree, and Indexing"></a>NoSQL, LSM Tree, and Indexing</h3><p>NoSQL 데이터베이스는 유연성, 확장성, 대량의 정형 및 비정형 데이터를 처리할 수 있도록 설계된 광범위한 종류의 데이터베이스 시스템이다. 일부 유형의 NoSQL 데이터베이스, 특히 KV 및 와이드 컬럼 스토어에서 널리 사용되는 데이터 구조는 Log-Structured Merge-tree(LSM Tree)다. 기존의 B-Tree 기반 인덱스 구조와 달리, LSM 트리는 쓰기 집약적인 워크로드에 최적화되어 있어 데이터 수집 속도가 높은 애플리케이션에 이상적이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230804190830904.png" alt=""></p>
<p>LSM 트리는 그 자체로 일종의 인덱스다. 데이터를 별도의 구조로 유지하며, 각 구조는 정렬된 트리 기반 인덱스다. 적은 데이터는 메모리에 있고(MemTable) 많은 데이터는 디스크에 저장된다(SSTable). 쓰기 작업은 MemTable에서 먼저 이루어진다. MemTable이 특정 크기에 도달하면 멤테이블의 콘텐츠가 SSTable로 디스크에 플러시된다. LSM 트리의 장점은 읽기 작업 중에 나타난다. 데이터가 여러 구조에 분산되어 있기 때문에 읽기 경로가 더 복잡해지지만, LSM 트리는 블룸 필터 및 파티션 인덱스와 같은 기술을 사용해 필요한 데이터를 빠르게 찾을 수 있다.</p>
<h3 id="Secondary-Index-for-LSM-Tree-based-Databases"><a href="#Secondary-Index-for-LSM-Tree-based-Databases" class="headerlink" title="Secondary Index for LSM Tree-based Databases"></a>Secondary Index for LSM Tree-based Databases</h3><p>LSM 트리는 기본 키에 대한 포인트 조회 및 범위 쿼리를 수행하는 효율적인 방법이다. 그러나 기본 키가 아닌 키에 대한 쿼리를 수행하려면 전체 테이블을 스캔해야 하므로 비효율적이다. 이때 보조 인덱스가 유용하다. 이름에서 알 수 있듯이 보조 인덱스는 기본 키 필드가 아닌 다른 필드에 생성되는 인덱스다. 키에 따라 데이터가 인덱싱되는 기본 인덱스와 달리 보조 인덱스에서는 키가 아닌 속성을 기준으로 데이터가 인덱싱된다. 보조 인덱스는 데이터베이스 시스템이 데이터에 엑세스할 수 있는 대체 경로를 제공하므로 키와 관련이 없는 쿼리를 보다 효율적으로 처리할 수 있다.</p>
<p>LSM 트리 기반 데이터베이스에서 보조 인덱스를 생성하려면 새로운 LSM 트리를 생성해야 하는데, 여기서 키는 인덱스가 생성되는 필드의 값이고, 값은 해당 레코드의 기본 키다. 인덱싱된 필드와 관련된 쿼리가 실행되면 데이터베이스는 보조 인덱스를 사용하여 관련 레코드의 기본 키를 빠르게 찾은 다음 기본 인덱스에서 전체 레코드를 검색한다.</p>
<p>그러나 LSM 트리 기반 데이터베이스에서 보조 인덱스의 복잡성 중 하나는 업데이트 처리다. 쓰기 최적화된 LSM 트리의 특성으로 인해 이런 데이터베이스의 데이터는 일반적으로 변경 불가능하며, 이는 업데이트가 쓰기와 삭제의 조합으로 처리됨을 의미한다. 일관성을 유지하려면 기본 데이터 저장소와 보조 인덱스를 동시에 업데이트해야 한다. 이로 인해 성능 절충이 발생할 수 있으며 인덱스 일관성 유지의 복잡성이 증가할 수 있다.</p>
<h2 id="Index-Use-Cases"><a href="#Index-Use-Cases" class="headerlink" title="Index Use Cases"></a>Index Use Cases</h2><p>몇 가지 일반적인 인덱싱 사용 사례에 대해 살펴보자.</p>
<h3 id="Point-Lookup"><a href="#Point-Lookup" class="headerlink" title="Point Lookup"></a>Point Lookup</h3><p>인덱스의 가장 간단한 사용 사례는 특정 속성이나 키에 대한 검색 속도를 높이는 것이다. 예를 들어 <code>car_id</code>와 <code>color</code> 컬럼이 있는 테이블이 있다고 가정하자. <code>car_id</code>는 기본 키이므로 클러스터된 인덱스가 내재되어 있다. <code>car_id</code>로 자동차를 찾아야하는 경우 데이터베이스에서 정보를 빠르게 찾을 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230804191637285.png" alt=""></p>
<p>하지만 특정 색상의 모든 자동차를 찾아야 한다면 어떻게 해야할까? <code>color</code> 컬럼에 인덱스가 없으면 데이터베이스에서 풀 테이블 스캔이 발생한다. 이는 큰 테이블의 경우 시간이 많이 걸리는 프로세스다. <code>color</code> 열에 클러스터링 되지 않은 인덱스를 생성하면 데이터베이스가 특정 색상의 모든 자동차를 효율적으로 검색할 수 있으므로 전체 테이블 스캔을 훨씬 빠른 인덱스 스캔으로 전환할 수 있다.</p>
<h3 id="Range-Lookup"><a href="#Range-Lookup" class="headerlink" title="Range Lookup"></a>Range Lookup</h3><p>인덱스는 다양한 값을 효율적으로 검색하는 데에도 사용할 수 있다. <code>post_id</code>가 기본 키이고 <code>created_time</code>이 보조 키인 블로그 플랫폼을 예로 들어보자. 인덱스가 없으면 가장 최근 게시물 20개를 찾기 위해 데이터베이스가 모든 레코드를 스캔하고 <code>created_time</code>을 기준으로 정렬해야 한다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230804192200174.png" alt=""></p>
<p>그러나 <code>created_time</code>이 인덱싱된 경우 데이터베이스는 이 인덱스를 사용하여 가장 최근의 글을 빠르게 식별할 수 있다. <code>created_time</code>의 인덱스는 <code>post_id</code> 값을 생성된 순서대로 저장하므로 데이터베이스가 전체 테이블을 스캔하지 않고도 가장 최근의 항목을 효율적으로 찾을 수 있기 때문이다.</p>
<h3 id="Prefix-Search"><a href="#Prefix-Search" class="headerlink" title="Prefix Search"></a>Prefix Search</h3><p>색인은 정렬된 특성 덕분에 접두사 검색에도 유용하다. 검색 엔진이 이전에 검색된 용어로 그에 해당하는 인기도 점수를 테이블에 보관하는 시나리오를 살펴보자.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230804192327951.png" alt=""></p>
<p>사용자가 검색어를 입력하기 시작하면 엔진은 해당 접두사로 시작하는 가장 인기 있는 용어를 제안하고자 한다. 검색어에 대한 B-Tree 인덱스를 사용하면 엔진이 주어진 접두사가 포함된 모든 용어를 효율적으로 찾을 수 있다. 이런 용어가 발견되면 인기도 점수별로 정렬하여 가장 관련성이 높은 제안을 제공할 수 있다.</p>
<p>이 시나리오에서 접두사 검색은 각 노드가 특정 문자열의 접두사를 나타내는 특수한 종류의 트리인 Trie 또는 접두사 트리를 사용해 더욱 최적화할 수 있다.</p>
<h3 id="Geo-Location-Lookup"><a href="#Geo-Location-Lookup" class="headerlink" title="Geo-Location Lookup"></a>Geo-Location Lookup</h3><p>GeoHash는 지구를 격자로 나누는 공간 인덱스의 한 형태이다. 그리드의 각 셀에는 고유한 해시가 할당되며, 같은 셀 내의 포인트는 동일한 해시 접두사를 공유한다. 따라서 GeoHash는 특정 근접 거리 내의 위치를 쿼리하는데 적합하다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230804192538116.png" alt=""></p>
<p>특정 위치의 특정 반경 내에 있는 모든 지점을 찾으려면 대상 위치와 GeoHash 접두사를 공유하는 지점만 검색하면 된다. 데이터베이스의 모든 지점까지의 거리를 계산하는 것보다 빠르다.</p>
<h3 id="Text-Search"><a href="#Text-Search" class="headerlink" title="Text Search"></a>Text Search</h3><p>큰 텍스트 블록을 검색하는 애플리케이션이라면 전체 텍스트 인덱스가 매우 유용할 수 있다. 전체 텍스트 인덱스는 큰 텍스트 문자열 내에서 빠른 텍스트 검색을 가능하게 한다. 예를 들어, 블로그 플랫폼에서 사용자가 게시물의 콘텐츠를 검색할 수 있도록 허용하고 싶을 수 있다. ‘content’ 컬럼에 전체 텍스트 인덱스를 사용하면 이런 검색 속도를 크게 높일 수 있다.</p>
<h3 id="Partial-Index"><a href="#Partial-Index" class="headerlink" title="Partial Index"></a>Partial Index</h3><p>테이블 데이터의 하위 집합만 정기적으로 쿼리하는 경우도 있다. 필터링된 인덱스라고도 하는 부분 인덱스는 특정 조건을 충족하는 행만 인덱싱한다. 이렇게 하면 쿼리할 가능성이 없는 행을 무시하여 공간을 절약하고 성능을 개선할 수 있다. 예를 들어, 전자상거래 애플리케이션에 ‘staus’ 컬럼이 있는 주문 테이블이 있다고 하자. 애플리케이션에서 배송되지 않은 주문을 자주 쿼리하는 경우 ‘status’ 컬럼의 값이 ‘unshipped’인 부분 인덱스가 유용할 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230804192912858.png" alt=""></p>
<h3 id="Join-Optimization"><a href="#Join-Optimization" class="headerlink" title="Join Optimization"></a>Join Optimization</h3><p>쿼리에 둘 이상의 테이블 간에 조인 작업이 포함된 경우 인덱스가 유용할 수 있다. 조인되는 열에 인덱스가 있으면 데이터베이스가 두 테이블의 모든 행을 스캔하지 않고도 일치하는 레코드를 빠르게 식별할 수 있다. 이렇게 하면 쿼리 실행 시간을 크게 단축할 수 있다. 예를 들어 <code>customer_id</code> 필드를 기준으로 고객 테이블과 주문 테이블을 조인할 때 두 테이블 모두에 <code>customer_id</code>에 대한 인덱스가 있으면 데이터베이스가 주문을 각 고객과 빠르게 일치시킬 수 있다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230804193059791.png" alt=""></p>
<h3 id="Order-By-Optimization"><a href="#Order-By-Optimization" class="headerlink" title="Order By Optimization"></a>Order By Optimization</h3><p>쿼리에 특정 열에 ORDER BY 절이 자주 포함되는 경우 해당 열을 인덱싱하는 것을 고려해야 한다. 인덱스는 특정 순서대로 행을 저장하므로 쿼리가 실행될 때마다 데이터베이스에서 데이터를 정렬할 필요가 줄어든다. 예를 들어, 블로그 게시물의 <code>publish_date</code>를 기준으로 순서를 지정하는 쿼리를 자주 실행하는 경우 <code>publish_date</code> 열에 인덱스를 생성하면 이런 쿼리를 효율적으로 실행할 수 있다.</p>
<h3 id="Group-By-Optimization"><a href="#Group-By-Optimization" class="headerlink" title="Group By Optimization"></a>Group By Optimization</h3><p>ORDER BY 절과 마찬가지로 GROUP BY 절도 인덱싱의 이점을 누릴 수 있다. 특정 열을 기준으로 결과를 자주 그룹화하는 경우 데이터베이스는 해당 열의 인덱스를 활용하여 행을 더 빠르게 그룹화할 수 있다. 이는 그룹화 비용이 높을 수 있는 대규모 데이터 집합을 처리할 때 특히 유용하다.</p>
<h2 id="SARGable-Queries"><a href="#SARGable-Queries" class="headerlink" title="SARGable Queries"></a>SARGable Queries</h2><p>SARGable은 “Search Argument-able”의 약자로, 인덱스를 활용하여 데이터 검색 속도를 높일 수 있는 쿼리를 의미한다. SARGable 쿼리를 작성하는 것은 데이터베이스 최적화의 중요한 측면이다. 쿼리가 SARGable인 경우 데이터베이스 엔진은 인덱스를 사용하여 필요한 데이터를 효율적으로 찾을 수 있다. 그러나 쿼리가 SARGable이 아닌 경우, 데이터베이스 엔진은 테이블의 모든 행을 스캔해야 할 수 있으며, 특히 대규모 데이터 세트의 경우 작업 속도가 훨씬 느려진다.</p>
<p>SARGable 쿼리의 작성을 위한 주요 아이디어는 데이터베이스 엔진이 인덱스에서 정확한 값을 검색할 수 있는 표현식을 작성하는 것이다. 아래는 몇가지 팁이다.</p>
<ul>
<li>인덱싱된 열에 함수를 사용하는 것을 피하라. WHERE 절 내에서 인덱싱된 열에 함수를 사용하거나 계산을 수행하면 데이터베이스 엔진이 인덱스를 직접 사용할 수 없다. 예를 들어, <code>WHERE YEAR(date_column) = 2023</code>을 사용하는 것은 SARG하지 못하다. 대신 이 조건을 <code>WHERE date_column BETWEEN &#39;2023-01-01&#39; AND &#39;2023-12-31&#39;</code>로 재작성할 수 있다.</li>
<li>비교 연산자를 신중하게 사용하라.  <code>=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>BETWWEN</code>과 같은 연산자는 SARG가 가능하지만 NOT, LIKE(후행 와일드카드와 함께 사용하지 않는 경우), &lt;&gt;와 같은 연산은 데이터베이스에 따라 불가능할 수 있다.</li>
<li>인덱스 순서를 고려하라. 복합 인덱스를 사용할 때는 WHERE 절에 있는 열의 순서가 중요하다는 점을 기억하게요. 인덱스가 열(A, B, C)에 있는 경우 열 A 또는 열 A와 B에 대한 쿼리 필터링은 인덱스를 활용할 수 있지만 열 B와 C에 대한 쿼리 필터링은 사용할 수 없다.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230804193906008.png" alt=""></p>
<h2 id="Indexing-Best-Practices"><a href="#Indexing-Best-Practices" class="headerlink" title="Indexing Best Practices"></a>Indexing Best Practices</h2><p>데이터베이스 인덱싱을 이해하는 것은 올바른 인덱스를 선택하는 데 관련된 다양한 고려사항과 장단점을 고려할 때 어려운 작업이 될 수 있다. 다음은 몇가지 모범 사례이다.</p>
<p><img src="https://cdn.jsdelivr.net/gh/SongHayoung/image@master/uPic/image-20230804194044019.png" alt=""></p>
<h3 id="Determine-Our-Needs"><a href="#Determine-Our-Needs" class="headerlink" title="Determine Our Needs"></a>Determine Our Needs</h3><p>인덱스를 생성하기 전에 애플리케이션의 요구 사항을 명확하게 이해해야 한다. 여기에는 애플리케이션의 워크로드에 대한 철저한 분석이 포함된다. 가장 일반적인 쿼리를 식별하고 그 사용 빈도를 파악한다. 또한 애플리케이션의 읽기 대 쓰기 비율을 결정한다. 인덱싱을 읽기 성능을 향상시키지만 쓰기 성능을 저하시킬 수 있다. 애플리케이션이 읽기보다 쓰기를 더 많이 수행하는 경우 인덱스가 너무 많으면 전체 성능에 부정적인 영향을 미칠 수 있다. 마찬가지로 애플리케이션이 읽기 위주인 경우 적절한 인덱싱을 통해 효율성을 크게 향상시킬 수 있다.</p>
<h3 id="Choose-the-Right-Columns-for-Indexing"><a href="#Choose-the-Right-Columns-for-Indexing" class="headerlink" title="Choose the Right Columns for Indexing"></a>Choose the Right Columns for Indexing</h3><p>인덱싱할 열을 결정할 때는 쿼리에서 해당 열의 용도에 따라 결정해야 한다. 인덱스는 WHERE절, ORDER BY절, JOIN 조건에서 자주 사용되거나 데이터를 정렬 및 그룹화하는 데 사용되는 열에 생성하는 것이 이상적이다.</p>
<p>고유성이 높은 열은 인덱싱에 이상적인 후보이다. 이러한 열의 인덱스를 사용하면 데이터베이스 엔진이 대부분의 데이터를 빠르게 필터링할 수 있다. 따라서 쿼리 결과가 더 빨라진다. NULL 값이 많은 열이나 유사한 값이 많은 열은 색인하지 않는 것이 좋다.</p>
<h3 id="Weigh-the-Cost-of-Updates-to-Indexed-Columns"><a href="#Weigh-the-Cost-of-Updates-to-Indexed-Columns" class="headerlink" title="Weigh the Cost of Updates to Indexed Columns"></a>Weigh the Cost of Updates to Indexed Columns</h3><p>인덱스는 데이터 검색 속도를 높여주지만 데이터 수정 속도를 떨어트린다. 데이터가 추가, 삭제 또는 수정될 때마다 해당 인덱스도 업데이트해야 하기 때문이다. 열이 자주 업데이트되는 경우, 인덱스 업데이트에 따른 오버헤드가 데이터 검색중에 얻은 성능 이점을 무효화할 수 있다. 인덱스 업데이트 시간이 데이터 검색 중에 절약되는 시간보다 더 길다면 인덱스를 유지할 가치가 없을 수 있다.</p>
<h3 id="Limit-the-Number-of-Indexes"><a href="#Limit-the-Number-of-Indexes" class="headerlink" title="Limit the Number of Indexes"></a>Limit the Number of Indexes</h3><p>인덱스는 쿼리 성능에 도움이 되지만, 인덱스가 너무 많으면 쓰기 작업의 성능에 부정적인 영향을 미치고 디스크 공간을 더 많이 차지할 수 있다. 데이터가 삽입되거나 업데이트될 때마다 테이블의 모든 인덱스가 업데이트 되어야 한다. 인덱스를 유지 관리하는 데 드는 비용이 인덱스가 제공하는 성능상의 이점보다 더 클 수 있다. 워크로드의 특성에 따라 적절한 균형을 유지하고 인덱스 수를 제한하는 것이 중요하다. 데이터베이스 시스템에서 제공하는 모니터링 도구를 활용하여 인덱스의 업데이트 시간이 불균형적으로 증가하고 있는지 파악한다.</p>
<h3 id="Use-Composite-Indexes-Effectively"><a href="#Use-Composite-Indexes-Effectively" class="headerlink" title="Use Composite Indexes Effectively"></a>Use Composite Indexes Effectively</h3><p>두 개 이상의 열로 구성된 복합 인덱스는 WHERE 절에 여러 열이 포함된 복잡한 쿼리에 매우 유용할 수 있다. 복합 인덱스에서 열의 순서는 매우 중요하다. 일반적으로 열의 카디널리티를 기준으로 해야 하며, 고유 값의 수가 가장 많은 열이 인덱스에서 가장 먼저 나타난다. 이 순서를 통해 데이터베이스 엔진은 불필요한 데이터를 효율적으로 필터링할 수 있다. 예를 들어 주문 테이블의 <code>customer_name</code> 및 <code>country</code> 열에 복합 인덱스를 생성하는 경우 고객 이름보다 고유한 국가 수가 적은 경우 인덱스는 <code>(country, customerName)</code>이이 되어야 한다.</p>
<p>이 가이드라인은 일반적인 경험 법칙이며 항상 올바른 것은 아니라는 점에 유의해야 한ㄷ. 옵티마이저가 실제로 의도한 대로 복합 인덱스를 사용하는지 확인한다.</p>
<h3 id="Leverage-Covering-Indexes"><a href="#Leverage-Covering-Indexes" class="headerlink" title="Leverage Covering Indexes"></a>Leverage Covering Indexes</h3><p>커버링 인덱스는 쿼리에 필요한 모든 열을 WHERE 절과 SELECT 목록에 모두 포함한다. 즉, 데이터베이스 엔진은 기본 테이블에서 추가 조회를 수행할 필요 없이 인덱스 자체 내에서 필요한 모든 데이터를 찾을 수 있다. 일반적으로 인덱스에 엑세스하는 것이 테이블 데이터에 엑세스하는 것보다 빠르기 때문에 성능이 크게 향상된다. 자주 사용되는 읽기 집약적인 쿼리에는 커버링 인덱스를 사용하는 것이 좋다.</p>
<h3 id="Regularly-Monitor-and-Optimize-the-Indexes"><a href="#Regularly-Monitor-and-Optimize-the-Indexes" class="headerlink" title="Regularly Monitor and Optimize the Indexes"></a>Regularly Monitor and Optimize the Indexes</h3><p>인덱스는 데이터베이스에서 한 번 설정하면 잊어버릴 수 있는 부분이 아니다. 데이터가 증가하고 변경됨에 따라 인덱스를 모니터링하고 최적화 해야한다. 시간이 지남에 따라 데이터가 추가, 업데이트, 삭제됨에 따라 인덱스가 조각화되어 성능에 부정적인 영향을 미칠 수 있다. 조각난 인덱스를 재구축하거나 재구성하는 등 인덱스 유지 관리 작업을 정기적으로 수행하면 최적의 성능을 계속 제공할 수 있다. SQL Server의 데이터베이스 엔진 튜닝 어드바이저 또는 MySQL의 테이블 최적화 명령과 같은 데이터베이스 도구는 사용할 수 있는 도구의 몇 가지 예이다. MySQL의 느린 쿼리 로그와 같은 로그를 모니터링 하는 것도 문제를 조기에 발견하는 데 중요하다.</p>
<h3 id="Drop-Unused-Indexes"><a href="#Drop-Unused-Indexes" class="headerlink" title="Drop Unused Indexes"></a>Drop Unused Indexes</h3><p>모든 인덱스가 의도한 대로 사용되는 것은 아니다. 일부는 거의 사용되지 않거나 전혀 사용되지 않을 수도 있다. 이런 인덱스는 쓰기 작업에 불필요한 오버헤드를 부과하고 저장 공간을 낭비한다. 데이터베이스의 기본 제공 도구를 사용하여 인덱스 사용량을 모니터링하고 더 이상 목적에 맞지 않는 인덱스는 주저하지 말고 삭제해야 한다. 예를 들어 PostgreSQL에서는 <code>pg_stat_user_indexes</code>를 통해 인덱스 사용량을 추적할 수 있다.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>데이터베이스 인덱싱은 데이터베이스 효율성을 최적화하는 데 있어 매우 중요한 부분이다. 인덱싱은 데이터 검색 속도와 쓰기 작업 성능 간의 균형을 맞추는 데 있어 핵심적인 요소다. 하지만 인덱싱이 모든 것을 해결할 수 있는 솔루션은 아니다. 신중한 설계, 정기적인 모니터링 및 유지 관리는 인덱싱 전략의 이점을 극대화하는데 필수적인 요소다. 다양한 데이터베이스에 특정한 색인 기술을 인식하면 데이터 작업을 크게 개선할 수 있다.</p>
<p>잘 구현된 인덱싱 전략은 고성능 데이터베이스의 기본이다. 데이터베이스 인덱싱 기술을 숙달하는 것은 대규모 데이터 기반 애플리케이션을 구축하는 모든 사람에게 필수적인 기술이다.</p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Song Hayoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songhayoung.github.io/2023/08/04/System%20Design/ByteByteGo/private/database-indexing-strategies-2/">https://songhayoung.github.io/2023/08/04/System%20Design/ByteByteGo/private/database-indexing-strategies-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System-Design/">System Design</a></div><nav id="pagination"></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '3604b61642355579f55e',
  clientSecret: 'f552120f18ac5aee3f6297e05e97d94c0a25cd4b',
  repo: 'SongHayoung.github.io',
  owner: 'SongHayoung',
  admin: 'SongHayoung',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://xxxx.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2024 By Song Hayoung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Learning how to walk slowly to not miss important things</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>